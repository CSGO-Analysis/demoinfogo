// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct GameServerPing {
    // message fields
    gameserver_id: ::std::option::Option<u64>,
    ping: ::std::option::Option<i32>,
    ip: ::std::option::Option<u32>,
    port: ::std::option::Option<u32>,
    instances: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GameServerPing {}

impl GameServerPing {
    pub fn new() -> GameServerPing {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GameServerPing {
        static mut instance: ::protobuf::lazy::Lazy<GameServerPing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GameServerPing,
        };
        unsafe {
            instance.get(GameServerPing::new)
        }
    }

    // optional uint64 gameserver_id = 1;

    pub fn clear_gameserver_id(&mut self) {
        self.gameserver_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_id(&self) -> bool {
        self.gameserver_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_id(&mut self, v: u64) {
        self.gameserver_id = ::std::option::Option::Some(v);
    }

    pub fn get_gameserver_id(&self) -> u64 {
        self.gameserver_id.unwrap_or(0)
    }

    fn get_gameserver_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.gameserver_id
    }

    fn mut_gameserver_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.gameserver_id
    }

    // optional int32 ping = 2;

    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: i32) {
        self.ping = ::std::option::Option::Some(v);
    }

    pub fn get_ping(&self) -> i32 {
        self.ping.unwrap_or(0)
    }

    fn get_ping_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.ping
    }

    fn mut_ping_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.ping
    }

    // optional uint32 ip = 3;

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    pub fn get_ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    fn get_ip_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ip
    }

    fn mut_ip_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ip
    }

    // optional uint32 port = 4;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    fn get_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.port
    }

    // optional uint32 instances = 5;

    pub fn clear_instances(&mut self) {
        self.instances = ::std::option::Option::None;
    }

    pub fn has_instances(&self) -> bool {
        self.instances.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instances(&mut self, v: u32) {
        self.instances = ::std::option::Option::Some(v);
    }

    pub fn get_instances(&self) -> u32 {
        self.instances.unwrap_or(0)
    }

    fn get_instances_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.instances
    }

    fn mut_instances_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.instances
    }
}

impl ::protobuf::Message for GameServerPing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gameserver_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ping = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ip = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.instances = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gameserver_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.instances {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gameserver_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.ping {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.instances {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GameServerPing {
    fn new() -> GameServerPing {
        GameServerPing::new()
    }

    fn descriptor_static(_: ::std::option::Option<GameServerPing>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gameserver_id",
                    GameServerPing::get_gameserver_id_for_reflect,
                    GameServerPing::mut_gameserver_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ping",
                    GameServerPing::get_ping_for_reflect,
                    GameServerPing::mut_ping_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ip",
                    GameServerPing::get_ip_for_reflect,
                    GameServerPing::mut_ip_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    GameServerPing::get_port_for_reflect,
                    GameServerPing::mut_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "instances",
                    GameServerPing::get_instances_for_reflect,
                    GameServerPing::mut_instances_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GameServerPing>(
                    "GameServerPing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GameServerPing {
    fn clear(&mut self) {
        self.clear_gameserver_id();
        self.clear_ping();
        self.clear_ip();
        self.clear_port();
        self.clear_instances();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameServerPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameServerPing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DetailedSearchStatistic {
    // message fields
    game_type: ::std::option::Option<u32>,
    search_time_avg: ::std::option::Option<u32>,
    players_searching: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DetailedSearchStatistic {}

impl DetailedSearchStatistic {
    pub fn new() -> DetailedSearchStatistic {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DetailedSearchStatistic {
        static mut instance: ::protobuf::lazy::Lazy<DetailedSearchStatistic> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DetailedSearchStatistic,
        };
        unsafe {
            instance.get(DetailedSearchStatistic::new)
        }
    }

    // optional uint32 game_type = 1;

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    fn get_game_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_type
    }

    fn mut_game_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_type
    }

    // optional uint32 search_time_avg = 2;

    pub fn clear_search_time_avg(&mut self) {
        self.search_time_avg = ::std::option::Option::None;
    }

    pub fn has_search_time_avg(&self) -> bool {
        self.search_time_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_time_avg(&mut self, v: u32) {
        self.search_time_avg = ::std::option::Option::Some(v);
    }

    pub fn get_search_time_avg(&self) -> u32 {
        self.search_time_avg.unwrap_or(0)
    }

    fn get_search_time_avg_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.search_time_avg
    }

    fn mut_search_time_avg_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.search_time_avg
    }

    // optional uint32 players_searching = 4;

    pub fn clear_players_searching(&mut self) {
        self.players_searching = ::std::option::Option::None;
    }

    pub fn has_players_searching(&self) -> bool {
        self.players_searching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_searching(&mut self, v: u32) {
        self.players_searching = ::std::option::Option::Some(v);
    }

    pub fn get_players_searching(&self) -> u32 {
        self.players_searching.unwrap_or(0)
    }

    fn get_players_searching_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.players_searching
    }

    fn mut_players_searching_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.players_searching
    }
}

impl ::protobuf::Message for DetailedSearchStatistic {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.search_time_avg = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.players_searching = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.search_time_avg {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.players_searching {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.search_time_avg {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.players_searching {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DetailedSearchStatistic {
    fn new() -> DetailedSearchStatistic {
        DetailedSearchStatistic::new()
    }

    fn descriptor_static(_: ::std::option::Option<DetailedSearchStatistic>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    DetailedSearchStatistic::get_game_type_for_reflect,
                    DetailedSearchStatistic::mut_game_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "search_time_avg",
                    DetailedSearchStatistic::get_search_time_avg_for_reflect,
                    DetailedSearchStatistic::mut_search_time_avg_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "players_searching",
                    DetailedSearchStatistic::get_players_searching_for_reflect,
                    DetailedSearchStatistic::mut_players_searching_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DetailedSearchStatistic>(
                    "DetailedSearchStatistic",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DetailedSearchStatistic {
    fn clear(&mut self) {
        self.clear_game_type();
        self.clear_search_time_avg();
        self.clear_players_searching();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DetailedSearchStatistic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetailedSearchStatistic {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TournamentPlayer {
    // message fields
    account_id: ::std::option::Option<u32>,
    player_nick: ::protobuf::SingularField<::std::string::String>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    player_dob: ::std::option::Option<u32>,
    player_flag: ::protobuf::SingularField<::std::string::String>,
    player_location: ::protobuf::SingularField<::std::string::String>,
    player_desc: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TournamentPlayer {}

impl TournamentPlayer {
    pub fn new() -> TournamentPlayer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TournamentPlayer {
        static mut instance: ::protobuf::lazy::Lazy<TournamentPlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TournamentPlayer,
        };
        unsafe {
            instance.get(TournamentPlayer::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional string player_nick = 2;

    pub fn clear_player_nick(&mut self) {
        self.player_nick.clear();
    }

    pub fn has_player_nick(&self) -> bool {
        self.player_nick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_nick(&mut self, v: ::std::string::String) {
        self.player_nick = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_nick(&mut self) -> &mut ::std::string::String {
        if self.player_nick.is_none() {
            self.player_nick.set_default();
        }
        self.player_nick.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_nick(&mut self) -> ::std::string::String {
        self.player_nick.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_nick(&self) -> &str {
        match self.player_nick.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_player_nick_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.player_nick
    }

    fn mut_player_nick_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.player_nick
    }

    // optional string player_name = 3;

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_player_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.player_name
    }

    fn mut_player_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.player_name
    }

    // optional uint32 player_dob = 4;

    pub fn clear_player_dob(&mut self) {
        self.player_dob = ::std::option::Option::None;
    }

    pub fn has_player_dob(&self) -> bool {
        self.player_dob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_dob(&mut self, v: u32) {
        self.player_dob = ::std::option::Option::Some(v);
    }

    pub fn get_player_dob(&self) -> u32 {
        self.player_dob.unwrap_or(0)
    }

    fn get_player_dob_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_dob
    }

    fn mut_player_dob_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_dob
    }

    // optional string player_flag = 5;

    pub fn clear_player_flag(&mut self) {
        self.player_flag.clear();
    }

    pub fn has_player_flag(&self) -> bool {
        self.player_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_flag(&mut self, v: ::std::string::String) {
        self.player_flag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_flag(&mut self) -> &mut ::std::string::String {
        if self.player_flag.is_none() {
            self.player_flag.set_default();
        }
        self.player_flag.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_flag(&mut self) -> ::std::string::String {
        self.player_flag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_flag(&self) -> &str {
        match self.player_flag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_player_flag_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.player_flag
    }

    fn mut_player_flag_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.player_flag
    }

    // optional string player_location = 6;

    pub fn clear_player_location(&mut self) {
        self.player_location.clear();
    }

    pub fn has_player_location(&self) -> bool {
        self.player_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_location(&mut self, v: ::std::string::String) {
        self.player_location = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_location(&mut self) -> &mut ::std::string::String {
        if self.player_location.is_none() {
            self.player_location.set_default();
        }
        self.player_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_location(&mut self) -> ::std::string::String {
        self.player_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_location(&self) -> &str {
        match self.player_location.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_player_location_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.player_location
    }

    fn mut_player_location_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.player_location
    }

    // optional string player_desc = 7;

    pub fn clear_player_desc(&mut self) {
        self.player_desc.clear();
    }

    pub fn has_player_desc(&self) -> bool {
        self.player_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_desc(&mut self, v: ::std::string::String) {
        self.player_desc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_desc(&mut self) -> &mut ::std::string::String {
        if self.player_desc.is_none() {
            self.player_desc.set_default();
        }
        self.player_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_desc(&mut self) -> ::std::string::String {
        self.player_desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_desc(&self) -> &str {
        match self.player_desc.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_player_desc_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.player_desc
    }

    fn mut_player_desc_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.player_desc
    }
}

impl ::protobuf::Message for TournamentPlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_nick)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_dob = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_flag)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_location)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_desc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_nick.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.player_dob {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_flag.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.player_location.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.player_desc.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.player_nick.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.player_dob {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.player_flag.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.player_location.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.player_desc.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TournamentPlayer {
    fn new() -> TournamentPlayer {
        TournamentPlayer::new()
    }

    fn descriptor_static(_: ::std::option::Option<TournamentPlayer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    TournamentPlayer::get_account_id_for_reflect,
                    TournamentPlayer::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_nick",
                    TournamentPlayer::get_player_nick_for_reflect,
                    TournamentPlayer::mut_player_nick_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_name",
                    TournamentPlayer::get_player_name_for_reflect,
                    TournamentPlayer::mut_player_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_dob",
                    TournamentPlayer::get_player_dob_for_reflect,
                    TournamentPlayer::mut_player_dob_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_flag",
                    TournamentPlayer::get_player_flag_for_reflect,
                    TournamentPlayer::mut_player_flag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_location",
                    TournamentPlayer::get_player_location_for_reflect,
                    TournamentPlayer::mut_player_location_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_desc",
                    TournamentPlayer::get_player_desc_for_reflect,
                    TournamentPlayer::mut_player_desc_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TournamentPlayer>(
                    "TournamentPlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TournamentPlayer {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_player_nick();
        self.clear_player_name();
        self.clear_player_dob();
        self.clear_player_flag();
        self.clear_player_location();
        self.clear_player_desc();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TournamentPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TournamentTeam {
    // message fields
    team_id: ::std::option::Option<i32>,
    team_tag: ::protobuf::SingularField<::std::string::String>,
    team_flag: ::protobuf::SingularField<::std::string::String>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    players: ::protobuf::RepeatedField<TournamentPlayer>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TournamentTeam {}

impl TournamentTeam {
    pub fn new() -> TournamentTeam {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TournamentTeam {
        static mut instance: ::protobuf::lazy::Lazy<TournamentTeam> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TournamentTeam,
        };
        unsafe {
            instance.get(TournamentTeam::new)
        }
    }

    // optional int32 team_id = 1;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.team_id
    }

    // optional string team_tag = 2;

    pub fn clear_team_tag(&mut self) {
        self.team_tag.clear();
    }

    pub fn has_team_tag(&self) -> bool {
        self.team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_tag(&mut self, v: ::std::string::String) {
        self.team_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
        if self.team_tag.is_none() {
            self.team_tag.set_default();
        }
        self.team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_tag(&mut self) -> ::std::string::String {
        self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_tag(&self) -> &str {
        match self.team_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_tag_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_tag
    }

    fn mut_team_tag_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_tag
    }

    // optional string team_flag = 3;

    pub fn clear_team_flag(&mut self) {
        self.team_flag.clear();
    }

    pub fn has_team_flag(&self) -> bool {
        self.team_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_flag(&mut self, v: ::std::string::String) {
        self.team_flag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_flag(&mut self) -> &mut ::std::string::String {
        if self.team_flag.is_none() {
            self.team_flag.set_default();
        }
        self.team_flag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_flag(&mut self) -> ::std::string::String {
        self.team_flag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_flag(&self) -> &str {
        match self.team_flag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_flag_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_flag
    }

    fn mut_team_flag_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_flag
    }

    // optional string team_name = 4;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // repeated .TournamentPlayer players = 5;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<TournamentPlayer>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<TournamentPlayer> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<TournamentPlayer> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[TournamentPlayer] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<TournamentPlayer> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<TournamentPlayer> {
        &mut self.players
    }
}

impl ::protobuf::Message for TournamentTeam {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_tag)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_flag)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.team_flag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.team_tag.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.team_flag.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.players {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TournamentTeam {
    fn new() -> TournamentTeam {
        TournamentTeam::new()
    }

    fn descriptor_static(_: ::std::option::Option<TournamentTeam>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id",
                    TournamentTeam::get_team_id_for_reflect,
                    TournamentTeam::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_tag",
                    TournamentTeam::get_team_tag_for_reflect,
                    TournamentTeam::mut_team_tag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_flag",
                    TournamentTeam::get_team_flag_for_reflect,
                    TournamentTeam::mut_team_flag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    TournamentTeam::get_team_name_for_reflect,
                    TournamentTeam::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentPlayer>>(
                    "players",
                    TournamentTeam::get_players_for_reflect,
                    TournamentTeam::mut_players_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TournamentTeam>(
                    "TournamentTeam",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TournamentTeam {
    fn clear(&mut self) {
        self.clear_team_id();
        self.clear_team_tag();
        self.clear_team_flag();
        self.clear_team_name();
        self.clear_players();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TournamentTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentTeam {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TournamentEvent {
    // message fields
    event_id: ::std::option::Option<i32>,
    event_tag: ::protobuf::SingularField<::std::string::String>,
    event_name: ::protobuf::SingularField<::std::string::String>,
    event_time_start: ::std::option::Option<u32>,
    event_time_end: ::std::option::Option<u32>,
    event_public: ::std::option::Option<i32>,
    event_stage_id: ::std::option::Option<i32>,
    event_stage_name: ::protobuf::SingularField<::std::string::String>,
    active_section_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TournamentEvent {}

impl TournamentEvent {
    pub fn new() -> TournamentEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TournamentEvent {
        static mut instance: ::protobuf::lazy::Lazy<TournamentEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TournamentEvent,
        };
        unsafe {
            instance.get(TournamentEvent::new)
        }
    }

    // optional int32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.event_id
    }

    // optional string event_tag = 2;

    pub fn clear_event_tag(&mut self) {
        self.event_tag.clear();
    }

    pub fn has_event_tag(&self) -> bool {
        self.event_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_tag(&mut self, v: ::std::string::String) {
        self.event_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_tag(&mut self) -> &mut ::std::string::String {
        if self.event_tag.is_none() {
            self.event_tag.set_default();
        }
        self.event_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_tag(&mut self) -> ::std::string::String {
        self.event_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_event_tag(&self) -> &str {
        match self.event_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_event_tag_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.event_tag
    }

    fn mut_event_tag_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.event_tag
    }

    // optional string event_name = 3;

    pub fn clear_event_name(&mut self) {
        self.event_name.clear();
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name.set_default();
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_event_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.event_name
    }

    fn mut_event_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.event_name
    }

    // optional uint32 event_time_start = 4;

    pub fn clear_event_time_start(&mut self) {
        self.event_time_start = ::std::option::Option::None;
    }

    pub fn has_event_time_start(&self) -> bool {
        self.event_time_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time_start(&mut self, v: u32) {
        self.event_time_start = ::std::option::Option::Some(v);
    }

    pub fn get_event_time_start(&self) -> u32 {
        self.event_time_start.unwrap_or(0)
    }

    fn get_event_time_start_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_time_start
    }

    fn mut_event_time_start_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_time_start
    }

    // optional uint32 event_time_end = 5;

    pub fn clear_event_time_end(&mut self) {
        self.event_time_end = ::std::option::Option::None;
    }

    pub fn has_event_time_end(&self) -> bool {
        self.event_time_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time_end(&mut self, v: u32) {
        self.event_time_end = ::std::option::Option::Some(v);
    }

    pub fn get_event_time_end(&self) -> u32 {
        self.event_time_end.unwrap_or(0)
    }

    fn get_event_time_end_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_time_end
    }

    fn mut_event_time_end_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_time_end
    }

    // optional int32 event_public = 6;

    pub fn clear_event_public(&mut self) {
        self.event_public = ::std::option::Option::None;
    }

    pub fn has_event_public(&self) -> bool {
        self.event_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_public(&mut self, v: i32) {
        self.event_public = ::std::option::Option::Some(v);
    }

    pub fn get_event_public(&self) -> i32 {
        self.event_public.unwrap_or(0)
    }

    fn get_event_public_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.event_public
    }

    fn mut_event_public_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.event_public
    }

    // optional int32 event_stage_id = 7;

    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }

    fn get_event_stage_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.event_stage_id
    }

    fn mut_event_stage_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.event_stage_id
    }

    // optional string event_stage_name = 8;

    pub fn clear_event_stage_name(&mut self) {
        self.event_stage_name.clear();
    }

    pub fn has_event_stage_name(&self) -> bool {
        self.event_stage_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_name(&mut self, v: ::std::string::String) {
        self.event_stage_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stage_name(&mut self) -> &mut ::std::string::String {
        if self.event_stage_name.is_none() {
            self.event_stage_name.set_default();
        }
        self.event_stage_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stage_name(&mut self) -> ::std::string::String {
        self.event_stage_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_event_stage_name(&self) -> &str {
        match self.event_stage_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_event_stage_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.event_stage_name
    }

    fn mut_event_stage_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.event_stage_name
    }

    // optional uint32 active_section_id = 9;

    pub fn clear_active_section_id(&mut self) {
        self.active_section_id = ::std::option::Option::None;
    }

    pub fn has_active_section_id(&self) -> bool {
        self.active_section_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_section_id(&mut self, v: u32) {
        self.active_section_id = ::std::option::Option::Some(v);
    }

    pub fn get_active_section_id(&self) -> u32 {
        self.active_section_id.unwrap_or(0)
    }

    fn get_active_section_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.active_section_id
    }

    fn mut_active_section_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.active_section_id
    }
}

impl ::protobuf::Message for TournamentEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.event_tag)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.event_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_time_start = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_time_end = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_public = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_stage_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.event_stage_name)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_section_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.event_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.event_time_start {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_time_end {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_public {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.event_stage_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.active_section_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.event_tag.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.event_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.event_time_start {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_time_end {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.event_public {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(7, v)?;
        }
        if let Some(ref v) = self.event_stage_name.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.active_section_id {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TournamentEvent {
    fn new() -> TournamentEvent {
        TournamentEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<TournamentEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_id",
                    TournamentEvent::get_event_id_for_reflect,
                    TournamentEvent::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "event_tag",
                    TournamentEvent::get_event_tag_for_reflect,
                    TournamentEvent::mut_event_tag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "event_name",
                    TournamentEvent::get_event_name_for_reflect,
                    TournamentEvent::mut_event_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_time_start",
                    TournamentEvent::get_event_time_start_for_reflect,
                    TournamentEvent::mut_event_time_start_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_time_end",
                    TournamentEvent::get_event_time_end_for_reflect,
                    TournamentEvent::mut_event_time_end_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_public",
                    TournamentEvent::get_event_public_for_reflect,
                    TournamentEvent::mut_event_public_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_stage_id",
                    TournamentEvent::get_event_stage_id_for_reflect,
                    TournamentEvent::mut_event_stage_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "event_stage_name",
                    TournamentEvent::get_event_stage_name_for_reflect,
                    TournamentEvent::mut_event_stage_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active_section_id",
                    TournamentEvent::get_active_section_id_for_reflect,
                    TournamentEvent::mut_active_section_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TournamentEvent>(
                    "TournamentEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TournamentEvent {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_event_tag();
        self.clear_event_name();
        self.clear_event_time_start();
        self.clear_event_time_end();
        self.clear_event_public();
        self.clear_event_stage_id();
        self.clear_event_stage_name();
        self.clear_active_section_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TournamentEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalStatistics {
    // message fields
    players_online: ::std::option::Option<u32>,
    servers_online: ::std::option::Option<u32>,
    players_searching: ::std::option::Option<u32>,
    servers_available: ::std::option::Option<u32>,
    ongoing_matches: ::std::option::Option<u32>,
    search_time_avg: ::std::option::Option<u32>,
    search_statistics: ::protobuf::RepeatedField<DetailedSearchStatistic>,
    main_post_url: ::protobuf::SingularField<::std::string::String>,
    required_appid_version: ::std::option::Option<u32>,
    pricesheet_version: ::std::option::Option<u32>,
    twitch_streams_version: ::std::option::Option<u32>,
    active_tournament_eventid: ::std::option::Option<u32>,
    active_survey_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GlobalStatistics {}

impl GlobalStatistics {
    pub fn new() -> GlobalStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GlobalStatistics {
        static mut instance: ::protobuf::lazy::Lazy<GlobalStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GlobalStatistics,
        };
        unsafe {
            instance.get(GlobalStatistics::new)
        }
    }

    // optional uint32 players_online = 1;

    pub fn clear_players_online(&mut self) {
        self.players_online = ::std::option::Option::None;
    }

    pub fn has_players_online(&self) -> bool {
        self.players_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_online(&mut self, v: u32) {
        self.players_online = ::std::option::Option::Some(v);
    }

    pub fn get_players_online(&self) -> u32 {
        self.players_online.unwrap_or(0)
    }

    fn get_players_online_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.players_online
    }

    fn mut_players_online_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.players_online
    }

    // optional uint32 servers_online = 2;

    pub fn clear_servers_online(&mut self) {
        self.servers_online = ::std::option::Option::None;
    }

    pub fn has_servers_online(&self) -> bool {
        self.servers_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servers_online(&mut self, v: u32) {
        self.servers_online = ::std::option::Option::Some(v);
    }

    pub fn get_servers_online(&self) -> u32 {
        self.servers_online.unwrap_or(0)
    }

    fn get_servers_online_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.servers_online
    }

    fn mut_servers_online_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.servers_online
    }

    // optional uint32 players_searching = 3;

    pub fn clear_players_searching(&mut self) {
        self.players_searching = ::std::option::Option::None;
    }

    pub fn has_players_searching(&self) -> bool {
        self.players_searching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_searching(&mut self, v: u32) {
        self.players_searching = ::std::option::Option::Some(v);
    }

    pub fn get_players_searching(&self) -> u32 {
        self.players_searching.unwrap_or(0)
    }

    fn get_players_searching_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.players_searching
    }

    fn mut_players_searching_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.players_searching
    }

    // optional uint32 servers_available = 4;

    pub fn clear_servers_available(&mut self) {
        self.servers_available = ::std::option::Option::None;
    }

    pub fn has_servers_available(&self) -> bool {
        self.servers_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servers_available(&mut self, v: u32) {
        self.servers_available = ::std::option::Option::Some(v);
    }

    pub fn get_servers_available(&self) -> u32 {
        self.servers_available.unwrap_or(0)
    }

    fn get_servers_available_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.servers_available
    }

    fn mut_servers_available_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.servers_available
    }

    // optional uint32 ongoing_matches = 5;

    pub fn clear_ongoing_matches(&mut self) {
        self.ongoing_matches = ::std::option::Option::None;
    }

    pub fn has_ongoing_matches(&self) -> bool {
        self.ongoing_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ongoing_matches(&mut self, v: u32) {
        self.ongoing_matches = ::std::option::Option::Some(v);
    }

    pub fn get_ongoing_matches(&self) -> u32 {
        self.ongoing_matches.unwrap_or(0)
    }

    fn get_ongoing_matches_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ongoing_matches
    }

    fn mut_ongoing_matches_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ongoing_matches
    }

    // optional uint32 search_time_avg = 6;

    pub fn clear_search_time_avg(&mut self) {
        self.search_time_avg = ::std::option::Option::None;
    }

    pub fn has_search_time_avg(&self) -> bool {
        self.search_time_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_time_avg(&mut self, v: u32) {
        self.search_time_avg = ::std::option::Option::Some(v);
    }

    pub fn get_search_time_avg(&self) -> u32 {
        self.search_time_avg.unwrap_or(0)
    }

    fn get_search_time_avg_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.search_time_avg
    }

    fn mut_search_time_avg_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.search_time_avg
    }

    // repeated .DetailedSearchStatistic search_statistics = 7;

    pub fn clear_search_statistics(&mut self) {
        self.search_statistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_search_statistics(&mut self, v: ::protobuf::RepeatedField<DetailedSearchStatistic>) {
        self.search_statistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_search_statistics(&mut self) -> &mut ::protobuf::RepeatedField<DetailedSearchStatistic> {
        &mut self.search_statistics
    }

    // Take field
    pub fn take_search_statistics(&mut self) -> ::protobuf::RepeatedField<DetailedSearchStatistic> {
        ::std::mem::replace(&mut self.search_statistics, ::protobuf::RepeatedField::new())
    }

    pub fn get_search_statistics(&self) -> &[DetailedSearchStatistic] {
        &self.search_statistics
    }

    fn get_search_statistics_for_reflect(&self) -> &::protobuf::RepeatedField<DetailedSearchStatistic> {
        &self.search_statistics
    }

    fn mut_search_statistics_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<DetailedSearchStatistic> {
        &mut self.search_statistics
    }

    // optional string main_post_url = 8;

    pub fn clear_main_post_url(&mut self) {
        self.main_post_url.clear();
    }

    pub fn has_main_post_url(&self) -> bool {
        self.main_post_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_post_url(&mut self, v: ::std::string::String) {
        self.main_post_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_post_url(&mut self) -> &mut ::std::string::String {
        if self.main_post_url.is_none() {
            self.main_post_url.set_default();
        }
        self.main_post_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_post_url(&mut self) -> ::std::string::String {
        self.main_post_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_main_post_url(&self) -> &str {
        match self.main_post_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_main_post_url_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.main_post_url
    }

    fn mut_main_post_url_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.main_post_url
    }

    // optional uint32 required_appid_version = 9;

    pub fn clear_required_appid_version(&mut self) {
        self.required_appid_version = ::std::option::Option::None;
    }

    pub fn has_required_appid_version(&self) -> bool {
        self.required_appid_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_appid_version(&mut self, v: u32) {
        self.required_appid_version = ::std::option::Option::Some(v);
    }

    pub fn get_required_appid_version(&self) -> u32 {
        self.required_appid_version.unwrap_or(0)
    }

    fn get_required_appid_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.required_appid_version
    }

    fn mut_required_appid_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.required_appid_version
    }

    // optional uint32 pricesheet_version = 10;

    pub fn clear_pricesheet_version(&mut self) {
        self.pricesheet_version = ::std::option::Option::None;
    }

    pub fn has_pricesheet_version(&self) -> bool {
        self.pricesheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pricesheet_version(&mut self, v: u32) {
        self.pricesheet_version = ::std::option::Option::Some(v);
    }

    pub fn get_pricesheet_version(&self) -> u32 {
        self.pricesheet_version.unwrap_or(0)
    }

    fn get_pricesheet_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pricesheet_version
    }

    fn mut_pricesheet_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pricesheet_version
    }

    // optional uint32 twitch_streams_version = 11;

    pub fn clear_twitch_streams_version(&mut self) {
        self.twitch_streams_version = ::std::option::Option::None;
    }

    pub fn has_twitch_streams_version(&self) -> bool {
        self.twitch_streams_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twitch_streams_version(&mut self, v: u32) {
        self.twitch_streams_version = ::std::option::Option::Some(v);
    }

    pub fn get_twitch_streams_version(&self) -> u32 {
        self.twitch_streams_version.unwrap_or(0)
    }

    fn get_twitch_streams_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.twitch_streams_version
    }

    fn mut_twitch_streams_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.twitch_streams_version
    }

    // optional uint32 active_tournament_eventid = 12;

    pub fn clear_active_tournament_eventid(&mut self) {
        self.active_tournament_eventid = ::std::option::Option::None;
    }

    pub fn has_active_tournament_eventid(&self) -> bool {
        self.active_tournament_eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_tournament_eventid(&mut self, v: u32) {
        self.active_tournament_eventid = ::std::option::Option::Some(v);
    }

    pub fn get_active_tournament_eventid(&self) -> u32 {
        self.active_tournament_eventid.unwrap_or(0)
    }

    fn get_active_tournament_eventid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.active_tournament_eventid
    }

    fn mut_active_tournament_eventid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.active_tournament_eventid
    }

    // optional uint32 active_survey_id = 13;

    pub fn clear_active_survey_id(&mut self) {
        self.active_survey_id = ::std::option::Option::None;
    }

    pub fn has_active_survey_id(&self) -> bool {
        self.active_survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_survey_id(&mut self, v: u32) {
        self.active_survey_id = ::std::option::Option::Some(v);
    }

    pub fn get_active_survey_id(&self) -> u32 {
        self.active_survey_id.unwrap_or(0)
    }

    fn get_active_survey_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.active_survey_id
    }

    fn mut_active_survey_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.active_survey_id
    }
}

impl ::protobuf::Message for GlobalStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.search_statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.players_online = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.servers_online = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.players_searching = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.servers_available = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ongoing_matches = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.search_time_avg = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.search_statistics)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.main_post_url)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.required_appid_version = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pricesheet_version = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.twitch_streams_version = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_tournament_eventid = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_survey_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.players_online {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.servers_online {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.players_searching {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.servers_available {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ongoing_matches {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.search_time_avg {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.search_statistics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.main_post_url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.required_appid_version {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pricesheet_version {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.twitch_streams_version {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_tournament_eventid {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_survey_id {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.players_online {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.servers_online {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.players_searching {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.servers_available {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ongoing_matches {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.search_time_avg {
            os.write_uint32(6, v)?;
        }
        for v in &self.search_statistics {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.main_post_url.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.required_appid_version {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.pricesheet_version {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.twitch_streams_version {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.active_tournament_eventid {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.active_survey_id {
            os.write_uint32(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GlobalStatistics {
    fn new() -> GlobalStatistics {
        GlobalStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<GlobalStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "players_online",
                    GlobalStatistics::get_players_online_for_reflect,
                    GlobalStatistics::mut_players_online_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "servers_online",
                    GlobalStatistics::get_servers_online_for_reflect,
                    GlobalStatistics::mut_servers_online_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "players_searching",
                    GlobalStatistics::get_players_searching_for_reflect,
                    GlobalStatistics::mut_players_searching_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "servers_available",
                    GlobalStatistics::get_servers_available_for_reflect,
                    GlobalStatistics::mut_servers_available_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ongoing_matches",
                    GlobalStatistics::get_ongoing_matches_for_reflect,
                    GlobalStatistics::mut_ongoing_matches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "search_time_avg",
                    GlobalStatistics::get_search_time_avg_for_reflect,
                    GlobalStatistics::mut_search_time_avg_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DetailedSearchStatistic>>(
                    "search_statistics",
                    GlobalStatistics::get_search_statistics_for_reflect,
                    GlobalStatistics::mut_search_statistics_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "main_post_url",
                    GlobalStatistics::get_main_post_url_for_reflect,
                    GlobalStatistics::mut_main_post_url_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "required_appid_version",
                    GlobalStatistics::get_required_appid_version_for_reflect,
                    GlobalStatistics::mut_required_appid_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pricesheet_version",
                    GlobalStatistics::get_pricesheet_version_for_reflect,
                    GlobalStatistics::mut_pricesheet_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "twitch_streams_version",
                    GlobalStatistics::get_twitch_streams_version_for_reflect,
                    GlobalStatistics::mut_twitch_streams_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active_tournament_eventid",
                    GlobalStatistics::get_active_tournament_eventid_for_reflect,
                    GlobalStatistics::mut_active_tournament_eventid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active_survey_id",
                    GlobalStatistics::get_active_survey_id_for_reflect,
                    GlobalStatistics::mut_active_survey_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GlobalStatistics>(
                    "GlobalStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GlobalStatistics {
    fn clear(&mut self) {
        self.clear_players_online();
        self.clear_servers_online();
        self.clear_players_searching();
        self.clear_servers_available();
        self.clear_ongoing_matches();
        self.clear_search_time_avg();
        self.clear_search_statistics();
        self.clear_main_post_url();
        self.clear_required_appid_version();
        self.clear_pricesheet_version();
        self.clear_twitch_streams_version();
        self.clear_active_tournament_eventid();
        self.clear_active_survey_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationalStatisticDescription {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    idkey: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for OperationalStatisticDescription {}

impl OperationalStatisticDescription {
    pub fn new() -> OperationalStatisticDescription {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static OperationalStatisticDescription {
        static mut instance: ::protobuf::lazy::Lazy<OperationalStatisticDescription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationalStatisticDescription,
        };
        unsafe {
            instance.get(OperationalStatisticDescription::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint32 idkey = 2;

    pub fn clear_idkey(&mut self) {
        self.idkey = ::std::option::Option::None;
    }

    pub fn has_idkey(&self) -> bool {
        self.idkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idkey(&mut self, v: u32) {
        self.idkey = ::std::option::Option::Some(v);
    }

    pub fn get_idkey(&self) -> u32 {
        self.idkey.unwrap_or(0)
    }

    fn get_idkey_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.idkey
    }

    fn mut_idkey_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.idkey
    }
}

impl ::protobuf::Message for OperationalStatisticDescription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.idkey = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.idkey {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.idkey {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for OperationalStatisticDescription {
    fn new() -> OperationalStatisticDescription {
        OperationalStatisticDescription::new()
    }

    fn descriptor_static(_: ::std::option::Option<OperationalStatisticDescription>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    OperationalStatisticDescription::get_name_for_reflect,
                    OperationalStatisticDescription::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "idkey",
                    OperationalStatisticDescription::get_idkey_for_reflect,
                    OperationalStatisticDescription::mut_idkey_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationalStatisticDescription>(
                    "OperationalStatisticDescription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for OperationalStatisticDescription {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_idkey();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationalStatisticDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationalStatisticElement {
    // message fields
    idkey: ::std::option::Option<u32>,
    values: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for OperationalStatisticElement {}

impl OperationalStatisticElement {
    pub fn new() -> OperationalStatisticElement {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static OperationalStatisticElement {
        static mut instance: ::protobuf::lazy::Lazy<OperationalStatisticElement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationalStatisticElement,
        };
        unsafe {
            instance.get(OperationalStatisticElement::new)
        }
    }

    // optional uint32 idkey = 1;

    pub fn clear_idkey(&mut self) {
        self.idkey = ::std::option::Option::None;
    }

    pub fn has_idkey(&self) -> bool {
        self.idkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idkey(&mut self, v: u32) {
        self.idkey = ::std::option::Option::Some(v);
    }

    pub fn get_idkey(&self) -> u32 {
        self.idkey.unwrap_or(0)
    }

    fn get_idkey_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.idkey
    }

    fn mut_idkey_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.idkey
    }

    // repeated int32 values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<i32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[i32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.values
    }
}

impl ::protobuf::Message for OperationalStatisticElement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.idkey = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.idkey {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.idkey {
            os.write_uint32(1, v)?;
        }
        for v in &self.values {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for OperationalStatisticElement {
    fn new() -> OperationalStatisticElement {
        OperationalStatisticElement::new()
    }

    fn descriptor_static(_: ::std::option::Option<OperationalStatisticElement>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "idkey",
                    OperationalStatisticElement::get_idkey_for_reflect,
                    OperationalStatisticElement::mut_idkey_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "values",
                    OperationalStatisticElement::get_values_for_reflect,
                    OperationalStatisticElement::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationalStatisticElement>(
                    "OperationalStatisticElement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for OperationalStatisticElement {
    fn clear(&mut self) {
        self.clear_idkey();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationalStatisticElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticElement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationalStatisticsPacket {
    // message fields
    packetid: ::std::option::Option<i32>,
    mstimestamp: ::std::option::Option<i32>,
    values: ::protobuf::RepeatedField<OperationalStatisticElement>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for OperationalStatisticsPacket {}

impl OperationalStatisticsPacket {
    pub fn new() -> OperationalStatisticsPacket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static OperationalStatisticsPacket {
        static mut instance: ::protobuf::lazy::Lazy<OperationalStatisticsPacket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationalStatisticsPacket,
        };
        unsafe {
            instance.get(OperationalStatisticsPacket::new)
        }
    }

    // optional int32 packetid = 1;

    pub fn clear_packetid(&mut self) {
        self.packetid = ::std::option::Option::None;
    }

    pub fn has_packetid(&self) -> bool {
        self.packetid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packetid(&mut self, v: i32) {
        self.packetid = ::std::option::Option::Some(v);
    }

    pub fn get_packetid(&self) -> i32 {
        self.packetid.unwrap_or(0)
    }

    fn get_packetid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.packetid
    }

    fn mut_packetid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.packetid
    }

    // optional int32 mstimestamp = 2;

    pub fn clear_mstimestamp(&mut self) {
        self.mstimestamp = ::std::option::Option::None;
    }

    pub fn has_mstimestamp(&self) -> bool {
        self.mstimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mstimestamp(&mut self, v: i32) {
        self.mstimestamp = ::std::option::Option::Some(v);
    }

    pub fn get_mstimestamp(&self) -> i32 {
        self.mstimestamp.unwrap_or(0)
    }

    fn get_mstimestamp_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.mstimestamp
    }

    fn mut_mstimestamp_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.mstimestamp
    }

    // repeated .OperationalStatisticElement values = 3;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<OperationalStatisticElement>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<OperationalStatisticElement> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<OperationalStatisticElement> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }

    pub fn get_values(&self) -> &[OperationalStatisticElement] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::protobuf::RepeatedField<OperationalStatisticElement> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<OperationalStatisticElement> {
        &mut self.values
    }
}

impl ::protobuf::Message for OperationalStatisticsPacket {
    fn is_initialized(&self) -> bool {
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.packetid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mstimestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packetid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mstimestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packetid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mstimestamp {
            os.write_int32(2, v)?;
        }
        for v in &self.values {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for OperationalStatisticsPacket {
    fn new() -> OperationalStatisticsPacket {
        OperationalStatisticsPacket::new()
    }

    fn descriptor_static(_: ::std::option::Option<OperationalStatisticsPacket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "packetid",
                    OperationalStatisticsPacket::get_packetid_for_reflect,
                    OperationalStatisticsPacket::mut_packetid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mstimestamp",
                    OperationalStatisticsPacket::get_mstimestamp_for_reflect,
                    OperationalStatisticsPacket::mut_mstimestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationalStatisticElement>>(
                    "values",
                    OperationalStatisticsPacket::get_values_for_reflect,
                    OperationalStatisticsPacket::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationalStatisticsPacket>(
                    "OperationalStatisticsPacket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for OperationalStatisticsPacket {
    fn clear(&mut self) {
        self.clear_packetid();
        self.clear_mstimestamp();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationalStatisticsPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticsPacket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerRankingInfo {
    // message fields
    account_id: ::std::option::Option<u32>,
    rank_id: ::std::option::Option<u32>,
    wins: ::std::option::Option<u32>,
    rank_change: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PlayerRankingInfo {}

impl PlayerRankingInfo {
    pub fn new() -> PlayerRankingInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PlayerRankingInfo {
        static mut instance: ::protobuf::lazy::Lazy<PlayerRankingInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlayerRankingInfo,
        };
        unsafe {
            instance.get(PlayerRankingInfo::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 rank_id = 2;

    pub fn clear_rank_id(&mut self) {
        self.rank_id = ::std::option::Option::None;
    }

    pub fn has_rank_id(&self) -> bool {
        self.rank_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_id(&mut self, v: u32) {
        self.rank_id = ::std::option::Option::Some(v);
    }

    pub fn get_rank_id(&self) -> u32 {
        self.rank_id.unwrap_or(0)
    }

    fn get_rank_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rank_id
    }

    fn mut_rank_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rank_id
    }

    // optional uint32 wins = 3;

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    pub fn get_wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    fn get_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wins
    }

    fn mut_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wins
    }

    // optional float rank_change = 4;

    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: f32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    pub fn get_rank_change(&self) -> f32 {
        self.rank_change.unwrap_or(0.)
    }

    fn get_rank_change_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.rank_change
    }

    fn mut_rank_change_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.rank_change
    }
}

impl ::protobuf::Message for PlayerRankingInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wins = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rank_change = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_change {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rank_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PlayerRankingInfo {
    fn new() -> PlayerRankingInfo {
        PlayerRankingInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<PlayerRankingInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    PlayerRankingInfo::get_account_id_for_reflect,
                    PlayerRankingInfo::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank_id",
                    PlayerRankingInfo::get_rank_id_for_reflect,
                    PlayerRankingInfo::mut_rank_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wins",
                    PlayerRankingInfo::get_wins_for_reflect,
                    PlayerRankingInfo::mut_wins_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rank_change",
                    PlayerRankingInfo::get_rank_change_for_reflect,
                    PlayerRankingInfo::mut_rank_change_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerRankingInfo>(
                    "PlayerRankingInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PlayerRankingInfo {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_rank_id();
        self.clear_wins();
        self.clear_rank_change();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerRankingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerRankingInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerCommendationInfo {
    // message fields
    cmd_friendly: ::std::option::Option<u32>,
    cmd_teaching: ::std::option::Option<u32>,
    cmd_leader: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PlayerCommendationInfo {}

impl PlayerCommendationInfo {
    pub fn new() -> PlayerCommendationInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PlayerCommendationInfo {
        static mut instance: ::protobuf::lazy::Lazy<PlayerCommendationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlayerCommendationInfo,
        };
        unsafe {
            instance.get(PlayerCommendationInfo::new)
        }
    }

    // optional uint32 cmd_friendly = 1;

    pub fn clear_cmd_friendly(&mut self) {
        self.cmd_friendly = ::std::option::Option::None;
    }

    pub fn has_cmd_friendly(&self) -> bool {
        self.cmd_friendly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_friendly(&mut self, v: u32) {
        self.cmd_friendly = ::std::option::Option::Some(v);
    }

    pub fn get_cmd_friendly(&self) -> u32 {
        self.cmd_friendly.unwrap_or(0)
    }

    fn get_cmd_friendly_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cmd_friendly
    }

    fn mut_cmd_friendly_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cmd_friendly
    }

    // optional uint32 cmd_teaching = 2;

    pub fn clear_cmd_teaching(&mut self) {
        self.cmd_teaching = ::std::option::Option::None;
    }

    pub fn has_cmd_teaching(&self) -> bool {
        self.cmd_teaching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_teaching(&mut self, v: u32) {
        self.cmd_teaching = ::std::option::Option::Some(v);
    }

    pub fn get_cmd_teaching(&self) -> u32 {
        self.cmd_teaching.unwrap_or(0)
    }

    fn get_cmd_teaching_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cmd_teaching
    }

    fn mut_cmd_teaching_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cmd_teaching
    }

    // optional uint32 cmd_leader = 4;

    pub fn clear_cmd_leader(&mut self) {
        self.cmd_leader = ::std::option::Option::None;
    }

    pub fn has_cmd_leader(&self) -> bool {
        self.cmd_leader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_leader(&mut self, v: u32) {
        self.cmd_leader = ::std::option::Option::Some(v);
    }

    pub fn get_cmd_leader(&self) -> u32 {
        self.cmd_leader.unwrap_or(0)
    }

    fn get_cmd_leader_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cmd_leader
    }

    fn mut_cmd_leader_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cmd_leader
    }
}

impl ::protobuf::Message for PlayerCommendationInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd_friendly = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd_teaching = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd_leader = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cmd_friendly {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cmd_teaching {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cmd_leader {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cmd_friendly {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cmd_teaching {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cmd_leader {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PlayerCommendationInfo {
    fn new() -> PlayerCommendationInfo {
        PlayerCommendationInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<PlayerCommendationInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd_friendly",
                    PlayerCommendationInfo::get_cmd_friendly_for_reflect,
                    PlayerCommendationInfo::mut_cmd_friendly_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd_teaching",
                    PlayerCommendationInfo::get_cmd_teaching_for_reflect,
                    PlayerCommendationInfo::mut_cmd_teaching_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd_leader",
                    PlayerCommendationInfo::get_cmd_leader_for_reflect,
                    PlayerCommendationInfo::mut_cmd_leader_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerCommendationInfo>(
                    "PlayerCommendationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PlayerCommendationInfo {
    fn clear(&mut self) {
        self.clear_cmd_friendly();
        self.clear_cmd_teaching();
        self.clear_cmd_leader();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerCommendationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerCommendationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerMedalsInfo {
    // message fields
    medal_team: ::std::option::Option<u32>,
    medal_combat: ::std::option::Option<u32>,
    medal_weapon: ::std::option::Option<u32>,
    medal_global: ::std::option::Option<u32>,
    medal_arms: ::std::option::Option<u32>,
    display_items_defidx: ::std::vec::Vec<u32>,
    featured_display_item_defidx: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PlayerMedalsInfo {}

impl PlayerMedalsInfo {
    pub fn new() -> PlayerMedalsInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PlayerMedalsInfo {
        static mut instance: ::protobuf::lazy::Lazy<PlayerMedalsInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlayerMedalsInfo,
        };
        unsafe {
            instance.get(PlayerMedalsInfo::new)
        }
    }

    // optional uint32 medal_team = 1;

    pub fn clear_medal_team(&mut self) {
        self.medal_team = ::std::option::Option::None;
    }

    pub fn has_medal_team(&self) -> bool {
        self.medal_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medal_team(&mut self, v: u32) {
        self.medal_team = ::std::option::Option::Some(v);
    }

    pub fn get_medal_team(&self) -> u32 {
        self.medal_team.unwrap_or(0)
    }

    fn get_medal_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.medal_team
    }

    fn mut_medal_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.medal_team
    }

    // optional uint32 medal_combat = 2;

    pub fn clear_medal_combat(&mut self) {
        self.medal_combat = ::std::option::Option::None;
    }

    pub fn has_medal_combat(&self) -> bool {
        self.medal_combat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medal_combat(&mut self, v: u32) {
        self.medal_combat = ::std::option::Option::Some(v);
    }

    pub fn get_medal_combat(&self) -> u32 {
        self.medal_combat.unwrap_or(0)
    }

    fn get_medal_combat_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.medal_combat
    }

    fn mut_medal_combat_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.medal_combat
    }

    // optional uint32 medal_weapon = 3;

    pub fn clear_medal_weapon(&mut self) {
        self.medal_weapon = ::std::option::Option::None;
    }

    pub fn has_medal_weapon(&self) -> bool {
        self.medal_weapon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medal_weapon(&mut self, v: u32) {
        self.medal_weapon = ::std::option::Option::Some(v);
    }

    pub fn get_medal_weapon(&self) -> u32 {
        self.medal_weapon.unwrap_or(0)
    }

    fn get_medal_weapon_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.medal_weapon
    }

    fn mut_medal_weapon_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.medal_weapon
    }

    // optional uint32 medal_global = 4;

    pub fn clear_medal_global(&mut self) {
        self.medal_global = ::std::option::Option::None;
    }

    pub fn has_medal_global(&self) -> bool {
        self.medal_global.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medal_global(&mut self, v: u32) {
        self.medal_global = ::std::option::Option::Some(v);
    }

    pub fn get_medal_global(&self) -> u32 {
        self.medal_global.unwrap_or(0)
    }

    fn get_medal_global_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.medal_global
    }

    fn mut_medal_global_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.medal_global
    }

    // optional uint32 medal_arms = 5;

    pub fn clear_medal_arms(&mut self) {
        self.medal_arms = ::std::option::Option::None;
    }

    pub fn has_medal_arms(&self) -> bool {
        self.medal_arms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medal_arms(&mut self, v: u32) {
        self.medal_arms = ::std::option::Option::Some(v);
    }

    pub fn get_medal_arms(&self) -> u32 {
        self.medal_arms.unwrap_or(0)
    }

    fn get_medal_arms_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.medal_arms
    }

    fn mut_medal_arms_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.medal_arms
    }

    // repeated uint32 display_items_defidx = 7;

    pub fn clear_display_items_defidx(&mut self) {
        self.display_items_defidx.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_items_defidx(&mut self, v: ::std::vec::Vec<u32>) {
        self.display_items_defidx = v;
    }

    // Mutable pointer to the field.
    pub fn mut_display_items_defidx(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.display_items_defidx
    }

    // Take field
    pub fn take_display_items_defidx(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.display_items_defidx, ::std::vec::Vec::new())
    }

    pub fn get_display_items_defidx(&self) -> &[u32] {
        &self.display_items_defidx
    }

    fn get_display_items_defidx_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.display_items_defidx
    }

    fn mut_display_items_defidx_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.display_items_defidx
    }

    // optional uint32 featured_display_item_defidx = 8;

    pub fn clear_featured_display_item_defidx(&mut self) {
        self.featured_display_item_defidx = ::std::option::Option::None;
    }

    pub fn has_featured_display_item_defidx(&self) -> bool {
        self.featured_display_item_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_display_item_defidx(&mut self, v: u32) {
        self.featured_display_item_defidx = ::std::option::Option::Some(v);
    }

    pub fn get_featured_display_item_defidx(&self) -> u32 {
        self.featured_display_item_defidx.unwrap_or(0)
    }

    fn get_featured_display_item_defidx_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.featured_display_item_defidx
    }

    fn mut_featured_display_item_defidx_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.featured_display_item_defidx
    }
}

impl ::protobuf::Message for PlayerMedalsInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.medal_team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.medal_combat = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.medal_weapon = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.medal_global = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.medal_arms = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.display_items_defidx)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.featured_display_item_defidx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.medal_team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.medal_combat {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.medal_weapon {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.medal_global {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.medal_arms {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.display_items_defidx {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.featured_display_item_defidx {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.medal_team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.medal_combat {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.medal_weapon {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.medal_global {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.medal_arms {
            os.write_uint32(5, v)?;
        }
        for v in &self.display_items_defidx {
            os.write_uint32(7, *v)?;
        };
        if let Some(v) = self.featured_display_item_defidx {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PlayerMedalsInfo {
    fn new() -> PlayerMedalsInfo {
        PlayerMedalsInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<PlayerMedalsInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "medal_team",
                    PlayerMedalsInfo::get_medal_team_for_reflect,
                    PlayerMedalsInfo::mut_medal_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "medal_combat",
                    PlayerMedalsInfo::get_medal_combat_for_reflect,
                    PlayerMedalsInfo::mut_medal_combat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "medal_weapon",
                    PlayerMedalsInfo::get_medal_weapon_for_reflect,
                    PlayerMedalsInfo::mut_medal_weapon_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "medal_global",
                    PlayerMedalsInfo::get_medal_global_for_reflect,
                    PlayerMedalsInfo::mut_medal_global_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "medal_arms",
                    PlayerMedalsInfo::get_medal_arms_for_reflect,
                    PlayerMedalsInfo::mut_medal_arms_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "display_items_defidx",
                    PlayerMedalsInfo::get_display_items_defidx_for_reflect,
                    PlayerMedalsInfo::mut_display_items_defidx_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "featured_display_item_defidx",
                    PlayerMedalsInfo::get_featured_display_item_defidx_for_reflect,
                    PlayerMedalsInfo::mut_featured_display_item_defidx_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerMedalsInfo>(
                    "PlayerMedalsInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PlayerMedalsInfo {
    fn clear(&mut self) {
        self.clear_medal_team();
        self.clear_medal_combat();
        self.clear_medal_weapon();
        self.clear_medal_global();
        self.clear_medal_arms();
        self.clear_display_items_defidx();
        self.clear_featured_display_item_defidx();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerMedalsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerMedalsInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountActivity {
    // message fields
    activity: ::std::option::Option<u32>,
    mode: ::std::option::Option<u32>,
    map: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AccountActivity {}

impl AccountActivity {
    pub fn new() -> AccountActivity {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AccountActivity {
        static mut instance: ::protobuf::lazy::Lazy<AccountActivity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountActivity,
        };
        unsafe {
            instance.get(AccountActivity::new)
        }
    }

    // optional uint32 activity = 1;

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: u32) {
        self.activity = ::std::option::Option::Some(v);
    }

    pub fn get_activity(&self) -> u32 {
        self.activity.unwrap_or(0)
    }

    fn get_activity_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.activity
    }

    fn mut_activity_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.activity
    }

    // optional uint32 mode = 2;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mode
    }

    // optional uint32 map = 3;

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: u32) {
        self.map = ::std::option::Option::Some(v);
    }

    pub fn get_map(&self) -> u32 {
        self.map.unwrap_or(0)
    }

    fn get_map_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.map
    }

    fn mut_map_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.map
    }
}

impl ::protobuf::Message for AccountActivity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.activity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.map = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.activity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.map {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AccountActivity {
    fn new() -> AccountActivity {
        AccountActivity::new()
    }

    fn descriptor_static(_: ::std::option::Option<AccountActivity>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "activity",
                    AccountActivity::get_activity_for_reflect,
                    AccountActivity::mut_activity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mode",
                    AccountActivity::get_mode_for_reflect,
                    AccountActivity::mut_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "map",
                    AccountActivity::get_map_for_reflect,
                    AccountActivity::mut_map_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountActivity>(
                    "AccountActivity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AccountActivity {
    fn clear(&mut self) {
        self.clear_activity();
        self.clear_mode();
        self.clear_map();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountActivity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountActivity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TournamentMatchSetup {
    // message fields
    event_id: ::std::option::Option<i32>,
    team_id_ct: ::std::option::Option<i32>,
    team_id_t: ::std::option::Option<i32>,
    event_stage_id: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TournamentMatchSetup {}

impl TournamentMatchSetup {
    pub fn new() -> TournamentMatchSetup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TournamentMatchSetup {
        static mut instance: ::protobuf::lazy::Lazy<TournamentMatchSetup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TournamentMatchSetup,
        };
        unsafe {
            instance.get(TournamentMatchSetup::new)
        }
    }

    // optional int32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.event_id
    }

    // optional int32 team_id_ct = 2;

    pub fn clear_team_id_ct(&mut self) {
        self.team_id_ct = ::std::option::Option::None;
    }

    pub fn has_team_id_ct(&self) -> bool {
        self.team_id_ct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_ct(&mut self, v: i32) {
        self.team_id_ct = ::std::option::Option::Some(v);
    }

    pub fn get_team_id_ct(&self) -> i32 {
        self.team_id_ct.unwrap_or(0)
    }

    fn get_team_id_ct_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.team_id_ct
    }

    fn mut_team_id_ct_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.team_id_ct
    }

    // optional int32 team_id_t = 3;

    pub fn clear_team_id_t(&mut self) {
        self.team_id_t = ::std::option::Option::None;
    }

    pub fn has_team_id_t(&self) -> bool {
        self.team_id_t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_t(&mut self, v: i32) {
        self.team_id_t = ::std::option::Option::Some(v);
    }

    pub fn get_team_id_t(&self) -> i32 {
        self.team_id_t.unwrap_or(0)
    }

    fn get_team_id_t_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.team_id_t
    }

    fn mut_team_id_t_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.team_id_t
    }

    // optional int32 event_stage_id = 4;

    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }

    fn get_event_stage_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.event_stage_id
    }

    fn mut_event_stage_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.event_stage_id
    }
}

impl ::protobuf::Message for TournamentMatchSetup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_ct = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_t = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_stage_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_ct {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_t {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_id_ct {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.team_id_t {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TournamentMatchSetup {
    fn new() -> TournamentMatchSetup {
        TournamentMatchSetup::new()
    }

    fn descriptor_static(_: ::std::option::Option<TournamentMatchSetup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_id",
                    TournamentMatchSetup::get_event_id_for_reflect,
                    TournamentMatchSetup::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_ct",
                    TournamentMatchSetup::get_team_id_ct_for_reflect,
                    TournamentMatchSetup::mut_team_id_ct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_t",
                    TournamentMatchSetup::get_team_id_t_for_reflect,
                    TournamentMatchSetup::mut_team_id_t_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_stage_id",
                    TournamentMatchSetup::get_event_stage_id_for_reflect,
                    TournamentMatchSetup::mut_event_stage_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TournamentMatchSetup>(
                    "TournamentMatchSetup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TournamentMatchSetup {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_team_id_ct();
        self.clear_team_id_t();
        self.clear_event_stage_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TournamentMatchSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentMatchSetup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerHltvInfo {
    // message fields
    tv_udp_port: ::std::option::Option<u32>,
    tv_watch_key: ::std::option::Option<u64>,
    tv_slots: ::std::option::Option<u32>,
    tv_clients: ::std::option::Option<u32>,
    tv_proxies: ::std::option::Option<u32>,
    tv_time: ::std::option::Option<u32>,
    game_type: ::std::option::Option<u32>,
    game_mapgroup: ::protobuf::SingularField<::std::string::String>,
    game_map: ::protobuf::SingularField<::std::string::String>,
    tv_master_steamid: ::std::option::Option<u64>,
    tv_local_slots: ::std::option::Option<u32>,
    tv_local_clients: ::std::option::Option<u32>,
    tv_local_proxies: ::std::option::Option<u32>,
    tv_relay_slots: ::std::option::Option<u32>,
    tv_relay_clients: ::std::option::Option<u32>,
    tv_relay_proxies: ::std::option::Option<u32>,
    tv_relay_address: ::std::option::Option<u32>,
    tv_relay_port: ::std::option::Option<u32>,
    tv_relay_steamid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ServerHltvInfo {}

impl ServerHltvInfo {
    pub fn new() -> ServerHltvInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ServerHltvInfo {
        static mut instance: ::protobuf::lazy::Lazy<ServerHltvInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerHltvInfo,
        };
        unsafe {
            instance.get(ServerHltvInfo::new)
        }
    }

    // optional uint32 tv_udp_port = 1;

    pub fn clear_tv_udp_port(&mut self) {
        self.tv_udp_port = ::std::option::Option::None;
    }

    pub fn has_tv_udp_port(&self) -> bool {
        self.tv_udp_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_udp_port(&mut self, v: u32) {
        self.tv_udp_port = ::std::option::Option::Some(v);
    }

    pub fn get_tv_udp_port(&self) -> u32 {
        self.tv_udp_port.unwrap_or(0)
    }

    fn get_tv_udp_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_udp_port
    }

    fn mut_tv_udp_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_udp_port
    }

    // optional uint64 tv_watch_key = 2;

    pub fn clear_tv_watch_key(&mut self) {
        self.tv_watch_key = ::std::option::Option::None;
    }

    pub fn has_tv_watch_key(&self) -> bool {
        self.tv_watch_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_watch_key(&mut self, v: u64) {
        self.tv_watch_key = ::std::option::Option::Some(v);
    }

    pub fn get_tv_watch_key(&self) -> u64 {
        self.tv_watch_key.unwrap_or(0)
    }

    fn get_tv_watch_key_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.tv_watch_key
    }

    fn mut_tv_watch_key_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.tv_watch_key
    }

    // optional uint32 tv_slots = 3;

    pub fn clear_tv_slots(&mut self) {
        self.tv_slots = ::std::option::Option::None;
    }

    pub fn has_tv_slots(&self) -> bool {
        self.tv_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_slots(&mut self, v: u32) {
        self.tv_slots = ::std::option::Option::Some(v);
    }

    pub fn get_tv_slots(&self) -> u32 {
        self.tv_slots.unwrap_or(0)
    }

    fn get_tv_slots_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_slots
    }

    fn mut_tv_slots_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_slots
    }

    // optional uint32 tv_clients = 4;

    pub fn clear_tv_clients(&mut self) {
        self.tv_clients = ::std::option::Option::None;
    }

    pub fn has_tv_clients(&self) -> bool {
        self.tv_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_clients(&mut self, v: u32) {
        self.tv_clients = ::std::option::Option::Some(v);
    }

    pub fn get_tv_clients(&self) -> u32 {
        self.tv_clients.unwrap_or(0)
    }

    fn get_tv_clients_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_clients
    }

    fn mut_tv_clients_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_clients
    }

    // optional uint32 tv_proxies = 5;

    pub fn clear_tv_proxies(&mut self) {
        self.tv_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_proxies(&self) -> bool {
        self.tv_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_proxies(&mut self, v: u32) {
        self.tv_proxies = ::std::option::Option::Some(v);
    }

    pub fn get_tv_proxies(&self) -> u32 {
        self.tv_proxies.unwrap_or(0)
    }

    fn get_tv_proxies_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_proxies
    }

    fn mut_tv_proxies_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_proxies
    }

    // optional uint32 tv_time = 6;

    pub fn clear_tv_time(&mut self) {
        self.tv_time = ::std::option::Option::None;
    }

    pub fn has_tv_time(&self) -> bool {
        self.tv_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_time(&mut self, v: u32) {
        self.tv_time = ::std::option::Option::Some(v);
    }

    pub fn get_tv_time(&self) -> u32 {
        self.tv_time.unwrap_or(0)
    }

    fn get_tv_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_time
    }

    fn mut_tv_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_time
    }

    // optional uint32 game_type = 8;

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    fn get_game_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_type
    }

    fn mut_game_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_type
    }

    // optional string game_mapgroup = 9;

    pub fn clear_game_mapgroup(&mut self) {
        self.game_mapgroup.clear();
    }

    pub fn has_game_mapgroup(&self) -> bool {
        self.game_mapgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mapgroup(&mut self, v: ::std::string::String) {
        self.game_mapgroup = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mapgroup(&mut self) -> &mut ::std::string::String {
        if self.game_mapgroup.is_none() {
            self.game_mapgroup.set_default();
        }
        self.game_mapgroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mapgroup(&mut self) -> ::std::string::String {
        self.game_mapgroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_game_mapgroup(&self) -> &str {
        match self.game_mapgroup.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_game_mapgroup_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.game_mapgroup
    }

    fn mut_game_mapgroup_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.game_mapgroup
    }

    // optional string game_map = 10;

    pub fn clear_game_map(&mut self) {
        self.game_map.clear();
    }

    pub fn has_game_map(&self) -> bool {
        self.game_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_map(&mut self, v: ::std::string::String) {
        self.game_map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_map(&mut self) -> &mut ::std::string::String {
        if self.game_map.is_none() {
            self.game_map.set_default();
        }
        self.game_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_map(&mut self) -> ::std::string::String {
        self.game_map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_game_map(&self) -> &str {
        match self.game_map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_game_map_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.game_map
    }

    fn mut_game_map_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.game_map
    }

    // optional uint64 tv_master_steamid = 11;

    pub fn clear_tv_master_steamid(&mut self) {
        self.tv_master_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_master_steamid(&self) -> bool {
        self.tv_master_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_master_steamid(&mut self, v: u64) {
        self.tv_master_steamid = ::std::option::Option::Some(v);
    }

    pub fn get_tv_master_steamid(&self) -> u64 {
        self.tv_master_steamid.unwrap_or(0)
    }

    fn get_tv_master_steamid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.tv_master_steamid
    }

    fn mut_tv_master_steamid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.tv_master_steamid
    }

    // optional uint32 tv_local_slots = 12;

    pub fn clear_tv_local_slots(&mut self) {
        self.tv_local_slots = ::std::option::Option::None;
    }

    pub fn has_tv_local_slots(&self) -> bool {
        self.tv_local_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_slots(&mut self, v: u32) {
        self.tv_local_slots = ::std::option::Option::Some(v);
    }

    pub fn get_tv_local_slots(&self) -> u32 {
        self.tv_local_slots.unwrap_or(0)
    }

    fn get_tv_local_slots_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_local_slots
    }

    fn mut_tv_local_slots_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_local_slots
    }

    // optional uint32 tv_local_clients = 13;

    pub fn clear_tv_local_clients(&mut self) {
        self.tv_local_clients = ::std::option::Option::None;
    }

    pub fn has_tv_local_clients(&self) -> bool {
        self.tv_local_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_clients(&mut self, v: u32) {
        self.tv_local_clients = ::std::option::Option::Some(v);
    }

    pub fn get_tv_local_clients(&self) -> u32 {
        self.tv_local_clients.unwrap_or(0)
    }

    fn get_tv_local_clients_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_local_clients
    }

    fn mut_tv_local_clients_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_local_clients
    }

    // optional uint32 tv_local_proxies = 14;

    pub fn clear_tv_local_proxies(&mut self) {
        self.tv_local_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_local_proxies(&self) -> bool {
        self.tv_local_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_proxies(&mut self, v: u32) {
        self.tv_local_proxies = ::std::option::Option::Some(v);
    }

    pub fn get_tv_local_proxies(&self) -> u32 {
        self.tv_local_proxies.unwrap_or(0)
    }

    fn get_tv_local_proxies_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_local_proxies
    }

    fn mut_tv_local_proxies_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_local_proxies
    }

    // optional uint32 tv_relay_slots = 15;

    pub fn clear_tv_relay_slots(&mut self) {
        self.tv_relay_slots = ::std::option::Option::None;
    }

    pub fn has_tv_relay_slots(&self) -> bool {
        self.tv_relay_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_slots(&mut self, v: u32) {
        self.tv_relay_slots = ::std::option::Option::Some(v);
    }

    pub fn get_tv_relay_slots(&self) -> u32 {
        self.tv_relay_slots.unwrap_or(0)
    }

    fn get_tv_relay_slots_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_relay_slots
    }

    fn mut_tv_relay_slots_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_relay_slots
    }

    // optional uint32 tv_relay_clients = 16;

    pub fn clear_tv_relay_clients(&mut self) {
        self.tv_relay_clients = ::std::option::Option::None;
    }

    pub fn has_tv_relay_clients(&self) -> bool {
        self.tv_relay_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_clients(&mut self, v: u32) {
        self.tv_relay_clients = ::std::option::Option::Some(v);
    }

    pub fn get_tv_relay_clients(&self) -> u32 {
        self.tv_relay_clients.unwrap_or(0)
    }

    fn get_tv_relay_clients_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_relay_clients
    }

    fn mut_tv_relay_clients_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_relay_clients
    }

    // optional uint32 tv_relay_proxies = 17;

    pub fn clear_tv_relay_proxies(&mut self) {
        self.tv_relay_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_relay_proxies(&self) -> bool {
        self.tv_relay_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_proxies(&mut self, v: u32) {
        self.tv_relay_proxies = ::std::option::Option::Some(v);
    }

    pub fn get_tv_relay_proxies(&self) -> u32 {
        self.tv_relay_proxies.unwrap_or(0)
    }

    fn get_tv_relay_proxies_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_relay_proxies
    }

    fn mut_tv_relay_proxies_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_relay_proxies
    }

    // optional uint32 tv_relay_address = 18;

    pub fn clear_tv_relay_address(&mut self) {
        self.tv_relay_address = ::std::option::Option::None;
    }

    pub fn has_tv_relay_address(&self) -> bool {
        self.tv_relay_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_address(&mut self, v: u32) {
        self.tv_relay_address = ::std::option::Option::Some(v);
    }

    pub fn get_tv_relay_address(&self) -> u32 {
        self.tv_relay_address.unwrap_or(0)
    }

    fn get_tv_relay_address_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_relay_address
    }

    fn mut_tv_relay_address_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_relay_address
    }

    // optional uint32 tv_relay_port = 19;

    pub fn clear_tv_relay_port(&mut self) {
        self.tv_relay_port = ::std::option::Option::None;
    }

    pub fn has_tv_relay_port(&self) -> bool {
        self.tv_relay_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_port(&mut self, v: u32) {
        self.tv_relay_port = ::std::option::Option::Some(v);
    }

    pub fn get_tv_relay_port(&self) -> u32 {
        self.tv_relay_port.unwrap_or(0)
    }

    fn get_tv_relay_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_relay_port
    }

    fn mut_tv_relay_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_relay_port
    }

    // optional uint64 tv_relay_steamid = 20;

    pub fn clear_tv_relay_steamid(&mut self) {
        self.tv_relay_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_relay_steamid(&self) -> bool {
        self.tv_relay_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_steamid(&mut self, v: u64) {
        self.tv_relay_steamid = ::std::option::Option::Some(v);
    }

    pub fn get_tv_relay_steamid(&self) -> u64 {
        self.tv_relay_steamid.unwrap_or(0)
    }

    fn get_tv_relay_steamid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.tv_relay_steamid
    }

    fn mut_tv_relay_steamid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.tv_relay_steamid
    }
}

impl ::protobuf::Message for ServerHltvInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_udp_port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tv_watch_key = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_slots = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_clients = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_proxies = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_mapgroup)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_map)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tv_master_steamid = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_local_slots = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_local_clients = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_local_proxies = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_relay_slots = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_relay_clients = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_relay_proxies = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_relay_address = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_relay_port = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tv_relay_steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tv_udp_port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_watch_key {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_slots {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_clients {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_proxies {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_time {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_mapgroup.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.game_map.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.tv_master_steamid {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_local_slots {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_local_clients {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_local_proxies {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_slots {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_clients {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_proxies {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_address {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_port {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_steamid {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tv_udp_port {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tv_watch_key {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.tv_slots {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tv_clients {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tv_proxies {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tv_time {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(8, v)?;
        }
        if let Some(ref v) = self.game_mapgroup.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.game_map.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.tv_master_steamid {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.tv_local_slots {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.tv_local_clients {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.tv_local_proxies {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.tv_relay_slots {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.tv_relay_clients {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.tv_relay_proxies {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.tv_relay_address {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.tv_relay_port {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.tv_relay_steamid {
            os.write_uint64(20, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ServerHltvInfo {
    fn new() -> ServerHltvInfo {
        ServerHltvInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ServerHltvInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_udp_port",
                    ServerHltvInfo::get_tv_udp_port_for_reflect,
                    ServerHltvInfo::mut_tv_udp_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tv_watch_key",
                    ServerHltvInfo::get_tv_watch_key_for_reflect,
                    ServerHltvInfo::mut_tv_watch_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_slots",
                    ServerHltvInfo::get_tv_slots_for_reflect,
                    ServerHltvInfo::mut_tv_slots_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_clients",
                    ServerHltvInfo::get_tv_clients_for_reflect,
                    ServerHltvInfo::mut_tv_clients_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_proxies",
                    ServerHltvInfo::get_tv_proxies_for_reflect,
                    ServerHltvInfo::mut_tv_proxies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_time",
                    ServerHltvInfo::get_tv_time_for_reflect,
                    ServerHltvInfo::mut_tv_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    ServerHltvInfo::get_game_type_for_reflect,
                    ServerHltvInfo::mut_game_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "game_mapgroup",
                    ServerHltvInfo::get_game_mapgroup_for_reflect,
                    ServerHltvInfo::mut_game_mapgroup_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "game_map",
                    ServerHltvInfo::get_game_map_for_reflect,
                    ServerHltvInfo::mut_game_map_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tv_master_steamid",
                    ServerHltvInfo::get_tv_master_steamid_for_reflect,
                    ServerHltvInfo::mut_tv_master_steamid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_local_slots",
                    ServerHltvInfo::get_tv_local_slots_for_reflect,
                    ServerHltvInfo::mut_tv_local_slots_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_local_clients",
                    ServerHltvInfo::get_tv_local_clients_for_reflect,
                    ServerHltvInfo::mut_tv_local_clients_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_local_proxies",
                    ServerHltvInfo::get_tv_local_proxies_for_reflect,
                    ServerHltvInfo::mut_tv_local_proxies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_relay_slots",
                    ServerHltvInfo::get_tv_relay_slots_for_reflect,
                    ServerHltvInfo::mut_tv_relay_slots_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_relay_clients",
                    ServerHltvInfo::get_tv_relay_clients_for_reflect,
                    ServerHltvInfo::mut_tv_relay_clients_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_relay_proxies",
                    ServerHltvInfo::get_tv_relay_proxies_for_reflect,
                    ServerHltvInfo::mut_tv_relay_proxies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_relay_address",
                    ServerHltvInfo::get_tv_relay_address_for_reflect,
                    ServerHltvInfo::mut_tv_relay_address_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_relay_port",
                    ServerHltvInfo::get_tv_relay_port_for_reflect,
                    ServerHltvInfo::mut_tv_relay_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tv_relay_steamid",
                    ServerHltvInfo::get_tv_relay_steamid_for_reflect,
                    ServerHltvInfo::mut_tv_relay_steamid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerHltvInfo>(
                    "ServerHltvInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ServerHltvInfo {
    fn clear(&mut self) {
        self.clear_tv_udp_port();
        self.clear_tv_watch_key();
        self.clear_tv_slots();
        self.clear_tv_clients();
        self.clear_tv_proxies();
        self.clear_tv_time();
        self.clear_game_type();
        self.clear_game_mapgroup();
        self.clear_game_map();
        self.clear_tv_master_steamid();
        self.clear_tv_local_slots();
        self.clear_tv_local_clients();
        self.clear_tv_local_proxies();
        self.clear_tv_relay_slots();
        self.clear_tv_relay_clients();
        self.clear_tv_relay_proxies();
        self.clear_tv_relay_address();
        self.clear_tv_relay_port();
        self.clear_tv_relay_steamid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerHltvInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerHltvInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IpAddressMask {
    // message fields
    a: ::std::option::Option<u32>,
    b: ::std::option::Option<u32>,
    c: ::std::option::Option<u32>,
    d: ::std::option::Option<u32>,
    bits: ::std::option::Option<u32>,
    token: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for IpAddressMask {}

impl IpAddressMask {
    pub fn new() -> IpAddressMask {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static IpAddressMask {
        static mut instance: ::protobuf::lazy::Lazy<IpAddressMask> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IpAddressMask,
        };
        unsafe {
            instance.get(IpAddressMask::new)
        }
    }

    // optional uint32 a = 1;

    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: u32) {
        self.a = ::std::option::Option::Some(v);
    }

    pub fn get_a(&self) -> u32 {
        self.a.unwrap_or(0)
    }

    fn get_a_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.a
    }

    fn mut_a_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.a
    }

    // optional uint32 b = 2;

    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: u32) {
        self.b = ::std::option::Option::Some(v);
    }

    pub fn get_b(&self) -> u32 {
        self.b.unwrap_or(0)
    }

    fn get_b_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.b
    }

    fn mut_b_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.b
    }

    // optional uint32 c = 3;

    pub fn clear_c(&mut self) {
        self.c = ::std::option::Option::None;
    }

    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c(&mut self, v: u32) {
        self.c = ::std::option::Option::Some(v);
    }

    pub fn get_c(&self) -> u32 {
        self.c.unwrap_or(0)
    }

    fn get_c_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.c
    }

    fn mut_c_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.c
    }

    // optional uint32 d = 4;

    pub fn clear_d(&mut self) {
        self.d = ::std::option::Option::None;
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: u32) {
        self.d = ::std::option::Option::Some(v);
    }

    pub fn get_d(&self) -> u32 {
        self.d.unwrap_or(0)
    }

    fn get_d_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.d
    }

    fn mut_d_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.d
    }

    // optional uint32 bits = 5;

    pub fn clear_bits(&mut self) {
        self.bits = ::std::option::Option::None;
    }

    pub fn has_bits(&self) -> bool {
        self.bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bits(&mut self, v: u32) {
        self.bits = ::std::option::Option::Some(v);
    }

    pub fn get_bits(&self) -> u32 {
        self.bits.unwrap_or(0)
    }

    fn get_bits_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.bits
    }

    fn mut_bits_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.bits
    }

    // optional uint32 token = 6;

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }

    pub fn get_token(&self) -> u32 {
        self.token.unwrap_or(0)
    }

    fn get_token_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.token
    }

    fn mut_token_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.token
    }
}

impl ::protobuf::Message for IpAddressMask {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.a = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.b = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.c = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.d = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bits = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.a {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.b {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.c {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.d {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bits {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.a {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.b {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.c {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.d {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.bits {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.token {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for IpAddressMask {
    fn new() -> IpAddressMask {
        IpAddressMask::new()
    }

    fn descriptor_static(_: ::std::option::Option<IpAddressMask>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "a",
                    IpAddressMask::get_a_for_reflect,
                    IpAddressMask::mut_a_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "b",
                    IpAddressMask::get_b_for_reflect,
                    IpAddressMask::mut_b_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "c",
                    IpAddressMask::get_c_for_reflect,
                    IpAddressMask::mut_c_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "d",
                    IpAddressMask::get_d_for_reflect,
                    IpAddressMask::mut_d_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bits",
                    IpAddressMask::get_bits_for_reflect,
                    IpAddressMask::mut_bits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "token",
                    IpAddressMask::get_token_for_reflect,
                    IpAddressMask::mut_token_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IpAddressMask>(
                    "IpAddressMask",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for IpAddressMask {
    fn clear(&mut self) {
        self.clear_a();
        self.clear_b();
        self.clear_c();
        self.clear_d();
        self.clear_bits();
        self.clear_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IpAddressMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IpAddressMask {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct XpProgressData {
    // message fields
    xp_points: ::std::option::Option<u32>,
    xp_category: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for XpProgressData {}

impl XpProgressData {
    pub fn new() -> XpProgressData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static XpProgressData {
        static mut instance: ::protobuf::lazy::Lazy<XpProgressData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const XpProgressData,
        };
        unsafe {
            instance.get(XpProgressData::new)
        }
    }

    // optional uint32 xp_points = 1;

    pub fn clear_xp_points(&mut self) {
        self.xp_points = ::std::option::Option::None;
    }

    pub fn has_xp_points(&self) -> bool {
        self.xp_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_points(&mut self, v: u32) {
        self.xp_points = ::std::option::Option::Some(v);
    }

    pub fn get_xp_points(&self) -> u32 {
        self.xp_points.unwrap_or(0)
    }

    fn get_xp_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.xp_points
    }

    fn mut_xp_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.xp_points
    }

    // optional int32 xp_category = 2;

    pub fn clear_xp_category(&mut self) {
        self.xp_category = ::std::option::Option::None;
    }

    pub fn has_xp_category(&self) -> bool {
        self.xp_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_category(&mut self, v: i32) {
        self.xp_category = ::std::option::Option::Some(v);
    }

    pub fn get_xp_category(&self) -> i32 {
        self.xp_category.unwrap_or(0)
    }

    fn get_xp_category_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.xp_category
    }

    fn mut_xp_category_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.xp_category
    }
}

impl ::protobuf::Message for XpProgressData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xp_points = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.xp_category = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.xp_points {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xp_category {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.xp_points {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.xp_category {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for XpProgressData {
    fn new() -> XpProgressData {
        XpProgressData::new()
    }

    fn descriptor_static(_: ::std::option::Option<XpProgressData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xp_points",
                    XpProgressData::get_xp_points_for_reflect,
                    XpProgressData::mut_xp_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "xp_category",
                    XpProgressData::get_xp_category_for_reflect,
                    XpProgressData::mut_xp_category_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<XpProgressData>(
                    "XpProgressData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for XpProgressData {
    fn clear(&mut self) {
        self.clear_xp_points();
        self.clear_xp_category();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for XpProgressData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for XpProgressData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchEndItemUpdates {
    // message fields
    item_id: ::std::option::Option<u64>,
    item_attr_defidx: ::std::option::Option<u32>,
    item_attr_delta_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MatchEndItemUpdates {}

impl MatchEndItemUpdates {
    pub fn new() -> MatchEndItemUpdates {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MatchEndItemUpdates {
        static mut instance: ::protobuf::lazy::Lazy<MatchEndItemUpdates> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchEndItemUpdates,
        };
        unsafe {
            instance.get(MatchEndItemUpdates::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 item_attr_defidx = 2;

    pub fn clear_item_attr_defidx(&mut self) {
        self.item_attr_defidx = ::std::option::Option::None;
    }

    pub fn has_item_attr_defidx(&self) -> bool {
        self.item_attr_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_attr_defidx(&mut self, v: u32) {
        self.item_attr_defidx = ::std::option::Option::Some(v);
    }

    pub fn get_item_attr_defidx(&self) -> u32 {
        self.item_attr_defidx.unwrap_or(0)
    }

    fn get_item_attr_defidx_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_attr_defidx
    }

    fn mut_item_attr_defidx_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_attr_defidx
    }

    // optional uint32 item_attr_delta_value = 3;

    pub fn clear_item_attr_delta_value(&mut self) {
        self.item_attr_delta_value = ::std::option::Option::None;
    }

    pub fn has_item_attr_delta_value(&self) -> bool {
        self.item_attr_delta_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_attr_delta_value(&mut self, v: u32) {
        self.item_attr_delta_value = ::std::option::Option::Some(v);
    }

    pub fn get_item_attr_delta_value(&self) -> u32 {
        self.item_attr_delta_value.unwrap_or(0)
    }

    fn get_item_attr_delta_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_attr_delta_value
    }

    fn mut_item_attr_delta_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_attr_delta_value
    }
}

impl ::protobuf::Message for MatchEndItemUpdates {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_attr_defidx = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_attr_delta_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_attr_defidx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_attr_delta_value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_attr_defidx {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_attr_delta_value {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MatchEndItemUpdates {
    fn new() -> MatchEndItemUpdates {
        MatchEndItemUpdates::new()
    }

    fn descriptor_static(_: ::std::option::Option<MatchEndItemUpdates>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    MatchEndItemUpdates::get_item_id_for_reflect,
                    MatchEndItemUpdates::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_attr_defidx",
                    MatchEndItemUpdates::get_item_attr_defidx_for_reflect,
                    MatchEndItemUpdates::mut_item_attr_defidx_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_attr_delta_value",
                    MatchEndItemUpdates::get_item_attr_delta_value_for_reflect,
                    MatchEndItemUpdates::mut_item_attr_delta_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchEndItemUpdates>(
                    "MatchEndItemUpdates",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MatchEndItemUpdates {
    fn clear(&mut self) {
        self.clear_item_id();
        self.clear_item_attr_defidx();
        self.clear_item_attr_delta_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchEndItemUpdates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchEndItemUpdates {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScoreLeaderboardData {
    // message fields
    quest_id: ::std::option::Option<u64>,
    score: ::std::option::Option<u32>,
    accountentries: ::protobuf::RepeatedField<ScoreLeaderboardData_AccountEntries>,
    matchentries: ::protobuf::RepeatedField<ScoreLeaderboardData_Entry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ScoreLeaderboardData {}

impl ScoreLeaderboardData {
    pub fn new() -> ScoreLeaderboardData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ScoreLeaderboardData {
        static mut instance: ::protobuf::lazy::Lazy<ScoreLeaderboardData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScoreLeaderboardData,
        };
        unsafe {
            instance.get(ScoreLeaderboardData::new)
        }
    }

    // optional uint64 quest_id = 1;

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    fn get_quest_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.quest_id
    }

    fn mut_quest_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.quest_id
    }

    // optional uint32 score = 2;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.score
    }

    // repeated .ScoreLeaderboardData.AccountEntries accountentries = 3;

    pub fn clear_accountentries(&mut self) {
        self.accountentries.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountentries(&mut self, v: ::protobuf::RepeatedField<ScoreLeaderboardData_AccountEntries>) {
        self.accountentries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accountentries(&mut self) -> &mut ::protobuf::RepeatedField<ScoreLeaderboardData_AccountEntries> {
        &mut self.accountentries
    }

    // Take field
    pub fn take_accountentries(&mut self) -> ::protobuf::RepeatedField<ScoreLeaderboardData_AccountEntries> {
        ::std::mem::replace(&mut self.accountentries, ::protobuf::RepeatedField::new())
    }

    pub fn get_accountentries(&self) -> &[ScoreLeaderboardData_AccountEntries] {
        &self.accountentries
    }

    fn get_accountentries_for_reflect(&self) -> &::protobuf::RepeatedField<ScoreLeaderboardData_AccountEntries> {
        &self.accountentries
    }

    fn mut_accountentries_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ScoreLeaderboardData_AccountEntries> {
        &mut self.accountentries
    }

    // repeated .ScoreLeaderboardData.Entry matchentries = 5;

    pub fn clear_matchentries(&mut self) {
        self.matchentries.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchentries(&mut self, v: ::protobuf::RepeatedField<ScoreLeaderboardData_Entry>) {
        self.matchentries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchentries(&mut self) -> &mut ::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        &mut self.matchentries
    }

    // Take field
    pub fn take_matchentries(&mut self) -> ::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        ::std::mem::replace(&mut self.matchentries, ::protobuf::RepeatedField::new())
    }

    pub fn get_matchentries(&self) -> &[ScoreLeaderboardData_Entry] {
        &self.matchentries
    }

    fn get_matchentries_for_reflect(&self) -> &::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        &self.matchentries
    }

    fn mut_matchentries_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        &mut self.matchentries
    }
}

impl ::protobuf::Message for ScoreLeaderboardData {
    fn is_initialized(&self) -> bool {
        for v in &self.accountentries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.matchentries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accountentries)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matchentries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.accountentries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.matchentries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(2, v)?;
        }
        for v in &self.accountentries {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.matchentries {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ScoreLeaderboardData {
    fn new() -> ScoreLeaderboardData {
        ScoreLeaderboardData::new()
    }

    fn descriptor_static(_: ::std::option::Option<ScoreLeaderboardData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "quest_id",
                    ScoreLeaderboardData::get_quest_id_for_reflect,
                    ScoreLeaderboardData::mut_quest_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score",
                    ScoreLeaderboardData::get_score_for_reflect,
                    ScoreLeaderboardData::mut_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScoreLeaderboardData_AccountEntries>>(
                    "accountentries",
                    ScoreLeaderboardData::get_accountentries_for_reflect,
                    ScoreLeaderboardData::mut_accountentries_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScoreLeaderboardData_Entry>>(
                    "matchentries",
                    ScoreLeaderboardData::get_matchentries_for_reflect,
                    ScoreLeaderboardData::mut_matchentries_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScoreLeaderboardData>(
                    "ScoreLeaderboardData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ScoreLeaderboardData {
    fn clear(&mut self) {
        self.clear_quest_id();
        self.clear_score();
        self.clear_accountentries();
        self.clear_matchentries();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScoreLeaderboardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoreLeaderboardData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScoreLeaderboardData_Entry {
    // message fields
    tag: ::std::option::Option<u32>,
    val: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ScoreLeaderboardData_Entry {}

impl ScoreLeaderboardData_Entry {
    pub fn new() -> ScoreLeaderboardData_Entry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ScoreLeaderboardData_Entry {
        static mut instance: ::protobuf::lazy::Lazy<ScoreLeaderboardData_Entry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScoreLeaderboardData_Entry,
        };
        unsafe {
            instance.get(ScoreLeaderboardData_Entry::new)
        }
    }

    // optional uint32 tag = 1;

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u32) {
        self.tag = ::std::option::Option::Some(v);
    }

    pub fn get_tag(&self) -> u32 {
        self.tag.unwrap_or(0)
    }

    fn get_tag_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tag
    }

    fn mut_tag_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tag
    }

    // optional uint32 val = 2;

    pub fn clear_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: u32) {
        self.val = ::std::option::Option::Some(v);
    }

    pub fn get_val(&self) -> u32 {
        self.val.unwrap_or(0)
    }

    fn get_val_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.val
    }

    fn mut_val_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.val
    }
}

impl ::protobuf::Message for ScoreLeaderboardData_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tag = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.val = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.val {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tag {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.val {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ScoreLeaderboardData_Entry {
    fn new() -> ScoreLeaderboardData_Entry {
        ScoreLeaderboardData_Entry::new()
    }

    fn descriptor_static(_: ::std::option::Option<ScoreLeaderboardData_Entry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tag",
                    ScoreLeaderboardData_Entry::get_tag_for_reflect,
                    ScoreLeaderboardData_Entry::mut_tag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "val",
                    ScoreLeaderboardData_Entry::get_val_for_reflect,
                    ScoreLeaderboardData_Entry::mut_val_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScoreLeaderboardData_Entry>(
                    "ScoreLeaderboardData_Entry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ScoreLeaderboardData_Entry {
    fn clear(&mut self) {
        self.clear_tag();
        self.clear_val();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScoreLeaderboardData_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoreLeaderboardData_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScoreLeaderboardData_AccountEntries {
    // message fields
    accountid: ::std::option::Option<u32>,
    entries: ::protobuf::RepeatedField<ScoreLeaderboardData_Entry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ScoreLeaderboardData_AccountEntries {}

impl ScoreLeaderboardData_AccountEntries {
    pub fn new() -> ScoreLeaderboardData_AccountEntries {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ScoreLeaderboardData_AccountEntries {
        static mut instance: ::protobuf::lazy::Lazy<ScoreLeaderboardData_AccountEntries> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScoreLeaderboardData_AccountEntries,
        };
        unsafe {
            instance.get(ScoreLeaderboardData_AccountEntries::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }

    // repeated .ScoreLeaderboardData.Entry entries = 2;

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<ScoreLeaderboardData_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_entries(&self) -> &[ScoreLeaderboardData_Entry] {
        &self.entries
    }

    fn get_entries_for_reflect(&self) -> &::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        &self.entries
    }

    fn mut_entries_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        &mut self.entries
    }
}

impl ::protobuf::Message for ScoreLeaderboardData_AccountEntries {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        for v in &self.entries {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ScoreLeaderboardData_AccountEntries {
    fn new() -> ScoreLeaderboardData_AccountEntries {
        ScoreLeaderboardData_AccountEntries::new()
    }

    fn descriptor_static(_: ::std::option::Option<ScoreLeaderboardData_AccountEntries>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    ScoreLeaderboardData_AccountEntries::get_accountid_for_reflect,
                    ScoreLeaderboardData_AccountEntries::mut_accountid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScoreLeaderboardData_Entry>>(
                    "entries",
                    ScoreLeaderboardData_AccountEntries::get_entries_for_reflect,
                    ScoreLeaderboardData_AccountEntries::mut_entries_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScoreLeaderboardData_AccountEntries>(
                    "ScoreLeaderboardData_AccountEntries",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ScoreLeaderboardData_AccountEntries {
    fn clear(&mut self) {
        self.clear_accountid();
        self.clear_entries();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScoreLeaderboardData_AccountEntries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoreLeaderboardData_AccountEntries {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerQuestData {
    // message fields
    quester_account_id: ::std::option::Option<u32>,
    quest_item_data: ::protobuf::RepeatedField<PlayerQuestData_QuestItemData>,
    xp_progress_data: ::protobuf::RepeatedField<XpProgressData>,
    time_played: ::std::option::Option<u32>,
    mm_game_mode: ::std::option::Option<u32>,
    item_updates: ::protobuf::RepeatedField<MatchEndItemUpdates>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PlayerQuestData {}

impl PlayerQuestData {
    pub fn new() -> PlayerQuestData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PlayerQuestData {
        static mut instance: ::protobuf::lazy::Lazy<PlayerQuestData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlayerQuestData,
        };
        unsafe {
            instance.get(PlayerQuestData::new)
        }
    }

    // optional uint32 quester_account_id = 1;

    pub fn clear_quester_account_id(&mut self) {
        self.quester_account_id = ::std::option::Option::None;
    }

    pub fn has_quester_account_id(&self) -> bool {
        self.quester_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quester_account_id(&mut self, v: u32) {
        self.quester_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_quester_account_id(&self) -> u32 {
        self.quester_account_id.unwrap_or(0)
    }

    fn get_quester_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quester_account_id
    }

    fn mut_quester_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quester_account_id
    }

    // repeated .PlayerQuestData.QuestItemData quest_item_data = 2;

    pub fn clear_quest_item_data(&mut self) {
        self.quest_item_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_quest_item_data(&mut self, v: ::protobuf::RepeatedField<PlayerQuestData_QuestItemData>) {
        self.quest_item_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quest_item_data(&mut self) -> &mut ::protobuf::RepeatedField<PlayerQuestData_QuestItemData> {
        &mut self.quest_item_data
    }

    // Take field
    pub fn take_quest_item_data(&mut self) -> ::protobuf::RepeatedField<PlayerQuestData_QuestItemData> {
        ::std::mem::replace(&mut self.quest_item_data, ::protobuf::RepeatedField::new())
    }

    pub fn get_quest_item_data(&self) -> &[PlayerQuestData_QuestItemData] {
        &self.quest_item_data
    }

    fn get_quest_item_data_for_reflect(&self) -> &::protobuf::RepeatedField<PlayerQuestData_QuestItemData> {
        &self.quest_item_data
    }

    fn mut_quest_item_data_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PlayerQuestData_QuestItemData> {
        &mut self.quest_item_data
    }

    // repeated .XpProgressData xp_progress_data = 3;

    pub fn clear_xp_progress_data(&mut self) {
        self.xp_progress_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_xp_progress_data(&mut self, v: ::protobuf::RepeatedField<XpProgressData>) {
        self.xp_progress_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xp_progress_data(&mut self) -> &mut ::protobuf::RepeatedField<XpProgressData> {
        &mut self.xp_progress_data
    }

    // Take field
    pub fn take_xp_progress_data(&mut self) -> ::protobuf::RepeatedField<XpProgressData> {
        ::std::mem::replace(&mut self.xp_progress_data, ::protobuf::RepeatedField::new())
    }

    pub fn get_xp_progress_data(&self) -> &[XpProgressData] {
        &self.xp_progress_data
    }

    fn get_xp_progress_data_for_reflect(&self) -> &::protobuf::RepeatedField<XpProgressData> {
        &self.xp_progress_data
    }

    fn mut_xp_progress_data_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<XpProgressData> {
        &mut self.xp_progress_data
    }

    // optional uint32 time_played = 4;

    pub fn clear_time_played(&mut self) {
        self.time_played = ::std::option::Option::None;
    }

    pub fn has_time_played(&self) -> bool {
        self.time_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_played(&mut self, v: u32) {
        self.time_played = ::std::option::Option::Some(v);
    }

    pub fn get_time_played(&self) -> u32 {
        self.time_played.unwrap_or(0)
    }

    fn get_time_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_played
    }

    fn mut_time_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_played
    }

    // optional uint32 mm_game_mode = 5;

    pub fn clear_mm_game_mode(&mut self) {
        self.mm_game_mode = ::std::option::Option::None;
    }

    pub fn has_mm_game_mode(&self) -> bool {
        self.mm_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mm_game_mode(&mut self, v: u32) {
        self.mm_game_mode = ::std::option::Option::Some(v);
    }

    pub fn get_mm_game_mode(&self) -> u32 {
        self.mm_game_mode.unwrap_or(0)
    }

    fn get_mm_game_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mm_game_mode
    }

    fn mut_mm_game_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mm_game_mode
    }

    // repeated .MatchEndItemUpdates item_updates = 6;

    pub fn clear_item_updates(&mut self) {
        self.item_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_updates(&mut self, v: ::protobuf::RepeatedField<MatchEndItemUpdates>) {
        self.item_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_updates(&mut self) -> &mut ::protobuf::RepeatedField<MatchEndItemUpdates> {
        &mut self.item_updates
    }

    // Take field
    pub fn take_item_updates(&mut self) -> ::protobuf::RepeatedField<MatchEndItemUpdates> {
        ::std::mem::replace(&mut self.item_updates, ::protobuf::RepeatedField::new())
    }

    pub fn get_item_updates(&self) -> &[MatchEndItemUpdates] {
        &self.item_updates
    }

    fn get_item_updates_for_reflect(&self) -> &::protobuf::RepeatedField<MatchEndItemUpdates> {
        &self.item_updates
    }

    fn mut_item_updates_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<MatchEndItemUpdates> {
        &mut self.item_updates
    }
}

impl ::protobuf::Message for PlayerQuestData {
    fn is_initialized(&self) -> bool {
        for v in &self.quest_item_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.xp_progress_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quester_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.quest_item_data)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.xp_progress_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_played = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mm_game_mode = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item_updates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quester_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.quest_item_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.xp_progress_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.time_played {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mm_game_mode {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quester_account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.quest_item_data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.xp_progress_data {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.time_played {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.mm_game_mode {
            os.write_uint32(5, v)?;
        }
        for v in &self.item_updates {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PlayerQuestData {
    fn new() -> PlayerQuestData {
        PlayerQuestData::new()
    }

    fn descriptor_static(_: ::std::option::Option<PlayerQuestData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quester_account_id",
                    PlayerQuestData::get_quester_account_id_for_reflect,
                    PlayerQuestData::mut_quester_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerQuestData_QuestItemData>>(
                    "quest_item_data",
                    PlayerQuestData::get_quest_item_data_for_reflect,
                    PlayerQuestData::mut_quest_item_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<XpProgressData>>(
                    "xp_progress_data",
                    PlayerQuestData::get_xp_progress_data_for_reflect,
                    PlayerQuestData::mut_xp_progress_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_played",
                    PlayerQuestData::get_time_played_for_reflect,
                    PlayerQuestData::mut_time_played_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mm_game_mode",
                    PlayerQuestData::get_mm_game_mode_for_reflect,
                    PlayerQuestData::mut_mm_game_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchEndItemUpdates>>(
                    "item_updates",
                    PlayerQuestData::get_item_updates_for_reflect,
                    PlayerQuestData::mut_item_updates_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerQuestData>(
                    "PlayerQuestData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PlayerQuestData {
    fn clear(&mut self) {
        self.clear_quester_account_id();
        self.clear_quest_item_data();
        self.clear_xp_progress_data();
        self.clear_time_played();
        self.clear_mm_game_mode();
        self.clear_item_updates();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerQuestData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerQuestData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerQuestData_QuestItemData {
    // message fields
    quest_id: ::std::option::Option<u64>,
    quest_normal_points_earned: ::std::option::Option<i32>,
    quest_bonus_points_earned: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PlayerQuestData_QuestItemData {}

impl PlayerQuestData_QuestItemData {
    pub fn new() -> PlayerQuestData_QuestItemData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PlayerQuestData_QuestItemData {
        static mut instance: ::protobuf::lazy::Lazy<PlayerQuestData_QuestItemData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlayerQuestData_QuestItemData,
        };
        unsafe {
            instance.get(PlayerQuestData_QuestItemData::new)
        }
    }

    // optional uint64 quest_id = 1;

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    fn get_quest_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.quest_id
    }

    fn mut_quest_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.quest_id
    }

    // optional int32 quest_normal_points_earned = 2;

    pub fn clear_quest_normal_points_earned(&mut self) {
        self.quest_normal_points_earned = ::std::option::Option::None;
    }

    pub fn has_quest_normal_points_earned(&self) -> bool {
        self.quest_normal_points_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_normal_points_earned(&mut self, v: i32) {
        self.quest_normal_points_earned = ::std::option::Option::Some(v);
    }

    pub fn get_quest_normal_points_earned(&self) -> i32 {
        self.quest_normal_points_earned.unwrap_or(0)
    }

    fn get_quest_normal_points_earned_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.quest_normal_points_earned
    }

    fn mut_quest_normal_points_earned_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.quest_normal_points_earned
    }

    // optional int32 quest_bonus_points_earned = 3;

    pub fn clear_quest_bonus_points_earned(&mut self) {
        self.quest_bonus_points_earned = ::std::option::Option::None;
    }

    pub fn has_quest_bonus_points_earned(&self) -> bool {
        self.quest_bonus_points_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_bonus_points_earned(&mut self, v: i32) {
        self.quest_bonus_points_earned = ::std::option::Option::Some(v);
    }

    pub fn get_quest_bonus_points_earned(&self) -> i32 {
        self.quest_bonus_points_earned.unwrap_or(0)
    }

    fn get_quest_bonus_points_earned_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.quest_bonus_points_earned
    }

    fn mut_quest_bonus_points_earned_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.quest_bonus_points_earned
    }
}

impl ::protobuf::Message for PlayerQuestData_QuestItemData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quest_normal_points_earned = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quest_bonus_points_earned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_normal_points_earned {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_bonus_points_earned {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.quest_normal_points_earned {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.quest_bonus_points_earned {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PlayerQuestData_QuestItemData {
    fn new() -> PlayerQuestData_QuestItemData {
        PlayerQuestData_QuestItemData::new()
    }

    fn descriptor_static(_: ::std::option::Option<PlayerQuestData_QuestItemData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "quest_id",
                    PlayerQuestData_QuestItemData::get_quest_id_for_reflect,
                    PlayerQuestData_QuestItemData::mut_quest_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "quest_normal_points_earned",
                    PlayerQuestData_QuestItemData::get_quest_normal_points_earned_for_reflect,
                    PlayerQuestData_QuestItemData::mut_quest_normal_points_earned_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "quest_bonus_points_earned",
                    PlayerQuestData_QuestItemData::get_quest_bonus_points_earned_for_reflect,
                    PlayerQuestData_QuestItemData::mut_quest_bonus_points_earned_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerQuestData_QuestItemData>(
                    "PlayerQuestData_QuestItemData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PlayerQuestData_QuestItemData {
    fn clear(&mut self) {
        self.clear_quest_id();
        self.clear_quest_normal_points_earned();
        self.clear_quest_bonus_points_earned();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerQuestData_QuestItemData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerQuestData_QuestItemData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_ServerQuestUpdateData {
    // message fields
    player_quest_data: ::protobuf::RepeatedField<PlayerQuestData>,
    binary_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mm_game_mode: ::std::option::Option<u32>,
    missionlbsdata: ::protobuf::SingularPtrField<ScoreLeaderboardData>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGC_ServerQuestUpdateData {}

impl CMsgGC_ServerQuestUpdateData {
    pub fn new() -> CMsgGC_ServerQuestUpdateData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGC_ServerQuestUpdateData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGC_ServerQuestUpdateData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGC_ServerQuestUpdateData,
        };
        unsafe {
            instance.get(CMsgGC_ServerQuestUpdateData::new)
        }
    }

    // repeated .PlayerQuestData player_quest_data = 1;

    pub fn clear_player_quest_data(&mut self) {
        self.player_quest_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_quest_data(&mut self, v: ::protobuf::RepeatedField<PlayerQuestData>) {
        self.player_quest_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_quest_data(&mut self) -> &mut ::protobuf::RepeatedField<PlayerQuestData> {
        &mut self.player_quest_data
    }

    // Take field
    pub fn take_player_quest_data(&mut self) -> ::protobuf::RepeatedField<PlayerQuestData> {
        ::std::mem::replace(&mut self.player_quest_data, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_quest_data(&self) -> &[PlayerQuestData] {
        &self.player_quest_data
    }

    fn get_player_quest_data_for_reflect(&self) -> &::protobuf::RepeatedField<PlayerQuestData> {
        &self.player_quest_data
    }

    fn mut_player_quest_data_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PlayerQuestData> {
        &mut self.player_quest_data
    }

    // optional bytes binary_data = 2;

    pub fn clear_binary_data(&mut self) {
        self.binary_data.clear();
    }

    pub fn has_binary_data(&self) -> bool {
        self.binary_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binary_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.binary_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binary_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.binary_data.is_none() {
            self.binary_data.set_default();
        }
        self.binary_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_binary_data(&mut self) -> ::std::vec::Vec<u8> {
        self.binary_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_binary_data(&self) -> &[u8] {
        match self.binary_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_binary_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.binary_data
    }

    fn mut_binary_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.binary_data
    }

    // optional uint32 mm_game_mode = 3;

    pub fn clear_mm_game_mode(&mut self) {
        self.mm_game_mode = ::std::option::Option::None;
    }

    pub fn has_mm_game_mode(&self) -> bool {
        self.mm_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mm_game_mode(&mut self, v: u32) {
        self.mm_game_mode = ::std::option::Option::Some(v);
    }

    pub fn get_mm_game_mode(&self) -> u32 {
        self.mm_game_mode.unwrap_or(0)
    }

    fn get_mm_game_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mm_game_mode
    }

    fn mut_mm_game_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mm_game_mode
    }

    // optional .ScoreLeaderboardData missionlbsdata = 4;

    pub fn clear_missionlbsdata(&mut self) {
        self.missionlbsdata.clear();
    }

    pub fn has_missionlbsdata(&self) -> bool {
        self.missionlbsdata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missionlbsdata(&mut self, v: ScoreLeaderboardData) {
        self.missionlbsdata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_missionlbsdata(&mut self) -> &mut ScoreLeaderboardData {
        if self.missionlbsdata.is_none() {
            self.missionlbsdata.set_default();
        }
        self.missionlbsdata.as_mut().unwrap()
    }

    // Take field
    pub fn take_missionlbsdata(&mut self) -> ScoreLeaderboardData {
        self.missionlbsdata.take().unwrap_or_else(|| ScoreLeaderboardData::new())
    }

    pub fn get_missionlbsdata(&self) -> &ScoreLeaderboardData {
        self.missionlbsdata.as_ref().unwrap_or_else(|| ScoreLeaderboardData::default_instance())
    }

    fn get_missionlbsdata_for_reflect(&self) -> &::protobuf::SingularPtrField<ScoreLeaderboardData> {
        &self.missionlbsdata
    }

    fn mut_missionlbsdata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ScoreLeaderboardData> {
        &mut self.missionlbsdata
    }
}

impl ::protobuf::Message for CMsgGC_ServerQuestUpdateData {
    fn is_initialized(&self) -> bool {
        for v in &self.player_quest_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.missionlbsdata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_quest_data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.binary_data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mm_game_mode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.missionlbsdata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.player_quest_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.binary_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.mm_game_mode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.missionlbsdata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.player_quest_data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.binary_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.mm_game_mode {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.missionlbsdata.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGC_ServerQuestUpdateData {
    fn new() -> CMsgGC_ServerQuestUpdateData {
        CMsgGC_ServerQuestUpdateData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGC_ServerQuestUpdateData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerQuestData>>(
                    "player_quest_data",
                    CMsgGC_ServerQuestUpdateData::get_player_quest_data_for_reflect,
                    CMsgGC_ServerQuestUpdateData::mut_player_quest_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "binary_data",
                    CMsgGC_ServerQuestUpdateData::get_binary_data_for_reflect,
                    CMsgGC_ServerQuestUpdateData::mut_binary_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mm_game_mode",
                    CMsgGC_ServerQuestUpdateData::get_mm_game_mode_for_reflect,
                    CMsgGC_ServerQuestUpdateData::mut_mm_game_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScoreLeaderboardData>>(
                    "missionlbsdata",
                    CMsgGC_ServerQuestUpdateData::get_missionlbsdata_for_reflect,
                    CMsgGC_ServerQuestUpdateData::mut_missionlbsdata_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGC_ServerQuestUpdateData>(
                    "CMsgGC_ServerQuestUpdateData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGC_ServerQuestUpdateData {
    fn clear(&mut self) {
        self.clear_player_quest_data();
        self.clear_binary_data();
        self.clear_mm_game_mode();
        self.clear_missionlbsdata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_ServerQuestUpdateData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_ServerQuestUpdateData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    // message fields
    packetid: ::std::option::Option<i32>,
    namekeys: ::protobuf::RepeatedField<OperationalStatisticDescription>,
    packets: ::protobuf::RepeatedField<OperationalStatisticsPacket>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {}

impl CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGCOperationalStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGCOperationalStats,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::new)
        }
    }

    // optional int32 packetid = 1;

    pub fn clear_packetid(&mut self) {
        self.packetid = ::std::option::Option::None;
    }

    pub fn has_packetid(&self) -> bool {
        self.packetid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packetid(&mut self, v: i32) {
        self.packetid = ::std::option::Option::Some(v);
    }

    pub fn get_packetid(&self) -> i32 {
        self.packetid.unwrap_or(0)
    }

    fn get_packetid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.packetid
    }

    fn mut_packetid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.packetid
    }

    // repeated .OperationalStatisticDescription namekeys = 2;

    pub fn clear_namekeys(&mut self) {
        self.namekeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_namekeys(&mut self, v: ::protobuf::RepeatedField<OperationalStatisticDescription>) {
        self.namekeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_namekeys(&mut self) -> &mut ::protobuf::RepeatedField<OperationalStatisticDescription> {
        &mut self.namekeys
    }

    // Take field
    pub fn take_namekeys(&mut self) -> ::protobuf::RepeatedField<OperationalStatisticDescription> {
        ::std::mem::replace(&mut self.namekeys, ::protobuf::RepeatedField::new())
    }

    pub fn get_namekeys(&self) -> &[OperationalStatisticDescription] {
        &self.namekeys
    }

    fn get_namekeys_for_reflect(&self) -> &::protobuf::RepeatedField<OperationalStatisticDescription> {
        &self.namekeys
    }

    fn mut_namekeys_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<OperationalStatisticDescription> {
        &mut self.namekeys
    }

    // repeated .OperationalStatisticsPacket packets = 3;

    pub fn clear_packets(&mut self) {
        self.packets.clear();
    }

    // Param is passed by value, moved
    pub fn set_packets(&mut self, v: ::protobuf::RepeatedField<OperationalStatisticsPacket>) {
        self.packets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packets(&mut self) -> &mut ::protobuf::RepeatedField<OperationalStatisticsPacket> {
        &mut self.packets
    }

    // Take field
    pub fn take_packets(&mut self) -> ::protobuf::RepeatedField<OperationalStatisticsPacket> {
        ::std::mem::replace(&mut self.packets, ::protobuf::RepeatedField::new())
    }

    pub fn get_packets(&self) -> &[OperationalStatisticsPacket] {
        &self.packets
    }

    fn get_packets_for_reflect(&self) -> &::protobuf::RepeatedField<OperationalStatisticsPacket> {
        &self.packets
    }

    fn mut_packets_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<OperationalStatisticsPacket> {
        &mut self.packets
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn is_initialized(&self) -> bool {
        for v in &self.namekeys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.packets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.packetid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.namekeys)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.packets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packetid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.namekeys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.packets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packetid {
            os.write_int32(1, v)?;
        }
        for v in &self.namekeys {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.packets {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
        CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingGCOperationalStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "packetid",
                    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::get_packetid_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::mut_packetid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationalStatisticDescription>>(
                    "namekeys",
                    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::get_namekeys_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::mut_namekeys_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationalStatisticsPacket>>(
                    "packets",
                    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::get_packets_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::mut_packets_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGCOperationalStats>(
                    "CMsgGCCStrike15_v2_MatchmakingGCOperationalStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn clear(&mut self) {
        self.clear_packetid();
        self.clear_namekeys();
        self.clear_packets();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    // message fields
    token: ::std::option::Option<u32>,
    stamp: ::std::option::Option<u32>,
    exchange: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {}

impl CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::new)
        }
    }

    // optional uint32 token = 1;

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }

    pub fn get_token(&self) -> u32 {
        self.token.unwrap_or(0)
    }

    fn get_token_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.token
    }

    fn mut_token_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.token
    }

    // optional uint32 stamp = 2;

    pub fn clear_stamp(&mut self) {
        self.stamp = ::std::option::Option::None;
    }

    pub fn has_stamp(&self) -> bool {
        self.stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stamp(&mut self, v: u32) {
        self.stamp = ::std::option::Option::Some(v);
    }

    pub fn get_stamp(&self) -> u32 {
        self.stamp.unwrap_or(0)
    }

    fn get_stamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.stamp
    }

    fn mut_stamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.stamp
    }

    // optional uint64 exchange = 3;

    pub fn clear_exchange(&mut self) {
        self.exchange = ::std::option::Option::None;
    }

    pub fn has_exchange(&self) -> bool {
        self.exchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exchange(&mut self, v: u64) {
        self.exchange = ::std::option::Option::Some(v);
    }

    pub fn get_exchange(&self) -> u64 {
        self.exchange.unwrap_or(0)
    }

    fn get_exchange_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.exchange
    }

    fn mut_exchange_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.exchange
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.token = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.exchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.exchange {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.token {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.exchange {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "token",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::get_token_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::mut_token_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stamp",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::get_stamp_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::mut_stamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "exchange",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::get_exchange_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::mut_exchange_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn clear(&mut self) {
        self.clear_token();
        self.clear_stamp();
        self.clear_exchange();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    // message fields
    viewers_external_total: ::std::option::Option<u32>,
    viewers_external_steam: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {}

impl CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GC2ServerReservationUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GC2ServerReservationUpdate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GC2ServerReservationUpdate::new)
        }
    }

    // optional uint32 viewers_external_total = 1;

    pub fn clear_viewers_external_total(&mut self) {
        self.viewers_external_total = ::std::option::Option::None;
    }

    pub fn has_viewers_external_total(&self) -> bool {
        self.viewers_external_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers_external_total(&mut self, v: u32) {
        self.viewers_external_total = ::std::option::Option::Some(v);
    }

    pub fn get_viewers_external_total(&self) -> u32 {
        self.viewers_external_total.unwrap_or(0)
    }

    fn get_viewers_external_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.viewers_external_total
    }

    fn mut_viewers_external_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.viewers_external_total
    }

    // optional uint32 viewers_external_steam = 2;

    pub fn clear_viewers_external_steam(&mut self) {
        self.viewers_external_steam = ::std::option::Option::None;
    }

    pub fn has_viewers_external_steam(&self) -> bool {
        self.viewers_external_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers_external_steam(&mut self, v: u32) {
        self.viewers_external_steam = ::std::option::Option::Some(v);
    }

    pub fn get_viewers_external_steam(&self) -> u32 {
        self.viewers_external_steam.unwrap_or(0)
    }

    fn get_viewers_external_steam_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.viewers_external_steam
    }

    fn mut_viewers_external_steam_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.viewers_external_steam
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.viewers_external_total = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.viewers_external_steam = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.viewers_external_total {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.viewers_external_steam {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.viewers_external_total {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.viewers_external_steam {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn new() -> CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        CMsgGCCStrike15_v2_GC2ServerReservationUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_GC2ServerReservationUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "viewers_external_total",
                    CMsgGCCStrike15_v2_GC2ServerReservationUpdate::get_viewers_external_total_for_reflect,
                    CMsgGCCStrike15_v2_GC2ServerReservationUpdate::mut_viewers_external_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "viewers_external_steam",
                    CMsgGCCStrike15_v2_GC2ServerReservationUpdate::get_viewers_external_steam_for_reflect,
                    CMsgGCCStrike15_v2_GC2ServerReservationUpdate::mut_viewers_external_steam_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GC2ServerReservationUpdate>(
                    "CMsgGCCStrike15_v2_GC2ServerReservationUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn clear(&mut self) {
        self.clear_viewers_external_total();
        self.clear_viewers_external_steam();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingStart {
    // message fields
    account_ids: ::std::vec::Vec<u32>,
    game_type: ::std::option::Option<u32>,
    ticket_data: ::protobuf::SingularField<::std::string::String>,
    client_version: ::std::option::Option<u32>,
    tournament_match: ::protobuf::SingularPtrField<TournamentMatchSetup>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingStart {}

impl CMsgGCCStrike15_v2_MatchmakingStart {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingStart {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingStart {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingStart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingStart,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingStart::new)
        }
    }

    // repeated uint32 account_ids = 1;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // optional uint32 game_type = 2;

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    fn get_game_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_type
    }

    fn mut_game_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_type
    }

    // optional string ticket_data = 3;

    pub fn clear_ticket_data(&mut self) {
        self.ticket_data.clear();
    }

    pub fn has_ticket_data(&self) -> bool {
        self.ticket_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_data(&mut self, v: ::std::string::String) {
        self.ticket_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket_data(&mut self) -> &mut ::std::string::String {
        if self.ticket_data.is_none() {
            self.ticket_data.set_default();
        }
        self.ticket_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket_data(&mut self) -> ::std::string::String {
        self.ticket_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ticket_data(&self) -> &str {
        match self.ticket_data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_ticket_data_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.ticket_data
    }

    fn mut_ticket_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.ticket_data
    }

    // optional uint32 client_version = 4;

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    pub fn get_client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    fn get_client_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.client_version
    }

    fn mut_client_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.client_version
    }

    // optional .TournamentMatchSetup tournament_match = 5;

    pub fn clear_tournament_match(&mut self) {
        self.tournament_match.clear();
    }

    pub fn has_tournament_match(&self) -> bool {
        self.tournament_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_match(&mut self, v: TournamentMatchSetup) {
        self.tournament_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_match(&mut self) -> &mut TournamentMatchSetup {
        if self.tournament_match.is_none() {
            self.tournament_match.set_default();
        }
        self.tournament_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournament_match(&mut self) -> TournamentMatchSetup {
        self.tournament_match.take().unwrap_or_else(|| TournamentMatchSetup::new())
    }

    pub fn get_tournament_match(&self) -> &TournamentMatchSetup {
        self.tournament_match.as_ref().unwrap_or_else(|| TournamentMatchSetup::default_instance())
    }

    fn get_tournament_match_for_reflect(&self) -> &::protobuf::SingularPtrField<TournamentMatchSetup> {
        &self.tournament_match
    }

    fn mut_tournament_match_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TournamentMatchSetup> {
        &mut self.tournament_match
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingStart {
    fn is_initialized(&self) -> bool {
        for v in &self.tournament_match {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ticket_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_version = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tournament_match)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ticket_data.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tournament_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.game_type {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.ticket_data.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.tournament_match.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingStart {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingStart {
        CMsgGCCStrike15_v2_MatchmakingStart::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingStart>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgGCCStrike15_v2_MatchmakingStart::get_account_ids_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingStart::mut_account_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    CMsgGCCStrike15_v2_MatchmakingStart::get_game_type_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingStart::mut_game_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ticket_data",
                    CMsgGCCStrike15_v2_MatchmakingStart::get_ticket_data_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingStart::mut_ticket_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "client_version",
                    CMsgGCCStrike15_v2_MatchmakingStart::get_client_version_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingStart::mut_client_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentMatchSetup>>(
                    "tournament_match",
                    CMsgGCCStrike15_v2_MatchmakingStart::get_tournament_match_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingStart::mut_tournament_match_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingStart>(
                    "CMsgGCCStrike15_v2_MatchmakingStart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingStart {
    fn clear(&mut self) {
        self.clear_account_ids();
        self.clear_game_type();
        self.clear_ticket_data();
        self.clear_client_version();
        self.clear_tournament_match();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingStart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingStop {
    // message fields
    abandon: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingStop {}

impl CMsgGCCStrike15_v2_MatchmakingStop {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingStop {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingStop {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingStop> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingStop,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingStop::new)
        }
    }

    // optional int32 abandon = 1;

    pub fn clear_abandon(&mut self) {
        self.abandon = ::std::option::Option::None;
    }

    pub fn has_abandon(&self) -> bool {
        self.abandon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandon(&mut self, v: i32) {
        self.abandon = ::std::option::Option::Some(v);
    }

    pub fn get_abandon(&self) -> i32 {
        self.abandon.unwrap_or(0)
    }

    fn get_abandon_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.abandon
    }

    fn mut_abandon_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.abandon
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingStop {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.abandon = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.abandon {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.abandon {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingStop {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingStop {
        CMsgGCCStrike15_v2_MatchmakingStop::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingStop>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "abandon",
                    CMsgGCCStrike15_v2_MatchmakingStop::get_abandon_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingStop::mut_abandon_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingStop>(
                    "CMsgGCCStrike15_v2_MatchmakingStop",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingStop {
    fn clear(&mut self) {
        self.clear_abandon();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingStop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingStop {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    // message fields
    gameserverpings: ::protobuf::RepeatedField<GameServerPing>,
    offset_index: ::std::option::Option<i32>,
    final_batch: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {}

impl CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingClient2ServerPing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingClient2ServerPing,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::new)
        }
    }

    // repeated .GameServerPing gameserverpings = 1;

    pub fn clear_gameserverpings(&mut self) {
        self.gameserverpings.clear();
    }

    // Param is passed by value, moved
    pub fn set_gameserverpings(&mut self, v: ::protobuf::RepeatedField<GameServerPing>) {
        self.gameserverpings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gameserverpings(&mut self) -> &mut ::protobuf::RepeatedField<GameServerPing> {
        &mut self.gameserverpings
    }

    // Take field
    pub fn take_gameserverpings(&mut self) -> ::protobuf::RepeatedField<GameServerPing> {
        ::std::mem::replace(&mut self.gameserverpings, ::protobuf::RepeatedField::new())
    }

    pub fn get_gameserverpings(&self) -> &[GameServerPing] {
        &self.gameserverpings
    }

    fn get_gameserverpings_for_reflect(&self) -> &::protobuf::RepeatedField<GameServerPing> {
        &self.gameserverpings
    }

    fn mut_gameserverpings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<GameServerPing> {
        &mut self.gameserverpings
    }

    // optional int32 offset_index = 2;

    pub fn clear_offset_index(&mut self) {
        self.offset_index = ::std::option::Option::None;
    }

    pub fn has_offset_index(&self) -> bool {
        self.offset_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset_index(&mut self, v: i32) {
        self.offset_index = ::std::option::Option::Some(v);
    }

    pub fn get_offset_index(&self) -> i32 {
        self.offset_index.unwrap_or(0)
    }

    fn get_offset_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.offset_index
    }

    fn mut_offset_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.offset_index
    }

    // optional int32 final_batch = 3;

    pub fn clear_final_batch(&mut self) {
        self.final_batch = ::std::option::Option::None;
    }

    pub fn has_final_batch(&self) -> bool {
        self.final_batch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_final_batch(&mut self, v: i32) {
        self.final_batch = ::std::option::Option::Some(v);
    }

    pub fn get_final_batch(&self) -> i32 {
        self.final_batch.unwrap_or(0)
    }

    fn get_final_batch_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.final_batch
    }

    fn mut_final_batch_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.final_batch
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn is_initialized(&self) -> bool {
        for v in &self.gameserverpings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.gameserverpings)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offset_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_batch = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gameserverpings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.offset_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.final_batch {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gameserverpings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.offset_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.final_batch {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingClient2ServerPing>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GameServerPing>>(
                    "gameserverpings",
                    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::get_gameserverpings_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::mut_gameserverpings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "offset_index",
                    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::get_offset_index_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::mut_offset_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "final_batch",
                    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::get_final_batch_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::mut_final_batch_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingClient2ServerPing>(
                    "CMsgGCCStrike15_v2_MatchmakingClient2ServerPing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn clear(&mut self) {
        self.clear_gameserverpings();
        self.clear_offset_index();
        self.clear_final_batch();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    // message fields
    matchmaking: ::std::option::Option<i32>,
    waiting_account_id_sessions: ::std::vec::Vec<u32>,
    error: ::protobuf::SingularField<::std::string::String>,
    ongoingmatch_account_id_sessions: ::std::vec::Vec<u32>,
    global_stats: ::protobuf::SingularPtrField<GlobalStatistics>,
    failping_account_id_sessions: ::std::vec::Vec<u32>,
    penalty_account_id_sessions: ::std::vec::Vec<u32>,
    failready_account_id_sessions: ::std::vec::Vec<u32>,
    vacbanned_account_id_sessions: ::std::vec::Vec<u32>,
    server_ipaddress_mask: ::protobuf::SingularPtrField<IpAddressMask>,
    notes: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>,
    penalty_account_id_sessions_green: ::std::vec::Vec<u32>,
    insufficientlevel_sessions: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::new)
        }
    }

    // optional int32 matchmaking = 1;

    pub fn clear_matchmaking(&mut self) {
        self.matchmaking = ::std::option::Option::None;
    }

    pub fn has_matchmaking(&self) -> bool {
        self.matchmaking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking(&mut self, v: i32) {
        self.matchmaking = ::std::option::Option::Some(v);
    }

    pub fn get_matchmaking(&self) -> i32 {
        self.matchmaking.unwrap_or(0)
    }

    fn get_matchmaking_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.matchmaking
    }

    fn mut_matchmaking_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.matchmaking
    }

    // repeated uint32 waiting_account_id_sessions = 2;

    pub fn clear_waiting_account_id_sessions(&mut self) {
        self.waiting_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_waiting_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.waiting_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_waiting_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.waiting_account_id_sessions
    }

    // Take field
    pub fn take_waiting_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.waiting_account_id_sessions, ::std::vec::Vec::new())
    }

    pub fn get_waiting_account_id_sessions(&self) -> &[u32] {
        &self.waiting_account_id_sessions
    }

    fn get_waiting_account_id_sessions_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.waiting_account_id_sessions
    }

    fn mut_waiting_account_id_sessions_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.waiting_account_id_sessions
    }

    // optional string error = 3;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_error_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.error
    }

    fn mut_error_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.error
    }

    // repeated uint32 ongoingmatch_account_id_sessions = 6;

    pub fn clear_ongoingmatch_account_id_sessions(&mut self) {
        self.ongoingmatch_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_ongoingmatch_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.ongoingmatch_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ongoingmatch_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ongoingmatch_account_id_sessions
    }

    // Take field
    pub fn take_ongoingmatch_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ongoingmatch_account_id_sessions, ::std::vec::Vec::new())
    }

    pub fn get_ongoingmatch_account_id_sessions(&self) -> &[u32] {
        &self.ongoingmatch_account_id_sessions
    }

    fn get_ongoingmatch_account_id_sessions_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.ongoingmatch_account_id_sessions
    }

    fn mut_ongoingmatch_account_id_sessions_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ongoingmatch_account_id_sessions
    }

    // optional .GlobalStatistics global_stats = 7;

    pub fn clear_global_stats(&mut self) {
        self.global_stats.clear();
    }

    pub fn has_global_stats(&self) -> bool {
        self.global_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_stats(&mut self, v: GlobalStatistics) {
        self.global_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global_stats(&mut self) -> &mut GlobalStatistics {
        if self.global_stats.is_none() {
            self.global_stats.set_default();
        }
        self.global_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_global_stats(&mut self) -> GlobalStatistics {
        self.global_stats.take().unwrap_or_else(|| GlobalStatistics::new())
    }

    pub fn get_global_stats(&self) -> &GlobalStatistics {
        self.global_stats.as_ref().unwrap_or_else(|| GlobalStatistics::default_instance())
    }

    fn get_global_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<GlobalStatistics> {
        &self.global_stats
    }

    fn mut_global_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<GlobalStatistics> {
        &mut self.global_stats
    }

    // repeated uint32 failping_account_id_sessions = 8;

    pub fn clear_failping_account_id_sessions(&mut self) {
        self.failping_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_failping_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.failping_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failping_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.failping_account_id_sessions
    }

    // Take field
    pub fn take_failping_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.failping_account_id_sessions, ::std::vec::Vec::new())
    }

    pub fn get_failping_account_id_sessions(&self) -> &[u32] {
        &self.failping_account_id_sessions
    }

    fn get_failping_account_id_sessions_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.failping_account_id_sessions
    }

    fn mut_failping_account_id_sessions_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.failping_account_id_sessions
    }

    // repeated uint32 penalty_account_id_sessions = 9;

    pub fn clear_penalty_account_id_sessions(&mut self) {
        self.penalty_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_penalty_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.penalty_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_penalty_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.penalty_account_id_sessions
    }

    // Take field
    pub fn take_penalty_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.penalty_account_id_sessions, ::std::vec::Vec::new())
    }

    pub fn get_penalty_account_id_sessions(&self) -> &[u32] {
        &self.penalty_account_id_sessions
    }

    fn get_penalty_account_id_sessions_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.penalty_account_id_sessions
    }

    fn mut_penalty_account_id_sessions_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.penalty_account_id_sessions
    }

    // repeated uint32 failready_account_id_sessions = 10;

    pub fn clear_failready_account_id_sessions(&mut self) {
        self.failready_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_failready_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.failready_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failready_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.failready_account_id_sessions
    }

    // Take field
    pub fn take_failready_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.failready_account_id_sessions, ::std::vec::Vec::new())
    }

    pub fn get_failready_account_id_sessions(&self) -> &[u32] {
        &self.failready_account_id_sessions
    }

    fn get_failready_account_id_sessions_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.failready_account_id_sessions
    }

    fn mut_failready_account_id_sessions_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.failready_account_id_sessions
    }

    // repeated uint32 vacbanned_account_id_sessions = 11;

    pub fn clear_vacbanned_account_id_sessions(&mut self) {
        self.vacbanned_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_vacbanned_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.vacbanned_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vacbanned_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.vacbanned_account_id_sessions
    }

    // Take field
    pub fn take_vacbanned_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.vacbanned_account_id_sessions, ::std::vec::Vec::new())
    }

    pub fn get_vacbanned_account_id_sessions(&self) -> &[u32] {
        &self.vacbanned_account_id_sessions
    }

    fn get_vacbanned_account_id_sessions_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.vacbanned_account_id_sessions
    }

    fn mut_vacbanned_account_id_sessions_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.vacbanned_account_id_sessions
    }

    // optional .IpAddressMask server_ipaddress_mask = 12;

    pub fn clear_server_ipaddress_mask(&mut self) {
        self.server_ipaddress_mask.clear();
    }

    pub fn has_server_ipaddress_mask(&self) -> bool {
        self.server_ipaddress_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ipaddress_mask(&mut self, v: IpAddressMask) {
        self.server_ipaddress_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_ipaddress_mask(&mut self) -> &mut IpAddressMask {
        if self.server_ipaddress_mask.is_none() {
            self.server_ipaddress_mask.set_default();
        }
        self.server_ipaddress_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_ipaddress_mask(&mut self) -> IpAddressMask {
        self.server_ipaddress_mask.take().unwrap_or_else(|| IpAddressMask::new())
    }

    pub fn get_server_ipaddress_mask(&self) -> &IpAddressMask {
        self.server_ipaddress_mask.as_ref().unwrap_or_else(|| IpAddressMask::default_instance())
    }

    fn get_server_ipaddress_mask_for_reflect(&self) -> &::protobuf::SingularPtrField<IpAddressMask> {
        &self.server_ipaddress_mask
    }

    fn mut_server_ipaddress_mask_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<IpAddressMask> {
        &mut self.server_ipaddress_mask
    }

    // repeated .CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note notes = 13;

    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>) {
        self.notes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note> {
        &mut self.notes
    }

    // Take field
    pub fn take_notes(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note> {
        ::std::mem::replace(&mut self.notes, ::protobuf::RepeatedField::new())
    }

    pub fn get_notes(&self) -> &[CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note] {
        &self.notes
    }

    fn get_notes_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note> {
        &self.notes
    }

    fn mut_notes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note> {
        &mut self.notes
    }

    // repeated uint32 penalty_account_id_sessions_green = 14;

    pub fn clear_penalty_account_id_sessions_green(&mut self) {
        self.penalty_account_id_sessions_green.clear();
    }

    // Param is passed by value, moved
    pub fn set_penalty_account_id_sessions_green(&mut self, v: ::std::vec::Vec<u32>) {
        self.penalty_account_id_sessions_green = v;
    }

    // Mutable pointer to the field.
    pub fn mut_penalty_account_id_sessions_green(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.penalty_account_id_sessions_green
    }

    // Take field
    pub fn take_penalty_account_id_sessions_green(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.penalty_account_id_sessions_green, ::std::vec::Vec::new())
    }

    pub fn get_penalty_account_id_sessions_green(&self) -> &[u32] {
        &self.penalty_account_id_sessions_green
    }

    fn get_penalty_account_id_sessions_green_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.penalty_account_id_sessions_green
    }

    fn mut_penalty_account_id_sessions_green_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.penalty_account_id_sessions_green
    }

    // repeated uint32 insufficientlevel_sessions = 15;

    pub fn clear_insufficientlevel_sessions(&mut self) {
        self.insufficientlevel_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_insufficientlevel_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.insufficientlevel_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_insufficientlevel_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.insufficientlevel_sessions
    }

    // Take field
    pub fn take_insufficientlevel_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.insufficientlevel_sessions, ::std::vec::Vec::new())
    }

    pub fn get_insufficientlevel_sessions(&self) -> &[u32] {
        &self.insufficientlevel_sessions
    }

    fn get_insufficientlevel_sessions_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.insufficientlevel_sessions
    }

    fn mut_insufficientlevel_sessions_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.insufficientlevel_sessions
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.global_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.server_ipaddress_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.notes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.matchmaking = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.waiting_account_id_sessions)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.ongoingmatch_account_id_sessions)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.global_stats)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.failping_account_id_sessions)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.penalty_account_id_sessions)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.failready_account_id_sessions)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.vacbanned_account_id_sessions)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_ipaddress_mask)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notes)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.penalty_account_id_sessions_green)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.insufficientlevel_sessions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.matchmaking {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.waiting_account_id_sessions {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.ongoingmatch_account_id_sessions {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.global_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.failping_account_id_sessions {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.penalty_account_id_sessions {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.failready_account_id_sessions {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.vacbanned_account_id_sessions {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.server_ipaddress_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.notes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.penalty_account_id_sessions_green {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.insufficientlevel_sessions {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.matchmaking {
            os.write_int32(1, v)?;
        }
        for v in &self.waiting_account_id_sessions {
            os.write_uint32(2, *v)?;
        };
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.ongoingmatch_account_id_sessions {
            os.write_uint32(6, *v)?;
        };
        if let Some(ref v) = self.global_stats.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.failping_account_id_sessions {
            os.write_uint32(8, *v)?;
        };
        for v in &self.penalty_account_id_sessions {
            os.write_uint32(9, *v)?;
        };
        for v in &self.failready_account_id_sessions {
            os.write_uint32(10, *v)?;
        };
        for v in &self.vacbanned_account_id_sessions {
            os.write_uint32(11, *v)?;
        };
        if let Some(ref v) = self.server_ipaddress_mask.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.notes {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.penalty_account_id_sessions_green {
            os.write_uint32(14, *v)?;
        };
        for v in &self.insufficientlevel_sessions {
            os.write_uint32(15, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "matchmaking",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_matchmaking_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_matchmaking_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "waiting_account_id_sessions",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_waiting_account_id_sessions_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_waiting_account_id_sessions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_error_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_error_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ongoingmatch_account_id_sessions",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_ongoingmatch_account_id_sessions_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_ongoingmatch_account_id_sessions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlobalStatistics>>(
                    "global_stats",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_global_stats_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_global_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "failping_account_id_sessions",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_failping_account_id_sessions_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_failping_account_id_sessions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_account_id_sessions",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_penalty_account_id_sessions_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_penalty_account_id_sessions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "failready_account_id_sessions",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_failready_account_id_sessions_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_failready_account_id_sessions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vacbanned_account_id_sessions",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_vacbanned_account_id_sessions_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_vacbanned_account_id_sessions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IpAddressMask>>(
                    "server_ipaddress_mask",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_server_ipaddress_mask_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_server_ipaddress_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>>(
                    "notes",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_notes_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_notes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_account_id_sessions_green",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_penalty_account_id_sessions_green_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_penalty_account_id_sessions_green_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "insufficientlevel_sessions",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::get_insufficientlevel_sessions_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::mut_insufficientlevel_sessions_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn clear(&mut self) {
        self.clear_matchmaking();
        self.clear_waiting_account_id_sessions();
        self.clear_error();
        self.clear_ongoingmatch_account_id_sessions();
        self.clear_global_stats();
        self.clear_failping_account_id_sessions();
        self.clear_penalty_account_id_sessions();
        self.clear_failready_account_id_sessions();
        self.clear_vacbanned_account_id_sessions();
        self.clear_server_ipaddress_mask();
        self.clear_notes();
        self.clear_penalty_account_id_sessions_green();
        self.clear_insufficientlevel_sessions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    // message fields
    field_type: ::std::option::Option<i32>,
    region_id: ::std::option::Option<i32>,
    region_r: ::std::option::Option<f32>,
    distance: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::new)
        }
    }

    // optional int32 type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.field_type
    }

    // optional int32 region_id = 2;

    pub fn clear_region_id(&mut self) {
        self.region_id = ::std::option::Option::None;
    }

    pub fn has_region_id(&self) -> bool {
        self.region_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: i32) {
        self.region_id = ::std::option::Option::Some(v);
    }

    pub fn get_region_id(&self) -> i32 {
        self.region_id.unwrap_or(0)
    }

    fn get_region_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.region_id
    }

    fn mut_region_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.region_id
    }

    // optional float region_r = 3;

    pub fn clear_region_r(&mut self) {
        self.region_r = ::std::option::Option::None;
    }

    pub fn has_region_r(&self) -> bool {
        self.region_r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_r(&mut self, v: f32) {
        self.region_r = ::std::option::Option::Some(v);
    }

    pub fn get_region_r(&self) -> f32 {
        self.region_r.unwrap_or(0.)
    }

    fn get_region_r_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.region_r
    }

    fn mut_region_r_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.region_r
    }

    // optional float distance = 4;

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }

    pub fn get_distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    fn get_distance_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.distance
    }

    fn mut_distance_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.distance
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.region_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.region_r = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.distance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.region_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.region_r {
            my_size += 5;
        }
        if let Some(v) = self.distance {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.region_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.region_r {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.distance {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::get_field_type_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "region_id",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::get_region_id_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::mut_region_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "region_r",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::get_region_r_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::mut_region_r_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "distance",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::get_distance_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::mut_distance_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_region_id();
        self.clear_region_r();
        self.clear_distance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentMatchDraft {
    // message fields
    event_id: ::std::option::Option<i32>,
    event_stage_id: ::std::option::Option<i32>,
    team_id_0: ::std::option::Option<i32>,
    team_id_1: ::std::option::Option<i32>,
    maps_count: ::std::option::Option<i32>,
    maps_current: ::std::option::Option<i32>,
    team_id_start: ::std::option::Option<i32>,
    team_id_veto1: ::std::option::Option<i32>,
    team_id_pickn: ::std::option::Option<i32>,
    drafts: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentMatchDraft_Entry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDataGCCStrike15_v2_TournamentMatchDraft {}

impl CDataGCCStrike15_v2_TournamentMatchDraft {
    pub fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentMatchDraft {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentMatchDraft> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentMatchDraft,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentMatchDraft::new)
        }
    }

    // optional int32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.event_id
    }

    // optional int32 event_stage_id = 2;

    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }

    fn get_event_stage_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.event_stage_id
    }

    fn mut_event_stage_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.event_stage_id
    }

    // optional int32 team_id_0 = 3;

    pub fn clear_team_id_0(&mut self) {
        self.team_id_0 = ::std::option::Option::None;
    }

    pub fn has_team_id_0(&self) -> bool {
        self.team_id_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_0(&mut self, v: i32) {
        self.team_id_0 = ::std::option::Option::Some(v);
    }

    pub fn get_team_id_0(&self) -> i32 {
        self.team_id_0.unwrap_or(0)
    }

    fn get_team_id_0_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.team_id_0
    }

    fn mut_team_id_0_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.team_id_0
    }

    // optional int32 team_id_1 = 4;

    pub fn clear_team_id_1(&mut self) {
        self.team_id_1 = ::std::option::Option::None;
    }

    pub fn has_team_id_1(&self) -> bool {
        self.team_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_1(&mut self, v: i32) {
        self.team_id_1 = ::std::option::Option::Some(v);
    }

    pub fn get_team_id_1(&self) -> i32 {
        self.team_id_1.unwrap_or(0)
    }

    fn get_team_id_1_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.team_id_1
    }

    fn mut_team_id_1_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.team_id_1
    }

    // optional int32 maps_count = 5;

    pub fn clear_maps_count(&mut self) {
        self.maps_count = ::std::option::Option::None;
    }

    pub fn has_maps_count(&self) -> bool {
        self.maps_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maps_count(&mut self, v: i32) {
        self.maps_count = ::std::option::Option::Some(v);
    }

    pub fn get_maps_count(&self) -> i32 {
        self.maps_count.unwrap_or(0)
    }

    fn get_maps_count_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.maps_count
    }

    fn mut_maps_count_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.maps_count
    }

    // optional int32 maps_current = 6;

    pub fn clear_maps_current(&mut self) {
        self.maps_current = ::std::option::Option::None;
    }

    pub fn has_maps_current(&self) -> bool {
        self.maps_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maps_current(&mut self, v: i32) {
        self.maps_current = ::std::option::Option::Some(v);
    }

    pub fn get_maps_current(&self) -> i32 {
        self.maps_current.unwrap_or(0)
    }

    fn get_maps_current_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.maps_current
    }

    fn mut_maps_current_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.maps_current
    }

    // optional int32 team_id_start = 7;

    pub fn clear_team_id_start(&mut self) {
        self.team_id_start = ::std::option::Option::None;
    }

    pub fn has_team_id_start(&self) -> bool {
        self.team_id_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_start(&mut self, v: i32) {
        self.team_id_start = ::std::option::Option::Some(v);
    }

    pub fn get_team_id_start(&self) -> i32 {
        self.team_id_start.unwrap_or(0)
    }

    fn get_team_id_start_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.team_id_start
    }

    fn mut_team_id_start_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.team_id_start
    }

    // optional int32 team_id_veto1 = 8;

    pub fn clear_team_id_veto1(&mut self) {
        self.team_id_veto1 = ::std::option::Option::None;
    }

    pub fn has_team_id_veto1(&self) -> bool {
        self.team_id_veto1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_veto1(&mut self, v: i32) {
        self.team_id_veto1 = ::std::option::Option::Some(v);
    }

    pub fn get_team_id_veto1(&self) -> i32 {
        self.team_id_veto1.unwrap_or(0)
    }

    fn get_team_id_veto1_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.team_id_veto1
    }

    fn mut_team_id_veto1_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.team_id_veto1
    }

    // optional int32 team_id_pickn = 9;

    pub fn clear_team_id_pickn(&mut self) {
        self.team_id_pickn = ::std::option::Option::None;
    }

    pub fn has_team_id_pickn(&self) -> bool {
        self.team_id_pickn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_pickn(&mut self, v: i32) {
        self.team_id_pickn = ::std::option::Option::Some(v);
    }

    pub fn get_team_id_pickn(&self) -> i32 {
        self.team_id_pickn.unwrap_or(0)
    }

    fn get_team_id_pickn_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.team_id_pickn
    }

    fn mut_team_id_pickn_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.team_id_pickn
    }

    // repeated .CDataGCCStrike15_v2_TournamentMatchDraft.Entry drafts = 10;

    pub fn clear_drafts(&mut self) {
        self.drafts.clear();
    }

    // Param is passed by value, moved
    pub fn set_drafts(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentMatchDraft_Entry>) {
        self.drafts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_drafts(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentMatchDraft_Entry> {
        &mut self.drafts
    }

    // Take field
    pub fn take_drafts(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentMatchDraft_Entry> {
        ::std::mem::replace(&mut self.drafts, ::protobuf::RepeatedField::new())
    }

    pub fn get_drafts(&self) -> &[CDataGCCStrike15_v2_TournamentMatchDraft_Entry] {
        &self.drafts
    }

    fn get_drafts_for_reflect(&self) -> &::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentMatchDraft_Entry> {
        &self.drafts
    }

    fn mut_drafts_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentMatchDraft_Entry> {
        &mut self.drafts
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn is_initialized(&self) -> bool {
        for v in &self.drafts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_stage_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_0 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_1 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maps_count = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maps_current = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_start = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_veto1 = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_pickn = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.drafts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_0 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_1 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maps_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maps_current {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_start {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_veto1 {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_pickn {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.drafts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.team_id_0 {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.team_id_1 {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.maps_count {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.maps_current {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.team_id_start {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.team_id_veto1 {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.team_id_pickn {
            os.write_int32(9, v)?;
        }
        for v in &self.drafts {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft {
        CDataGCCStrike15_v2_TournamentMatchDraft::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDataGCCStrike15_v2_TournamentMatchDraft>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_id",
                    CDataGCCStrike15_v2_TournamentMatchDraft::get_event_id_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_stage_id",
                    CDataGCCStrike15_v2_TournamentMatchDraft::get_event_stage_id_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft::mut_event_stage_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_0",
                    CDataGCCStrike15_v2_TournamentMatchDraft::get_team_id_0_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft::mut_team_id_0_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_1",
                    CDataGCCStrike15_v2_TournamentMatchDraft::get_team_id_1_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft::mut_team_id_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "maps_count",
                    CDataGCCStrike15_v2_TournamentMatchDraft::get_maps_count_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft::mut_maps_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "maps_current",
                    CDataGCCStrike15_v2_TournamentMatchDraft::get_maps_current_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft::mut_maps_current_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_start",
                    CDataGCCStrike15_v2_TournamentMatchDraft::get_team_id_start_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft::mut_team_id_start_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_veto1",
                    CDataGCCStrike15_v2_TournamentMatchDraft::get_team_id_veto1_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft::mut_team_id_veto1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_pickn",
                    CDataGCCStrike15_v2_TournamentMatchDraft::get_team_id_pickn_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft::mut_team_id_pickn_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentMatchDraft_Entry>>(
                    "drafts",
                    CDataGCCStrike15_v2_TournamentMatchDraft::get_drafts_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft::mut_drafts_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentMatchDraft>(
                    "CDataGCCStrike15_v2_TournamentMatchDraft",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_event_stage_id();
        self.clear_team_id_0();
        self.clear_team_id_1();
        self.clear_maps_count();
        self.clear_maps_current();
        self.clear_team_id_start();
        self.clear_team_id_veto1();
        self.clear_team_id_pickn();
        self.clear_drafts();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    // message fields
    mapid: ::std::option::Option<i32>,
    team_id_ct: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDataGCCStrike15_v2_TournamentMatchDraft_Entry {}

impl CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    pub fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentMatchDraft_Entry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentMatchDraft_Entry,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentMatchDraft_Entry::new)
        }
    }

    // optional int32 mapid = 1;

    pub fn clear_mapid(&mut self) {
        self.mapid = ::std::option::Option::None;
    }

    pub fn has_mapid(&self) -> bool {
        self.mapid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mapid(&mut self, v: i32) {
        self.mapid = ::std::option::Option::Some(v);
    }

    pub fn get_mapid(&self) -> i32 {
        self.mapid.unwrap_or(0)
    }

    fn get_mapid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.mapid
    }

    fn mut_mapid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.mapid
    }

    // optional int32 team_id_ct = 2;

    pub fn clear_team_id_ct(&mut self) {
        self.team_id_ct = ::std::option::Option::None;
    }

    pub fn has_team_id_ct(&self) -> bool {
        self.team_id_ct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_ct(&mut self, v: i32) {
        self.team_id_ct = ::std::option::Option::Some(v);
    }

    pub fn get_team_id_ct(&self) -> i32 {
        self.team_id_ct.unwrap_or(0)
    }

    fn get_team_id_ct_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.team_id_ct
    }

    fn mut_team_id_ct_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.team_id_ct
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mapid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_ct = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mapid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_ct {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mapid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_id_ct {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
        CDataGCCStrike15_v2_TournamentMatchDraft_Entry::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDataGCCStrike15_v2_TournamentMatchDraft_Entry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mapid",
                    CDataGCCStrike15_v2_TournamentMatchDraft_Entry::get_mapid_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft_Entry::mut_mapid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_ct",
                    CDataGCCStrike15_v2_TournamentMatchDraft_Entry::get_team_id_ct_for_reflect,
                    CDataGCCStrike15_v2_TournamentMatchDraft_Entry::mut_team_id_ct_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentMatchDraft_Entry>(
                    "CDataGCCStrike15_v2_TournamentMatchDraft_Entry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    fn clear(&mut self) {
        self.clear_mapid();
        self.clear_team_id_ct();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPreMatchInfoData {
    // message fields
    predictions_pct: ::std::option::Option<i32>,
    draft: ::protobuf::SingularPtrField<CDataGCCStrike15_v2_TournamentMatchDraft>,
    stats: ::protobuf::RepeatedField<CPreMatchInfoData_TeamStats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CPreMatchInfoData {}

impl CPreMatchInfoData {
    pub fn new() -> CPreMatchInfoData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CPreMatchInfoData {
        static mut instance: ::protobuf::lazy::Lazy<CPreMatchInfoData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPreMatchInfoData,
        };
        unsafe {
            instance.get(CPreMatchInfoData::new)
        }
    }

    // optional int32 predictions_pct = 1;

    pub fn clear_predictions_pct(&mut self) {
        self.predictions_pct = ::std::option::Option::None;
    }

    pub fn has_predictions_pct(&self) -> bool {
        self.predictions_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predictions_pct(&mut self, v: i32) {
        self.predictions_pct = ::std::option::Option::Some(v);
    }

    pub fn get_predictions_pct(&self) -> i32 {
        self.predictions_pct.unwrap_or(0)
    }

    fn get_predictions_pct_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.predictions_pct
    }

    fn mut_predictions_pct_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.predictions_pct
    }

    // optional .CDataGCCStrike15_v2_TournamentMatchDraft draft = 4;

    pub fn clear_draft(&mut self) {
        self.draft.clear();
    }

    pub fn has_draft(&self) -> bool {
        self.draft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_draft(&mut self, v: CDataGCCStrike15_v2_TournamentMatchDraft) {
        self.draft = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_draft(&mut self) -> &mut CDataGCCStrike15_v2_TournamentMatchDraft {
        if self.draft.is_none() {
            self.draft.set_default();
        }
        self.draft.as_mut().unwrap()
    }

    // Take field
    pub fn take_draft(&mut self) -> CDataGCCStrike15_v2_TournamentMatchDraft {
        self.draft.take().unwrap_or_else(|| CDataGCCStrike15_v2_TournamentMatchDraft::new())
    }

    pub fn get_draft(&self) -> &CDataGCCStrike15_v2_TournamentMatchDraft {
        self.draft.as_ref().unwrap_or_else(|| CDataGCCStrike15_v2_TournamentMatchDraft::default_instance())
    }

    fn get_draft_for_reflect(&self) -> &::protobuf::SingularPtrField<CDataGCCStrike15_v2_TournamentMatchDraft> {
        &self.draft
    }

    fn mut_draft_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDataGCCStrike15_v2_TournamentMatchDraft> {
        &mut self.draft
    }

    // repeated .CPreMatchInfoData.TeamStats stats = 5;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CPreMatchInfoData_TeamStats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<CPreMatchInfoData_TeamStats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CPreMatchInfoData_TeamStats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_stats(&self) -> &[CPreMatchInfoData_TeamStats] {
        &self.stats
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CPreMatchInfoData_TeamStats> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CPreMatchInfoData_TeamStats> {
        &mut self.stats
    }
}

impl ::protobuf::Message for CPreMatchInfoData {
    fn is_initialized(&self) -> bool {
        for v in &self.draft {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.predictions_pct = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.draft)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.predictions_pct {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.draft.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.predictions_pct {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.draft.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.stats {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CPreMatchInfoData {
    fn new() -> CPreMatchInfoData {
        CPreMatchInfoData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CPreMatchInfoData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "predictions_pct",
                    CPreMatchInfoData::get_predictions_pct_for_reflect,
                    CPreMatchInfoData::mut_predictions_pct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentMatchDraft>>(
                    "draft",
                    CPreMatchInfoData::get_draft_for_reflect,
                    CPreMatchInfoData::mut_draft_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPreMatchInfoData_TeamStats>>(
                    "stats",
                    CPreMatchInfoData::get_stats_for_reflect,
                    CPreMatchInfoData::mut_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPreMatchInfoData>(
                    "CPreMatchInfoData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CPreMatchInfoData {
    fn clear(&mut self) {
        self.clear_predictions_pct();
        self.clear_draft();
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPreMatchInfoData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPreMatchInfoData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPreMatchInfoData_TeamStats {
    // message fields
    match_info_idxtxt: ::std::option::Option<i32>,
    match_info_txt: ::protobuf::SingularField<::std::string::String>,
    match_info_teams: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CPreMatchInfoData_TeamStats {}

impl CPreMatchInfoData_TeamStats {
    pub fn new() -> CPreMatchInfoData_TeamStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CPreMatchInfoData_TeamStats {
        static mut instance: ::protobuf::lazy::Lazy<CPreMatchInfoData_TeamStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPreMatchInfoData_TeamStats,
        };
        unsafe {
            instance.get(CPreMatchInfoData_TeamStats::new)
        }
    }

    // optional int32 match_info_idxtxt = 1;

    pub fn clear_match_info_idxtxt(&mut self) {
        self.match_info_idxtxt = ::std::option::Option::None;
    }

    pub fn has_match_info_idxtxt(&self) -> bool {
        self.match_info_idxtxt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_info_idxtxt(&mut self, v: i32) {
        self.match_info_idxtxt = ::std::option::Option::Some(v);
    }

    pub fn get_match_info_idxtxt(&self) -> i32 {
        self.match_info_idxtxt.unwrap_or(0)
    }

    fn get_match_info_idxtxt_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.match_info_idxtxt
    }

    fn mut_match_info_idxtxt_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.match_info_idxtxt
    }

    // optional string match_info_txt = 2;

    pub fn clear_match_info_txt(&mut self) {
        self.match_info_txt.clear();
    }

    pub fn has_match_info_txt(&self) -> bool {
        self.match_info_txt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_info_txt(&mut self, v: ::std::string::String) {
        self.match_info_txt = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_info_txt(&mut self) -> &mut ::std::string::String {
        if self.match_info_txt.is_none() {
            self.match_info_txt.set_default();
        }
        self.match_info_txt.as_mut().unwrap()
    }

    // Take field
    pub fn take_match_info_txt(&mut self) -> ::std::string::String {
        self.match_info_txt.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_match_info_txt(&self) -> &str {
        match self.match_info_txt.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_match_info_txt_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.match_info_txt
    }

    fn mut_match_info_txt_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.match_info_txt
    }

    // repeated string match_info_teams = 3;

    pub fn clear_match_info_teams(&mut self) {
        self.match_info_teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_info_teams(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.match_info_teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_match_info_teams(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.match_info_teams
    }

    // Take field
    pub fn take_match_info_teams(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.match_info_teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_match_info_teams(&self) -> &[::std::string::String] {
        &self.match_info_teams
    }

    fn get_match_info_teams_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.match_info_teams
    }

    fn mut_match_info_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.match_info_teams
    }
}

impl ::protobuf::Message for CPreMatchInfoData_TeamStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.match_info_idxtxt = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.match_info_txt)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.match_info_teams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_info_idxtxt {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.match_info_txt.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.match_info_teams {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_info_idxtxt {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.match_info_txt.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.match_info_teams {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CPreMatchInfoData_TeamStats {
    fn new() -> CPreMatchInfoData_TeamStats {
        CPreMatchInfoData_TeamStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CPreMatchInfoData_TeamStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "match_info_idxtxt",
                    CPreMatchInfoData_TeamStats::get_match_info_idxtxt_for_reflect,
                    CPreMatchInfoData_TeamStats::mut_match_info_idxtxt_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match_info_txt",
                    CPreMatchInfoData_TeamStats::get_match_info_txt_for_reflect,
                    CPreMatchInfoData_TeamStats::mut_match_info_txt_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match_info_teams",
                    CPreMatchInfoData_TeamStats::get_match_info_teams_for_reflect,
                    CPreMatchInfoData_TeamStats::mut_match_info_teams_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPreMatchInfoData_TeamStats>(
                    "CPreMatchInfoData_TeamStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CPreMatchInfoData_TeamStats {
    fn clear(&mut self) {
        self.clear_match_info_idxtxt();
        self.clear_match_info_txt();
        self.clear_match_info_teams();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPreMatchInfoData_TeamStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPreMatchInfoData_TeamStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    // message fields
    account_ids: ::std::vec::Vec<u32>,
    game_type: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    server_version: ::std::option::Option<u32>,
    rankings: ::protobuf::RepeatedField<PlayerRankingInfo>,
    encryption_key: ::std::option::Option<u64>,
    encryption_key_pub: ::std::option::Option<u64>,
    party_ids: ::std::vec::Vec<u32>,
    whitelist: ::protobuf::RepeatedField<IpAddressMask>,
    tv_master_steamid: ::std::option::Option<u64>,
    tournament_event: ::protobuf::SingularPtrField<TournamentEvent>,
    tournament_teams: ::protobuf::RepeatedField<TournamentTeam>,
    tournament_casters_account_ids: ::std::vec::Vec<u32>,
    tv_relay_steamid: ::std::option::Option<u64>,
    pre_match_data: ::protobuf::SingularPtrField<CPreMatchInfoData>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {}

impl CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new)
        }
    }

    // repeated uint32 account_ids = 1;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // optional uint32 game_type = 2;

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    fn get_game_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_type
    }

    fn mut_game_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_type
    }

    // optional uint64 match_id = 3;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 server_version = 4;

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    fn get_server_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_version
    }

    fn mut_server_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_version
    }

    // repeated .PlayerRankingInfo rankings = 5;

    pub fn clear_rankings(&mut self) {
        self.rankings.clear();
    }

    // Param is passed by value, moved
    pub fn set_rankings(&mut self, v: ::protobuf::RepeatedField<PlayerRankingInfo>) {
        self.rankings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rankings(&mut self) -> &mut ::protobuf::RepeatedField<PlayerRankingInfo> {
        &mut self.rankings
    }

    // Take field
    pub fn take_rankings(&mut self) -> ::protobuf::RepeatedField<PlayerRankingInfo> {
        ::std::mem::replace(&mut self.rankings, ::protobuf::RepeatedField::new())
    }

    pub fn get_rankings(&self) -> &[PlayerRankingInfo] {
        &self.rankings
    }

    fn get_rankings_for_reflect(&self) -> &::protobuf::RepeatedField<PlayerRankingInfo> {
        &self.rankings
    }

    fn mut_rankings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PlayerRankingInfo> {
        &mut self.rankings
    }

    // optional uint64 encryption_key = 6;

    pub fn clear_encryption_key(&mut self) {
        self.encryption_key = ::std::option::Option::None;
    }

    pub fn has_encryption_key(&self) -> bool {
        self.encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key(&mut self, v: u64) {
        self.encryption_key = ::std::option::Option::Some(v);
    }

    pub fn get_encryption_key(&self) -> u64 {
        self.encryption_key.unwrap_or(0)
    }

    fn get_encryption_key_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.encryption_key
    }

    fn mut_encryption_key_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.encryption_key
    }

    // optional uint64 encryption_key_pub = 7;

    pub fn clear_encryption_key_pub(&mut self) {
        self.encryption_key_pub = ::std::option::Option::None;
    }

    pub fn has_encryption_key_pub(&self) -> bool {
        self.encryption_key_pub.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key_pub(&mut self, v: u64) {
        self.encryption_key_pub = ::std::option::Option::Some(v);
    }

    pub fn get_encryption_key_pub(&self) -> u64 {
        self.encryption_key_pub.unwrap_or(0)
    }

    fn get_encryption_key_pub_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.encryption_key_pub
    }

    fn mut_encryption_key_pub_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.encryption_key_pub
    }

    // repeated uint32 party_ids = 8;

    pub fn clear_party_ids(&mut self) {
        self.party_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_party_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.party_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_party_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.party_ids
    }

    // Take field
    pub fn take_party_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.party_ids, ::std::vec::Vec::new())
    }

    pub fn get_party_ids(&self) -> &[u32] {
        &self.party_ids
    }

    fn get_party_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.party_ids
    }

    fn mut_party_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.party_ids
    }

    // repeated .IpAddressMask whitelist = 9;

    pub fn clear_whitelist(&mut self) {
        self.whitelist.clear();
    }

    // Param is passed by value, moved
    pub fn set_whitelist(&mut self, v: ::protobuf::RepeatedField<IpAddressMask>) {
        self.whitelist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_whitelist(&mut self) -> &mut ::protobuf::RepeatedField<IpAddressMask> {
        &mut self.whitelist
    }

    // Take field
    pub fn take_whitelist(&mut self) -> ::protobuf::RepeatedField<IpAddressMask> {
        ::std::mem::replace(&mut self.whitelist, ::protobuf::RepeatedField::new())
    }

    pub fn get_whitelist(&self) -> &[IpAddressMask] {
        &self.whitelist
    }

    fn get_whitelist_for_reflect(&self) -> &::protobuf::RepeatedField<IpAddressMask> {
        &self.whitelist
    }

    fn mut_whitelist_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<IpAddressMask> {
        &mut self.whitelist
    }

    // optional uint64 tv_master_steamid = 10;

    pub fn clear_tv_master_steamid(&mut self) {
        self.tv_master_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_master_steamid(&self) -> bool {
        self.tv_master_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_master_steamid(&mut self, v: u64) {
        self.tv_master_steamid = ::std::option::Option::Some(v);
    }

    pub fn get_tv_master_steamid(&self) -> u64 {
        self.tv_master_steamid.unwrap_or(0)
    }

    fn get_tv_master_steamid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.tv_master_steamid
    }

    fn mut_tv_master_steamid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.tv_master_steamid
    }

    // optional .TournamentEvent tournament_event = 11;

    pub fn clear_tournament_event(&mut self) {
        self.tournament_event.clear();
    }

    pub fn has_tournament_event(&self) -> bool {
        self.tournament_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_event(&mut self, v: TournamentEvent) {
        self.tournament_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_event(&mut self) -> &mut TournamentEvent {
        if self.tournament_event.is_none() {
            self.tournament_event.set_default();
        }
        self.tournament_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournament_event(&mut self) -> TournamentEvent {
        self.tournament_event.take().unwrap_or_else(|| TournamentEvent::new())
    }

    pub fn get_tournament_event(&self) -> &TournamentEvent {
        self.tournament_event.as_ref().unwrap_or_else(|| TournamentEvent::default_instance())
    }

    fn get_tournament_event_for_reflect(&self) -> &::protobuf::SingularPtrField<TournamentEvent> {
        &self.tournament_event
    }

    fn mut_tournament_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TournamentEvent> {
        &mut self.tournament_event
    }

    // repeated .TournamentTeam tournament_teams = 12;

    pub fn clear_tournament_teams(&mut self) {
        self.tournament_teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_tournament_teams(&mut self, v: ::protobuf::RepeatedField<TournamentTeam>) {
        self.tournament_teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tournament_teams(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.tournament_teams
    }

    // Take field
    pub fn take_tournament_teams(&mut self) -> ::protobuf::RepeatedField<TournamentTeam> {
        ::std::mem::replace(&mut self.tournament_teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_tournament_teams(&self) -> &[TournamentTeam] {
        &self.tournament_teams
    }

    fn get_tournament_teams_for_reflect(&self) -> &::protobuf::RepeatedField<TournamentTeam> {
        &self.tournament_teams
    }

    fn mut_tournament_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.tournament_teams
    }

    // repeated uint32 tournament_casters_account_ids = 13;

    pub fn clear_tournament_casters_account_ids(&mut self) {
        self.tournament_casters_account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_tournament_casters_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.tournament_casters_account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tournament_casters_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tournament_casters_account_ids
    }

    // Take field
    pub fn take_tournament_casters_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tournament_casters_account_ids, ::std::vec::Vec::new())
    }

    pub fn get_tournament_casters_account_ids(&self) -> &[u32] {
        &self.tournament_casters_account_ids
    }

    fn get_tournament_casters_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.tournament_casters_account_ids
    }

    fn mut_tournament_casters_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tournament_casters_account_ids
    }

    // optional uint64 tv_relay_steamid = 14;

    pub fn clear_tv_relay_steamid(&mut self) {
        self.tv_relay_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_relay_steamid(&self) -> bool {
        self.tv_relay_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_steamid(&mut self, v: u64) {
        self.tv_relay_steamid = ::std::option::Option::Some(v);
    }

    pub fn get_tv_relay_steamid(&self) -> u64 {
        self.tv_relay_steamid.unwrap_or(0)
    }

    fn get_tv_relay_steamid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.tv_relay_steamid
    }

    fn mut_tv_relay_steamid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.tv_relay_steamid
    }

    // optional .CPreMatchInfoData pre_match_data = 15;

    pub fn clear_pre_match_data(&mut self) {
        self.pre_match_data.clear();
    }

    pub fn has_pre_match_data(&self) -> bool {
        self.pre_match_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_match_data(&mut self, v: CPreMatchInfoData) {
        self.pre_match_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pre_match_data(&mut self) -> &mut CPreMatchInfoData {
        if self.pre_match_data.is_none() {
            self.pre_match_data.set_default();
        }
        self.pre_match_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_pre_match_data(&mut self) -> CPreMatchInfoData {
        self.pre_match_data.take().unwrap_or_else(|| CPreMatchInfoData::new())
    }

    pub fn get_pre_match_data(&self) -> &CPreMatchInfoData {
        self.pre_match_data.as_ref().unwrap_or_else(|| CPreMatchInfoData::default_instance())
    }

    fn get_pre_match_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CPreMatchInfoData> {
        &self.pre_match_data
    }

    fn mut_pre_match_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CPreMatchInfoData> {
        &mut self.pre_match_data
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn is_initialized(&self) -> bool {
        for v in &self.rankings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.whitelist {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tournament_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tournament_teams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pre_match_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rankings)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.encryption_key = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.encryption_key_pub = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.party_ids)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.whitelist)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tv_master_steamid = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tournament_event)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tournament_teams)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.tournament_casters_account_ids)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tv_relay_steamid = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pre_match_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.rankings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.encryption_key {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.encryption_key_pub {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.party_ids {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.whitelist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.tv_master_steamid {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tournament_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tournament_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tournament_casters_account_ids {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.tv_relay_steamid {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pre_match_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.game_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(4, v)?;
        }
        for v in &self.rankings {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.encryption_key {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.encryption_key_pub {
            os.write_uint64(7, v)?;
        }
        for v in &self.party_ids {
            os.write_uint32(8, *v)?;
        };
        for v in &self.whitelist {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.tv_master_steamid {
            os.write_uint64(10, v)?;
        }
        if let Some(ref v) = self.tournament_event.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tournament_teams {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tournament_casters_account_ids {
            os.write_uint32(13, *v)?;
        };
        if let Some(v) = self.tv_relay_steamid {
            os.write_uint64(14, v)?;
        }
        if let Some(ref v) = self.pre_match_data.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_account_ids_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_account_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_game_type_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_game_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_match_id_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_version",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_server_version_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_server_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerRankingInfo>>(
                    "rankings",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_rankings_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_rankings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "encryption_key",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_encryption_key_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_encryption_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "encryption_key_pub",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_encryption_key_pub_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_encryption_key_pub_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "party_ids",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_party_ids_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_party_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IpAddressMask>>(
                    "whitelist",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_whitelist_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_whitelist_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tv_master_steamid",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_tv_master_steamid_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_tv_master_steamid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentEvent>>(
                    "tournament_event",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_tournament_event_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_tournament_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentTeam>>(
                    "tournament_teams",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_tournament_teams_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_tournament_teams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tournament_casters_account_ids",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_tournament_casters_account_ids_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_tournament_casters_account_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tv_relay_steamid",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_tv_relay_steamid_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_tv_relay_steamid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPreMatchInfoData>>(
                    "pre_match_data",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::get_pre_match_data_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::mut_pre_match_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn clear(&mut self) {
        self.clear_account_ids();
        self.clear_game_type();
        self.clear_match_id();
        self.clear_server_version();
        self.clear_rankings();
        self.clear_encryption_key();
        self.clear_encryption_key_pub();
        self.clear_party_ids();
        self.clear_whitelist();
        self.clear_tv_master_steamid();
        self.clear_tournament_event();
        self.clear_tournament_teams();
        self.clear_tournament_casters_account_ids();
        self.clear_tv_relay_steamid();
        self.clear_pre_match_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    // message fields
    reservationid: ::std::option::Option<u64>,
    reservation: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    map: ::protobuf::SingularField<::std::string::String>,
    gc_reservation_sent: ::std::option::Option<u64>,
    server_version: ::std::option::Option<u32>,
    tv_info: ::protobuf::SingularPtrField<ServerHltvInfo>,
    reward_player_accounts: ::std::vec::Vec<u32>,
    idle_player_accounts: ::std::vec::Vec<u32>,
    reward_item_attr_def_idx: ::std::option::Option<u32>,
    reward_item_attr_value: ::std::option::Option<u32>,
    reward_item_attr_reward_idx: ::std::option::Option<u32>,
    reward_drop_list: ::std::option::Option<u32>,
    tournament_tag: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {}

impl CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingServerReservationResponse,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::new)
        }
    }

    // optional uint64 reservationid = 1;

    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    pub fn get_reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }

    fn get_reservationid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.reservationid
    }

    fn mut_reservationid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.reservationid
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve reservation = 2;

    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        if self.reservation.is_none() {
            self.reservation.set_default();
        }
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new())
    }

    pub fn get_reservation(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::default_instance())
    }

    fn get_reservation_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve> {
        &self.reservation
    }

    fn mut_reservation_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve> {
        &mut self.reservation
    }

    // optional string map = 3;

    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map.set_default();
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_map_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.map
    }

    fn mut_map_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.map
    }

    // optional uint64 gc_reservation_sent = 4;

    pub fn clear_gc_reservation_sent(&mut self) {
        self.gc_reservation_sent = ::std::option::Option::None;
    }

    pub fn has_gc_reservation_sent(&self) -> bool {
        self.gc_reservation_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_reservation_sent(&mut self, v: u64) {
        self.gc_reservation_sent = ::std::option::Option::Some(v);
    }

    pub fn get_gc_reservation_sent(&self) -> u64 {
        self.gc_reservation_sent.unwrap_or(0)
    }

    fn get_gc_reservation_sent_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.gc_reservation_sent
    }

    fn mut_gc_reservation_sent_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.gc_reservation_sent
    }

    // optional uint32 server_version = 5;

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    fn get_server_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_version
    }

    fn mut_server_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_version
    }

    // optional .ServerHltvInfo tv_info = 6;

    pub fn clear_tv_info(&mut self) {
        self.tv_info.clear();
    }

    pub fn has_tv_info(&self) -> bool {
        self.tv_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_info(&mut self, v: ServerHltvInfo) {
        self.tv_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tv_info(&mut self) -> &mut ServerHltvInfo {
        if self.tv_info.is_none() {
            self.tv_info.set_default();
        }
        self.tv_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_tv_info(&mut self) -> ServerHltvInfo {
        self.tv_info.take().unwrap_or_else(|| ServerHltvInfo::new())
    }

    pub fn get_tv_info(&self) -> &ServerHltvInfo {
        self.tv_info.as_ref().unwrap_or_else(|| ServerHltvInfo::default_instance())
    }

    fn get_tv_info_for_reflect(&self) -> &::protobuf::SingularPtrField<ServerHltvInfo> {
        &self.tv_info
    }

    fn mut_tv_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ServerHltvInfo> {
        &mut self.tv_info
    }

    // repeated uint32 reward_player_accounts = 7;

    pub fn clear_reward_player_accounts(&mut self) {
        self.reward_player_accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_reward_player_accounts(&mut self, v: ::std::vec::Vec<u32>) {
        self.reward_player_accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reward_player_accounts(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.reward_player_accounts
    }

    // Take field
    pub fn take_reward_player_accounts(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.reward_player_accounts, ::std::vec::Vec::new())
    }

    pub fn get_reward_player_accounts(&self) -> &[u32] {
        &self.reward_player_accounts
    }

    fn get_reward_player_accounts_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.reward_player_accounts
    }

    fn mut_reward_player_accounts_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.reward_player_accounts
    }

    // repeated uint32 idle_player_accounts = 8;

    pub fn clear_idle_player_accounts(&mut self) {
        self.idle_player_accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_idle_player_accounts(&mut self, v: ::std::vec::Vec<u32>) {
        self.idle_player_accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_idle_player_accounts(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.idle_player_accounts
    }

    // Take field
    pub fn take_idle_player_accounts(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.idle_player_accounts, ::std::vec::Vec::new())
    }

    pub fn get_idle_player_accounts(&self) -> &[u32] {
        &self.idle_player_accounts
    }

    fn get_idle_player_accounts_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.idle_player_accounts
    }

    fn mut_idle_player_accounts_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.idle_player_accounts
    }

    // optional uint32 reward_item_attr_def_idx = 9;

    pub fn clear_reward_item_attr_def_idx(&mut self) {
        self.reward_item_attr_def_idx = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_def_idx(&self) -> bool {
        self.reward_item_attr_def_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_def_idx(&mut self, v: u32) {
        self.reward_item_attr_def_idx = ::std::option::Option::Some(v);
    }

    pub fn get_reward_item_attr_def_idx(&self) -> u32 {
        self.reward_item_attr_def_idx.unwrap_or(0)
    }

    fn get_reward_item_attr_def_idx_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reward_item_attr_def_idx
    }

    fn mut_reward_item_attr_def_idx_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reward_item_attr_def_idx
    }

    // optional uint32 reward_item_attr_value = 10;

    pub fn clear_reward_item_attr_value(&mut self) {
        self.reward_item_attr_value = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_value(&self) -> bool {
        self.reward_item_attr_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_value(&mut self, v: u32) {
        self.reward_item_attr_value = ::std::option::Option::Some(v);
    }

    pub fn get_reward_item_attr_value(&self) -> u32 {
        self.reward_item_attr_value.unwrap_or(0)
    }

    fn get_reward_item_attr_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reward_item_attr_value
    }

    fn mut_reward_item_attr_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reward_item_attr_value
    }

    // optional uint32 reward_item_attr_reward_idx = 11;

    pub fn clear_reward_item_attr_reward_idx(&mut self) {
        self.reward_item_attr_reward_idx = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_reward_idx(&self) -> bool {
        self.reward_item_attr_reward_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_reward_idx(&mut self, v: u32) {
        self.reward_item_attr_reward_idx = ::std::option::Option::Some(v);
    }

    pub fn get_reward_item_attr_reward_idx(&self) -> u32 {
        self.reward_item_attr_reward_idx.unwrap_or(0)
    }

    fn get_reward_item_attr_reward_idx_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reward_item_attr_reward_idx
    }

    fn mut_reward_item_attr_reward_idx_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reward_item_attr_reward_idx
    }

    // optional uint32 reward_drop_list = 12;

    pub fn clear_reward_drop_list(&mut self) {
        self.reward_drop_list = ::std::option::Option::None;
    }

    pub fn has_reward_drop_list(&self) -> bool {
        self.reward_drop_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_drop_list(&mut self, v: u32) {
        self.reward_drop_list = ::std::option::Option::Some(v);
    }

    pub fn get_reward_drop_list(&self) -> u32 {
        self.reward_drop_list.unwrap_or(0)
    }

    fn get_reward_drop_list_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reward_drop_list
    }

    fn mut_reward_drop_list_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reward_drop_list
    }

    // optional string tournament_tag = 13;

    pub fn clear_tournament_tag(&mut self) {
        self.tournament_tag.clear();
    }

    pub fn has_tournament_tag(&self) -> bool {
        self.tournament_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_tag(&mut self, v: ::std::string::String) {
        self.tournament_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_tag(&mut self) -> &mut ::std::string::String {
        if self.tournament_tag.is_none() {
            self.tournament_tag.set_default();
        }
        self.tournament_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournament_tag(&mut self) -> ::std::string::String {
        self.tournament_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_tournament_tag(&self) -> &str {
        match self.tournament_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_tournament_tag_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.tournament_tag
    }

    fn mut_tournament_tag_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.tournament_tag
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.reservation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tv_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reservationid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gc_reservation_sent = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tv_info)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.reward_player_accounts)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.idle_player_accounts)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_item_attr_def_idx = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_item_attr_value = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_item_attr_reward_idx = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_drop_list = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tournament_tag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.gc_reservation_sent {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tv_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.reward_player_accounts {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.idle_player_accounts {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.reward_item_attr_def_idx {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reward_item_attr_value {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reward_item_attr_reward_idx {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reward_drop_list {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tournament_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reservationid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.map.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.gc_reservation_sent {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.tv_info.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.reward_player_accounts {
            os.write_uint32(7, *v)?;
        };
        for v in &self.idle_player_accounts {
            os.write_uint32(8, *v)?;
        };
        if let Some(v) = self.reward_item_attr_def_idx {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.reward_item_attr_value {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.reward_item_attr_reward_idx {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.reward_drop_list {
            os.write_uint32(12, v)?;
        }
        if let Some(ref v) = self.tournament_tag.as_ref() {
            os.write_string(13, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "reservationid",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_reservationid_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_reservationid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>>(
                    "reservation",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_reservation_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_reservation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "map",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_map_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_map_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gc_reservation_sent",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_gc_reservation_sent_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_gc_reservation_sent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_version",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_server_version_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_server_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerHltvInfo>>(
                    "tv_info",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_tv_info_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_tv_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_player_accounts",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_reward_player_accounts_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_reward_player_accounts_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "idle_player_accounts",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_idle_player_accounts_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_idle_player_accounts_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_item_attr_def_idx",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_reward_item_attr_def_idx_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_reward_item_attr_def_idx_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_item_attr_value",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_reward_item_attr_value_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_reward_item_attr_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_item_attr_reward_idx",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_reward_item_attr_reward_idx_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_reward_item_attr_reward_idx_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_drop_list",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_reward_drop_list_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_reward_drop_list_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tournament_tag",
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::get_tournament_tag_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::mut_tournament_tag_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>(
                    "CMsgGCCStrike15_v2_MatchmakingServerReservationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn clear(&mut self) {
        self.clear_reservationid();
        self.clear_reservation();
        self.clear_map();
        self.clear_gc_reservation_sent();
        self.clear_server_version();
        self.clear_tv_info();
        self.clear_reward_player_accounts();
        self.clear_idle_player_accounts();
        self.clear_reward_item_attr_def_idx();
        self.clear_reward_item_attr_value();
        self.clear_reward_item_attr_reward_idx();
        self.clear_reward_drop_list();
        self.clear_tournament_tag();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    // message fields
    serverid: ::std::option::Option<u64>,
    reservationid: ::std::option::Option<u64>,
    reservation: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    map: ::protobuf::SingularField<::std::string::String>,
    server_address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new)
        }
    }

    // optional uint64 serverid = 1;

    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    pub fn get_serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }

    fn get_serverid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.serverid
    }

    fn mut_serverid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.serverid
    }

    // optional uint64 reservationid = 4;

    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    pub fn get_reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }

    fn get_reservationid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.reservationid
    }

    fn mut_reservationid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.reservationid
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve reservation = 5;

    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        if self.reservation.is_none() {
            self.reservation.set_default();
        }
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new())
    }

    pub fn get_reservation(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::default_instance())
    }

    fn get_reservation_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve> {
        &self.reservation
    }

    fn mut_reservation_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve> {
        &mut self.reservation
    }

    // optional string map = 6;

    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map.set_default();
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_map_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.map
    }

    fn mut_map_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.map
    }

    // optional string server_address = 7;

    pub fn clear_server_address(&mut self) {
        self.server_address.clear();
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: ::std::string::String) {
        self.server_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_address(&mut self) -> &mut ::std::string::String {
        if self.server_address.is_none() {
            self.server_address.set_default();
        }
        self.server_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_address(&mut self) -> ::std::string::String {
        self.server_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_server_address(&self) -> &str {
        match self.server_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_server_address_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.server_address
    }

    fn mut_server_address_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.server_address
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn is_initialized(&self) -> bool {
        for v in &self.reservation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.serverid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reservationid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.server_address.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.serverid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.reservationid {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.map.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.server_address.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "serverid",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::get_serverid_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::mut_serverid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "reservationid",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::get_reservationid_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::mut_reservationid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>>(
                    "reservation",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::get_reservation_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::mut_reservation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "map",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::get_map_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::mut_map_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "server_address",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::get_server_address_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::mut_server_address_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn clear(&mut self) {
        self.clear_serverid();
        self.clear_reservationid();
        self.clear_reservation();
        self.clear_map();
        self.clear_server_address();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    // message fields
    reservationid: ::std::option::Option<u64>,
    reservation: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    map: ::protobuf::SingularField<::std::string::String>,
    round: ::std::option::Option<i32>,
    kills: ::std::vec::Vec<i32>,
    assists: ::std::vec::Vec<i32>,
    deaths: ::std::vec::Vec<i32>,
    scores: ::std::vec::Vec<i32>,
    pings: ::std::vec::Vec<i32>,
    round_result: ::std::option::Option<i32>,
    match_result: ::std::option::Option<i32>,
    team_scores: ::std::vec::Vec<i32>,
    confirm: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>,
    reservation_stage: ::std::option::Option<i32>,
    match_duration: ::std::option::Option<i32>,
    enemy_kills: ::std::vec::Vec<i32>,
    enemy_headshots: ::std::vec::Vec<i32>,
    enemy_3ks: ::std::vec::Vec<i32>,
    enemy_4ks: ::std::vec::Vec<i32>,
    enemy_5ks: ::std::vec::Vec<i32>,
    mvps: ::std::vec::Vec<i32>,
    spectators_count: ::std::option::Option<u32>,
    spectators_count_tv: ::std::option::Option<u32>,
    spectators_count_lnk: ::std::option::Option<u32>,
    enemy_kills_agg: ::std::vec::Vec<i32>,
    drop_info: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {}

impl CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingServerRoundStats,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingServerRoundStats::new)
        }
    }

    // optional uint64 reservationid = 1;

    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    pub fn get_reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }

    fn get_reservationid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.reservationid
    }

    fn mut_reservationid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.reservationid
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve reservation = 2;

    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        if self.reservation.is_none() {
            self.reservation.set_default();
        }
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new())
    }

    pub fn get_reservation(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::default_instance())
    }

    fn get_reservation_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve> {
        &self.reservation
    }

    fn mut_reservation_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve> {
        &mut self.reservation
    }

    // optional string map = 3;

    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map.set_default();
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_map_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.map
    }

    fn mut_map_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.map
    }

    // optional int32 round = 4;

    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i32) {
        self.round = ::std::option::Option::Some(v);
    }

    pub fn get_round(&self) -> i32 {
        self.round.unwrap_or(0)
    }

    fn get_round_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.round
    }

    fn mut_round_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.round
    }

    // repeated int32 kills = 5;

    pub fn clear_kills(&mut self) {
        self.kills.clear();
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: ::std::vec::Vec<i32>) {
        self.kills = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kills(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.kills
    }

    // Take field
    pub fn take_kills(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.kills, ::std::vec::Vec::new())
    }

    pub fn get_kills(&self) -> &[i32] {
        &self.kills
    }

    fn get_kills_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.kills
    }

    // repeated int32 assists = 6;

    pub fn clear_assists(&mut self) {
        self.assists.clear();
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: ::std::vec::Vec<i32>) {
        self.assists = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assists(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.assists
    }

    // Take field
    pub fn take_assists(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.assists, ::std::vec::Vec::new())
    }

    pub fn get_assists(&self) -> &[i32] {
        &self.assists
    }

    fn get_assists_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.assists
    }

    fn mut_assists_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.assists
    }

    // repeated int32 deaths = 7;

    pub fn clear_deaths(&mut self) {
        self.deaths.clear();
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: ::std::vec::Vec<i32>) {
        self.deaths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deaths(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.deaths
    }

    // Take field
    pub fn take_deaths(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.deaths, ::std::vec::Vec::new())
    }

    pub fn get_deaths(&self) -> &[i32] {
        &self.deaths
    }

    fn get_deaths_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.deaths
    }

    fn mut_deaths_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.deaths
    }

    // repeated int32 scores = 8;

    pub fn clear_scores(&mut self) {
        self.scores.clear();
    }

    // Param is passed by value, moved
    pub fn set_scores(&mut self, v: ::std::vec::Vec<i32>) {
        self.scores = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scores(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.scores
    }

    // Take field
    pub fn take_scores(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.scores, ::std::vec::Vec::new())
    }

    pub fn get_scores(&self) -> &[i32] {
        &self.scores
    }

    fn get_scores_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.scores
    }

    fn mut_scores_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.scores
    }

    // repeated int32 pings = 9;

    pub fn clear_pings(&mut self) {
        self.pings.clear();
    }

    // Param is passed by value, moved
    pub fn set_pings(&mut self, v: ::std::vec::Vec<i32>) {
        self.pings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pings(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.pings
    }

    // Take field
    pub fn take_pings(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.pings, ::std::vec::Vec::new())
    }

    pub fn get_pings(&self) -> &[i32] {
        &self.pings
    }

    fn get_pings_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.pings
    }

    fn mut_pings_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.pings
    }

    // optional int32 round_result = 10;

    pub fn clear_round_result(&mut self) {
        self.round_result = ::std::option::Option::None;
    }

    pub fn has_round_result(&self) -> bool {
        self.round_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_result(&mut self, v: i32) {
        self.round_result = ::std::option::Option::Some(v);
    }

    pub fn get_round_result(&self) -> i32 {
        self.round_result.unwrap_or(0)
    }

    fn get_round_result_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.round_result
    }

    fn mut_round_result_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.round_result
    }

    // optional int32 match_result = 11;

    pub fn clear_match_result(&mut self) {
        self.match_result = ::std::option::Option::None;
    }

    pub fn has_match_result(&self) -> bool {
        self.match_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_result(&mut self, v: i32) {
        self.match_result = ::std::option::Option::Some(v);
    }

    pub fn get_match_result(&self) -> i32 {
        self.match_result.unwrap_or(0)
    }

    fn get_match_result_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.match_result
    }

    fn mut_match_result_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.match_result
    }

    // repeated int32 team_scores = 12;

    pub fn clear_team_scores(&mut self) {
        self.team_scores.clear();
    }

    // Param is passed by value, moved
    pub fn set_team_scores(&mut self, v: ::std::vec::Vec<i32>) {
        self.team_scores = v;
    }

    // Mutable pointer to the field.
    pub fn mut_team_scores(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.team_scores
    }

    // Take field
    pub fn take_team_scores(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.team_scores, ::std::vec::Vec::new())
    }

    pub fn get_team_scores(&self) -> &[i32] {
        &self.team_scores
    }

    fn get_team_scores_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.team_scores
    }

    fn mut_team_scores_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.team_scores
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm confirm = 13;

    pub fn clear_confirm(&mut self) {
        self.confirm.clear();
    }

    pub fn has_confirm(&self) -> bool {
        self.confirm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confirm(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm) {
        self.confirm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_confirm(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        if self.confirm.is_none() {
            self.confirm.set_default();
        }
        self.confirm.as_mut().unwrap()
    }

    // Take field
    pub fn take_confirm(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        self.confirm.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::new())
    }

    pub fn get_confirm(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        self.confirm.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::default_instance())
    }

    fn get_confirm_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm> {
        &self.confirm
    }

    fn mut_confirm_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm> {
        &mut self.confirm
    }

    // optional int32 reservation_stage = 14;

    pub fn clear_reservation_stage(&mut self) {
        self.reservation_stage = ::std::option::Option::None;
    }

    pub fn has_reservation_stage(&self) -> bool {
        self.reservation_stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_stage(&mut self, v: i32) {
        self.reservation_stage = ::std::option::Option::Some(v);
    }

    pub fn get_reservation_stage(&self) -> i32 {
        self.reservation_stage.unwrap_or(0)
    }

    fn get_reservation_stage_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.reservation_stage
    }

    fn mut_reservation_stage_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.reservation_stage
    }

    // optional int32 match_duration = 15;

    pub fn clear_match_duration(&mut self) {
        self.match_duration = ::std::option::Option::None;
    }

    pub fn has_match_duration(&self) -> bool {
        self.match_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_duration(&mut self, v: i32) {
        self.match_duration = ::std::option::Option::Some(v);
    }

    pub fn get_match_duration(&self) -> i32 {
        self.match_duration.unwrap_or(0)
    }

    fn get_match_duration_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.match_duration
    }

    fn mut_match_duration_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.match_duration
    }

    // repeated int32 enemy_kills = 16;

    pub fn clear_enemy_kills(&mut self) {
        self.enemy_kills.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_kills(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_kills = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_kills(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_kills
    }

    // Take field
    pub fn take_enemy_kills(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_kills, ::std::vec::Vec::new())
    }

    pub fn get_enemy_kills(&self) -> &[i32] {
        &self.enemy_kills
    }

    fn get_enemy_kills_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.enemy_kills
    }

    fn mut_enemy_kills_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_kills
    }

    // repeated int32 enemy_headshots = 17;

    pub fn clear_enemy_headshots(&mut self) {
        self.enemy_headshots.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_headshots(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_headshots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_headshots(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_headshots
    }

    // Take field
    pub fn take_enemy_headshots(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_headshots, ::std::vec::Vec::new())
    }

    pub fn get_enemy_headshots(&self) -> &[i32] {
        &self.enemy_headshots
    }

    fn get_enemy_headshots_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.enemy_headshots
    }

    fn mut_enemy_headshots_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_headshots
    }

    // repeated int32 enemy_3ks = 18;

    pub fn clear_enemy_3ks(&mut self) {
        self.enemy_3ks.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_3ks(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_3ks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_3ks(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_3ks
    }

    // Take field
    pub fn take_enemy_3ks(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_3ks, ::std::vec::Vec::new())
    }

    pub fn get_enemy_3ks(&self) -> &[i32] {
        &self.enemy_3ks
    }

    fn get_enemy_3ks_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.enemy_3ks
    }

    fn mut_enemy_3ks_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_3ks
    }

    // repeated int32 enemy_4ks = 19;

    pub fn clear_enemy_4ks(&mut self) {
        self.enemy_4ks.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_4ks(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_4ks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_4ks(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_4ks
    }

    // Take field
    pub fn take_enemy_4ks(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_4ks, ::std::vec::Vec::new())
    }

    pub fn get_enemy_4ks(&self) -> &[i32] {
        &self.enemy_4ks
    }

    fn get_enemy_4ks_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.enemy_4ks
    }

    fn mut_enemy_4ks_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_4ks
    }

    // repeated int32 enemy_5ks = 20;

    pub fn clear_enemy_5ks(&mut self) {
        self.enemy_5ks.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_5ks(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_5ks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_5ks(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_5ks
    }

    // Take field
    pub fn take_enemy_5ks(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_5ks, ::std::vec::Vec::new())
    }

    pub fn get_enemy_5ks(&self) -> &[i32] {
        &self.enemy_5ks
    }

    fn get_enemy_5ks_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.enemy_5ks
    }

    fn mut_enemy_5ks_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_5ks
    }

    // repeated int32 mvps = 21;

    pub fn clear_mvps(&mut self) {
        self.mvps.clear();
    }

    // Param is passed by value, moved
    pub fn set_mvps(&mut self, v: ::std::vec::Vec<i32>) {
        self.mvps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mvps(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.mvps
    }

    // Take field
    pub fn take_mvps(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.mvps, ::std::vec::Vec::new())
    }

    pub fn get_mvps(&self) -> &[i32] {
        &self.mvps
    }

    fn get_mvps_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.mvps
    }

    fn mut_mvps_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.mvps
    }

    // optional uint32 spectators_count = 22;

    pub fn clear_spectators_count(&mut self) {
        self.spectators_count = ::std::option::Option::None;
    }

    pub fn has_spectators_count(&self) -> bool {
        self.spectators_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count(&mut self, v: u32) {
        self.spectators_count = ::std::option::Option::Some(v);
    }

    pub fn get_spectators_count(&self) -> u32 {
        self.spectators_count.unwrap_or(0)
    }

    fn get_spectators_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.spectators_count
    }

    fn mut_spectators_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.spectators_count
    }

    // optional uint32 spectators_count_tv = 23;

    pub fn clear_spectators_count_tv(&mut self) {
        self.spectators_count_tv = ::std::option::Option::None;
    }

    pub fn has_spectators_count_tv(&self) -> bool {
        self.spectators_count_tv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count_tv(&mut self, v: u32) {
        self.spectators_count_tv = ::std::option::Option::Some(v);
    }

    pub fn get_spectators_count_tv(&self) -> u32 {
        self.spectators_count_tv.unwrap_or(0)
    }

    fn get_spectators_count_tv_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.spectators_count_tv
    }

    fn mut_spectators_count_tv_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.spectators_count_tv
    }

    // optional uint32 spectators_count_lnk = 24;

    pub fn clear_spectators_count_lnk(&mut self) {
        self.spectators_count_lnk = ::std::option::Option::None;
    }

    pub fn has_spectators_count_lnk(&self) -> bool {
        self.spectators_count_lnk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count_lnk(&mut self, v: u32) {
        self.spectators_count_lnk = ::std::option::Option::Some(v);
    }

    pub fn get_spectators_count_lnk(&self) -> u32 {
        self.spectators_count_lnk.unwrap_or(0)
    }

    fn get_spectators_count_lnk_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.spectators_count_lnk
    }

    fn mut_spectators_count_lnk_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.spectators_count_lnk
    }

    // repeated int32 enemy_kills_agg = 25;

    pub fn clear_enemy_kills_agg(&mut self) {
        self.enemy_kills_agg.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_kills_agg(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_kills_agg = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_kills_agg(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_kills_agg
    }

    // Take field
    pub fn take_enemy_kills_agg(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_kills_agg, ::std::vec::Vec::new())
    }

    pub fn get_enemy_kills_agg(&self) -> &[i32] {
        &self.enemy_kills_agg
    }

    fn get_enemy_kills_agg_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.enemy_kills_agg
    }

    fn mut_enemy_kills_agg_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_kills_agg
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo drop_info = 26;

    pub fn clear_drop_info(&mut self) {
        self.drop_info.clear();
    }

    pub fn has_drop_info(&self) -> bool {
        self.drop_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drop_info(&mut self, v: CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo) {
        self.drop_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_drop_info(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        if self.drop_info.is_none() {
            self.drop_info.set_default();
        }
        self.drop_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_drop_info(&mut self) -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        self.drop_info.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo::new())
    }

    pub fn get_drop_info(&self) -> &CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        self.drop_info.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo::default_instance())
    }

    fn get_drop_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo> {
        &self.drop_info
    }

    fn mut_drop_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo> {
        &mut self.drop_info
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn is_initialized(&self) -> bool {
        for v in &self.reservation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.confirm {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.drop_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reservationid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.round = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.kills)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.assists)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.deaths)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.scores)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.pings)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.round_result = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.match_result = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.team_scores)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.confirm)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reservation_stage = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.match_duration = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_kills)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_headshots)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_3ks)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_4ks)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_5ks)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.mvps)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spectators_count = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spectators_count_tv = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spectators_count_lnk = ::std::option::Option::Some(tmp);
                },
                25 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_kills_agg)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.drop_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.round {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.kills {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.assists {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.deaths {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.scores {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.pings {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.round_result {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_result {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.team_scores {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.confirm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reservation_stage {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_duration {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.enemy_kills {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.enemy_headshots {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.enemy_3ks {
            my_size += ::protobuf::rt::value_size(18, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.enemy_4ks {
            my_size += ::protobuf::rt::value_size(19, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.enemy_5ks {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.mvps {
            my_size += ::protobuf::rt::value_size(21, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.spectators_count {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spectators_count_tv {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spectators_count_lnk {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.enemy_kills_agg {
            my_size += ::protobuf::rt::value_size(25, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.drop_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reservationid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.map.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.round {
            os.write_int32(4, v)?;
        }
        for v in &self.kills {
            os.write_int32(5, *v)?;
        };
        for v in &self.assists {
            os.write_int32(6, *v)?;
        };
        for v in &self.deaths {
            os.write_int32(7, *v)?;
        };
        for v in &self.scores {
            os.write_int32(8, *v)?;
        };
        for v in &self.pings {
            os.write_int32(9, *v)?;
        };
        if let Some(v) = self.round_result {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.match_result {
            os.write_int32(11, v)?;
        }
        for v in &self.team_scores {
            os.write_int32(12, *v)?;
        };
        if let Some(ref v) = self.confirm.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.reservation_stage {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.match_duration {
            os.write_int32(15, v)?;
        }
        for v in &self.enemy_kills {
            os.write_int32(16, *v)?;
        };
        for v in &self.enemy_headshots {
            os.write_int32(17, *v)?;
        };
        for v in &self.enemy_3ks {
            os.write_int32(18, *v)?;
        };
        for v in &self.enemy_4ks {
            os.write_int32(19, *v)?;
        };
        for v in &self.enemy_5ks {
            os.write_int32(20, *v)?;
        };
        for v in &self.mvps {
            os.write_int32(21, *v)?;
        };
        if let Some(v) = self.spectators_count {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.spectators_count_tv {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.spectators_count_lnk {
            os.write_uint32(24, v)?;
        }
        for v in &self.enemy_kills_agg {
            os.write_int32(25, *v)?;
        };
        if let Some(ref v) = self.drop_info.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        CMsgGCCStrike15_v2_MatchmakingServerRoundStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "reservationid",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_reservationid_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_reservationid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>>(
                    "reservation",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_reservation_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_reservation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "map",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_map_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_map_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "round",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_round_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_round_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "kills",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_kills_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "assists",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_assists_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_assists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "deaths",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_deaths_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "scores",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_scores_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_scores_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pings",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_pings_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_pings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "round_result",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_round_result_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_round_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "match_result",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_match_result_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_match_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_scores",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_team_scores_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_team_scores_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>>(
                    "confirm",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_confirm_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_confirm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "reservation_stage",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_reservation_stage_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_reservation_stage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "match_duration",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_match_duration_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_match_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_kills",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_enemy_kills_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_enemy_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_headshots",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_enemy_headshots_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_enemy_headshots_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_3ks",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_enemy_3ks_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_enemy_3ks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_4ks",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_enemy_4ks_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_enemy_4ks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_5ks",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_enemy_5ks_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_enemy_5ks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mvps",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_mvps_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_mvps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "spectators_count",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_spectators_count_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_spectators_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "spectators_count_tv",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_spectators_count_tv_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_spectators_count_tv_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "spectators_count_lnk",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_spectators_count_lnk_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_spectators_count_lnk_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_kills_agg",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_enemy_kills_agg_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_enemy_kills_agg_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo>>(
                    "drop_info",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::get_drop_info_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats::mut_drop_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>(
                    "CMsgGCCStrike15_v2_MatchmakingServerRoundStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn clear(&mut self) {
        self.clear_reservationid();
        self.clear_reservation();
        self.clear_map();
        self.clear_round();
        self.clear_kills();
        self.clear_assists();
        self.clear_deaths();
        self.clear_scores();
        self.clear_pings();
        self.clear_round_result();
        self.clear_match_result();
        self.clear_team_scores();
        self.clear_confirm();
        self.clear_reservation_stage();
        self.clear_match_duration();
        self.clear_enemy_kills();
        self.clear_enemy_headshots();
        self.clear_enemy_3ks();
        self.clear_enemy_4ks();
        self.clear_enemy_5ks();
        self.clear_mvps();
        self.clear_spectators_count();
        self.clear_spectators_count_tv();
        self.clear_spectators_count_lnk();
        self.clear_enemy_kills_agg();
        self.clear_drop_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    // message fields
    account_mvp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {}

impl CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo::new)
        }
    }

    // optional uint32 account_mvp = 1;

    pub fn clear_account_mvp(&mut self) {
        self.account_mvp = ::std::option::Option::None;
    }

    pub fn has_account_mvp(&self) -> bool {
        self.account_mvp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_mvp(&mut self, v: u32) {
        self.account_mvp = ::std::option::Option::Some(v);
    }

    pub fn get_account_mvp(&self) -> u32 {
        self.account_mvp.unwrap_or(0)
    }

    fn get_account_mvp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_mvp
    }

    fn mut_account_mvp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_mvp
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_mvp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_mvp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_mvp {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_mvp",
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo::get_account_mvp_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo::mut_account_mvp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo>(
                    "CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    fn clear(&mut self) {
        self.clear_account_mvp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    // message fields
    stats: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>,
    confirm: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>,
    rematch: ::std::option::Option<u64>,
    replay_token: ::std::option::Option<u32>,
    replay_cluster_id: ::std::option::Option<u32>,
    aborted_match: ::std::option::Option<bool>,
    match_end_quest_data: ::protobuf::SingularPtrField<CMsgGC_ServerQuestUpdateData>,
    server_version: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {}

impl CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingServerMatchEnd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingServerMatchEnd,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::new)
        }
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingServerRoundStats stats = 1;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CMsgGCCStrike15_v2_MatchmakingServerRoundStats) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        self.stats.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats::new())
    }

    pub fn get_stats(&self) -> &CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        self.stats.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats::default_instance())
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> {
        &mut self.stats
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm confirm = 3;

    pub fn clear_confirm(&mut self) {
        self.confirm.clear();
    }

    pub fn has_confirm(&self) -> bool {
        self.confirm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confirm(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm) {
        self.confirm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_confirm(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        if self.confirm.is_none() {
            self.confirm.set_default();
        }
        self.confirm.as_mut().unwrap()
    }

    // Take field
    pub fn take_confirm(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        self.confirm.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::new())
    }

    pub fn get_confirm(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        self.confirm.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::default_instance())
    }

    fn get_confirm_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm> {
        &self.confirm
    }

    fn mut_confirm_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm> {
        &mut self.confirm
    }

    // optional uint64 rematch = 4;

    pub fn clear_rematch(&mut self) {
        self.rematch = ::std::option::Option::None;
    }

    pub fn has_rematch(&self) -> bool {
        self.rematch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rematch(&mut self, v: u64) {
        self.rematch = ::std::option::Option::Some(v);
    }

    pub fn get_rematch(&self) -> u64 {
        self.rematch.unwrap_or(0)
    }

    fn get_rematch_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.rematch
    }

    fn mut_rematch_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.rematch
    }

    // optional uint32 replay_token = 5;

    pub fn clear_replay_token(&mut self) {
        self.replay_token = ::std::option::Option::None;
    }

    pub fn has_replay_token(&self) -> bool {
        self.replay_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_token(&mut self, v: u32) {
        self.replay_token = ::std::option::Option::Some(v);
    }

    pub fn get_replay_token(&self) -> u32 {
        self.replay_token.unwrap_or(0)
    }

    fn get_replay_token_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.replay_token
    }

    fn mut_replay_token_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.replay_token
    }

    // optional uint32 replay_cluster_id = 6;

    pub fn clear_replay_cluster_id(&mut self) {
        self.replay_cluster_id = ::std::option::Option::None;
    }

    pub fn has_replay_cluster_id(&self) -> bool {
        self.replay_cluster_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_cluster_id(&mut self, v: u32) {
        self.replay_cluster_id = ::std::option::Option::Some(v);
    }

    pub fn get_replay_cluster_id(&self) -> u32 {
        self.replay_cluster_id.unwrap_or(0)
    }

    fn get_replay_cluster_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.replay_cluster_id
    }

    fn mut_replay_cluster_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.replay_cluster_id
    }

    // optional bool aborted_match = 7;

    pub fn clear_aborted_match(&mut self) {
        self.aborted_match = ::std::option::Option::None;
    }

    pub fn has_aborted_match(&self) -> bool {
        self.aborted_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aborted_match(&mut self, v: bool) {
        self.aborted_match = ::std::option::Option::Some(v);
    }

    pub fn get_aborted_match(&self) -> bool {
        self.aborted_match.unwrap_or(false)
    }

    fn get_aborted_match_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.aborted_match
    }

    fn mut_aborted_match_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.aborted_match
    }

    // optional .CMsgGC_ServerQuestUpdateData match_end_quest_data = 8;

    pub fn clear_match_end_quest_data(&mut self) {
        self.match_end_quest_data.clear();
    }

    pub fn has_match_end_quest_data(&self) -> bool {
        self.match_end_quest_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_end_quest_data(&mut self, v: CMsgGC_ServerQuestUpdateData) {
        self.match_end_quest_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_end_quest_data(&mut self) -> &mut CMsgGC_ServerQuestUpdateData {
        if self.match_end_quest_data.is_none() {
            self.match_end_quest_data.set_default();
        }
        self.match_end_quest_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_match_end_quest_data(&mut self) -> CMsgGC_ServerQuestUpdateData {
        self.match_end_quest_data.take().unwrap_or_else(|| CMsgGC_ServerQuestUpdateData::new())
    }

    pub fn get_match_end_quest_data(&self) -> &CMsgGC_ServerQuestUpdateData {
        self.match_end_quest_data.as_ref().unwrap_or_else(|| CMsgGC_ServerQuestUpdateData::default_instance())
    }

    fn get_match_end_quest_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGC_ServerQuestUpdateData> {
        &self.match_end_quest_data
    }

    fn mut_match_end_quest_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGC_ServerQuestUpdateData> {
        &mut self.match_end_quest_data
    }

    // optional uint32 server_version = 9;

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    fn get_server_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_version
    }

    fn mut_server_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_version
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.confirm {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.match_end_quest_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.confirm)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rematch = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replay_token = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replay_cluster_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.aborted_match = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.match_end_quest_data)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.confirm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.rematch {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.replay_token {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.replay_cluster_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.aborted_match {
            my_size += 2;
        }
        if let Some(ref v) = self.match_end_quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.confirm.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.rematch {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.replay_token {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.replay_cluster_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.aborted_match {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.match_end_quest_data.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
        CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingServerMatchEnd>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>>(
                    "stats",
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::get_stats_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::mut_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>>(
                    "confirm",
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::get_confirm_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::mut_confirm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rematch",
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::get_rematch_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::mut_rematch_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replay_token",
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::get_replay_token_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::mut_replay_token_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replay_cluster_id",
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::get_replay_cluster_id_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::mut_replay_cluster_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "aborted_match",
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::get_aborted_match_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::mut_aborted_match_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGC_ServerQuestUpdateData>>(
                    "match_end_quest_data",
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::get_match_end_quest_data_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::mut_match_end_quest_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_version",
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::get_server_version_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::mut_server_version_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingServerMatchEnd>(
                    "CMsgGCCStrike15_v2_MatchmakingServerMatchEnd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn clear(&mut self) {
        self.clear_stats();
        self.clear_confirm();
        self.clear_rematch();
        self.clear_replay_token();
        self.clear_replay_cluster_id();
        self.clear_aborted_match();
        self.clear_match_end_quest_data();
        self.clear_server_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {}

impl CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingClient2GCHello> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingClient2GCHello,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingClient2GCHello::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        CMsgGCCStrike15_v2_MatchmakingClient2GCHello::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingClient2GCHello>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingClient2GCHello>(
                    "CMsgGCCStrike15_v2_MatchmakingClient2GCHello",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    // message fields
    account_id: ::std::option::Option<u32>,
    ongoingmatch: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    global_stats: ::protobuf::SingularPtrField<GlobalStatistics>,
    penalty_seconds: ::std::option::Option<u32>,
    penalty_reason: ::std::option::Option<u32>,
    vac_banned: ::std::option::Option<i32>,
    ranking: ::protobuf::SingularPtrField<PlayerRankingInfo>,
    commendation: ::protobuf::SingularPtrField<PlayerCommendationInfo>,
    medals: ::protobuf::SingularPtrField<PlayerMedalsInfo>,
    my_current_event: ::protobuf::SingularPtrField<TournamentEvent>,
    my_current_event_teams: ::protobuf::RepeatedField<TournamentTeam>,
    my_current_team: ::protobuf::SingularPtrField<TournamentTeam>,
    my_current_event_stages: ::protobuf::RepeatedField<TournamentEvent>,
    survey_vote: ::std::option::Option<u32>,
    activity: ::protobuf::SingularPtrField<AccountActivity>,
    player_level: ::std::option::Option<i32>,
    player_cur_xp: ::std::option::Option<i32>,
    player_xp_bonus_flags: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ClientHello,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve ongoingmatch = 2;

    pub fn clear_ongoingmatch(&mut self) {
        self.ongoingmatch.clear();
    }

    pub fn has_ongoingmatch(&self) -> bool {
        self.ongoingmatch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ongoingmatch(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve) {
        self.ongoingmatch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ongoingmatch(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        if self.ongoingmatch.is_none() {
            self.ongoingmatch.set_default();
        }
        self.ongoingmatch.as_mut().unwrap()
    }

    // Take field
    pub fn take_ongoingmatch(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.ongoingmatch.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new())
    }

    pub fn get_ongoingmatch(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.ongoingmatch.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::default_instance())
    }

    fn get_ongoingmatch_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve> {
        &self.ongoingmatch
    }

    fn mut_ongoingmatch_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve> {
        &mut self.ongoingmatch
    }

    // optional .GlobalStatistics global_stats = 3;

    pub fn clear_global_stats(&mut self) {
        self.global_stats.clear();
    }

    pub fn has_global_stats(&self) -> bool {
        self.global_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_stats(&mut self, v: GlobalStatistics) {
        self.global_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global_stats(&mut self) -> &mut GlobalStatistics {
        if self.global_stats.is_none() {
            self.global_stats.set_default();
        }
        self.global_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_global_stats(&mut self) -> GlobalStatistics {
        self.global_stats.take().unwrap_or_else(|| GlobalStatistics::new())
    }

    pub fn get_global_stats(&self) -> &GlobalStatistics {
        self.global_stats.as_ref().unwrap_or_else(|| GlobalStatistics::default_instance())
    }

    fn get_global_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<GlobalStatistics> {
        &self.global_stats
    }

    fn mut_global_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<GlobalStatistics> {
        &mut self.global_stats
    }

    // optional uint32 penalty_seconds = 4;

    pub fn clear_penalty_seconds(&mut self) {
        self.penalty_seconds = ::std::option::Option::None;
    }

    pub fn has_penalty_seconds(&self) -> bool {
        self.penalty_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_seconds(&mut self, v: u32) {
        self.penalty_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_penalty_seconds(&self) -> u32 {
        self.penalty_seconds.unwrap_or(0)
    }

    fn get_penalty_seconds_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.penalty_seconds
    }

    fn mut_penalty_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.penalty_seconds
    }

    // optional uint32 penalty_reason = 5;

    pub fn clear_penalty_reason(&mut self) {
        self.penalty_reason = ::std::option::Option::None;
    }

    pub fn has_penalty_reason(&self) -> bool {
        self.penalty_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_reason(&mut self, v: u32) {
        self.penalty_reason = ::std::option::Option::Some(v);
    }

    pub fn get_penalty_reason(&self) -> u32 {
        self.penalty_reason.unwrap_or(0)
    }

    fn get_penalty_reason_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.penalty_reason
    }

    fn mut_penalty_reason_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.penalty_reason
    }

    // optional int32 vac_banned = 6;

    pub fn clear_vac_banned(&mut self) {
        self.vac_banned = ::std::option::Option::None;
    }

    pub fn has_vac_banned(&self) -> bool {
        self.vac_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vac_banned(&mut self, v: i32) {
        self.vac_banned = ::std::option::Option::Some(v);
    }

    pub fn get_vac_banned(&self) -> i32 {
        self.vac_banned.unwrap_or(0)
    }

    fn get_vac_banned_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.vac_banned
    }

    fn mut_vac_banned_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.vac_banned
    }

    // optional .PlayerRankingInfo ranking = 7;

    pub fn clear_ranking(&mut self) {
        self.ranking.clear();
    }

    pub fn has_ranking(&self) -> bool {
        self.ranking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranking(&mut self, v: PlayerRankingInfo) {
        self.ranking = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ranking(&mut self) -> &mut PlayerRankingInfo {
        if self.ranking.is_none() {
            self.ranking.set_default();
        }
        self.ranking.as_mut().unwrap()
    }

    // Take field
    pub fn take_ranking(&mut self) -> PlayerRankingInfo {
        self.ranking.take().unwrap_or_else(|| PlayerRankingInfo::new())
    }

    pub fn get_ranking(&self) -> &PlayerRankingInfo {
        self.ranking.as_ref().unwrap_or_else(|| PlayerRankingInfo::default_instance())
    }

    fn get_ranking_for_reflect(&self) -> &::protobuf::SingularPtrField<PlayerRankingInfo> {
        &self.ranking
    }

    fn mut_ranking_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PlayerRankingInfo> {
        &mut self.ranking
    }

    // optional .PlayerCommendationInfo commendation = 8;

    pub fn clear_commendation(&mut self) {
        self.commendation.clear();
    }

    pub fn has_commendation(&self) -> bool {
        self.commendation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commendation(&mut self, v: PlayerCommendationInfo) {
        self.commendation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commendation(&mut self) -> &mut PlayerCommendationInfo {
        if self.commendation.is_none() {
            self.commendation.set_default();
        }
        self.commendation.as_mut().unwrap()
    }

    // Take field
    pub fn take_commendation(&mut self) -> PlayerCommendationInfo {
        self.commendation.take().unwrap_or_else(|| PlayerCommendationInfo::new())
    }

    pub fn get_commendation(&self) -> &PlayerCommendationInfo {
        self.commendation.as_ref().unwrap_or_else(|| PlayerCommendationInfo::default_instance())
    }

    fn get_commendation_for_reflect(&self) -> &::protobuf::SingularPtrField<PlayerCommendationInfo> {
        &self.commendation
    }

    fn mut_commendation_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PlayerCommendationInfo> {
        &mut self.commendation
    }

    // optional .PlayerMedalsInfo medals = 9;

    pub fn clear_medals(&mut self) {
        self.medals.clear();
    }

    pub fn has_medals(&self) -> bool {
        self.medals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medals(&mut self, v: PlayerMedalsInfo) {
        self.medals = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_medals(&mut self) -> &mut PlayerMedalsInfo {
        if self.medals.is_none() {
            self.medals.set_default();
        }
        self.medals.as_mut().unwrap()
    }

    // Take field
    pub fn take_medals(&mut self) -> PlayerMedalsInfo {
        self.medals.take().unwrap_or_else(|| PlayerMedalsInfo::new())
    }

    pub fn get_medals(&self) -> &PlayerMedalsInfo {
        self.medals.as_ref().unwrap_or_else(|| PlayerMedalsInfo::default_instance())
    }

    fn get_medals_for_reflect(&self) -> &::protobuf::SingularPtrField<PlayerMedalsInfo> {
        &self.medals
    }

    fn mut_medals_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PlayerMedalsInfo> {
        &mut self.medals
    }

    // optional .TournamentEvent my_current_event = 10;

    pub fn clear_my_current_event(&mut self) {
        self.my_current_event.clear();
    }

    pub fn has_my_current_event(&self) -> bool {
        self.my_current_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_current_event(&mut self, v: TournamentEvent) {
        self.my_current_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_my_current_event(&mut self) -> &mut TournamentEvent {
        if self.my_current_event.is_none() {
            self.my_current_event.set_default();
        }
        self.my_current_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_my_current_event(&mut self) -> TournamentEvent {
        self.my_current_event.take().unwrap_or_else(|| TournamentEvent::new())
    }

    pub fn get_my_current_event(&self) -> &TournamentEvent {
        self.my_current_event.as_ref().unwrap_or_else(|| TournamentEvent::default_instance())
    }

    fn get_my_current_event_for_reflect(&self) -> &::protobuf::SingularPtrField<TournamentEvent> {
        &self.my_current_event
    }

    fn mut_my_current_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TournamentEvent> {
        &mut self.my_current_event
    }

    // repeated .TournamentTeam my_current_event_teams = 11;

    pub fn clear_my_current_event_teams(&mut self) {
        self.my_current_event_teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_my_current_event_teams(&mut self, v: ::protobuf::RepeatedField<TournamentTeam>) {
        self.my_current_event_teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_my_current_event_teams(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.my_current_event_teams
    }

    // Take field
    pub fn take_my_current_event_teams(&mut self) -> ::protobuf::RepeatedField<TournamentTeam> {
        ::std::mem::replace(&mut self.my_current_event_teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_my_current_event_teams(&self) -> &[TournamentTeam] {
        &self.my_current_event_teams
    }

    fn get_my_current_event_teams_for_reflect(&self) -> &::protobuf::RepeatedField<TournamentTeam> {
        &self.my_current_event_teams
    }

    fn mut_my_current_event_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.my_current_event_teams
    }

    // optional .TournamentTeam my_current_team = 12;

    pub fn clear_my_current_team(&mut self) {
        self.my_current_team.clear();
    }

    pub fn has_my_current_team(&self) -> bool {
        self.my_current_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_current_team(&mut self, v: TournamentTeam) {
        self.my_current_team = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_my_current_team(&mut self) -> &mut TournamentTeam {
        if self.my_current_team.is_none() {
            self.my_current_team.set_default();
        }
        self.my_current_team.as_mut().unwrap()
    }

    // Take field
    pub fn take_my_current_team(&mut self) -> TournamentTeam {
        self.my_current_team.take().unwrap_or_else(|| TournamentTeam::new())
    }

    pub fn get_my_current_team(&self) -> &TournamentTeam {
        self.my_current_team.as_ref().unwrap_or_else(|| TournamentTeam::default_instance())
    }

    fn get_my_current_team_for_reflect(&self) -> &::protobuf::SingularPtrField<TournamentTeam> {
        &self.my_current_team
    }

    fn mut_my_current_team_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TournamentTeam> {
        &mut self.my_current_team
    }

    // repeated .TournamentEvent my_current_event_stages = 13;

    pub fn clear_my_current_event_stages(&mut self) {
        self.my_current_event_stages.clear();
    }

    // Param is passed by value, moved
    pub fn set_my_current_event_stages(&mut self, v: ::protobuf::RepeatedField<TournamentEvent>) {
        self.my_current_event_stages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_my_current_event_stages(&mut self) -> &mut ::protobuf::RepeatedField<TournamentEvent> {
        &mut self.my_current_event_stages
    }

    // Take field
    pub fn take_my_current_event_stages(&mut self) -> ::protobuf::RepeatedField<TournamentEvent> {
        ::std::mem::replace(&mut self.my_current_event_stages, ::protobuf::RepeatedField::new())
    }

    pub fn get_my_current_event_stages(&self) -> &[TournamentEvent] {
        &self.my_current_event_stages
    }

    fn get_my_current_event_stages_for_reflect(&self) -> &::protobuf::RepeatedField<TournamentEvent> {
        &self.my_current_event_stages
    }

    fn mut_my_current_event_stages_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<TournamentEvent> {
        &mut self.my_current_event_stages
    }

    // optional uint32 survey_vote = 14;

    pub fn clear_survey_vote(&mut self) {
        self.survey_vote = ::std::option::Option::None;
    }

    pub fn has_survey_vote(&self) -> bool {
        self.survey_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_vote(&mut self, v: u32) {
        self.survey_vote = ::std::option::Option::Some(v);
    }

    pub fn get_survey_vote(&self) -> u32 {
        self.survey_vote.unwrap_or(0)
    }

    fn get_survey_vote_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.survey_vote
    }

    fn mut_survey_vote_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.survey_vote
    }

    // optional .AccountActivity activity = 15;

    pub fn clear_activity(&mut self) {
        self.activity.clear();
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: AccountActivity) {
        self.activity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activity(&mut self) -> &mut AccountActivity {
        if self.activity.is_none() {
            self.activity.set_default();
        }
        self.activity.as_mut().unwrap()
    }

    // Take field
    pub fn take_activity(&mut self) -> AccountActivity {
        self.activity.take().unwrap_or_else(|| AccountActivity::new())
    }

    pub fn get_activity(&self) -> &AccountActivity {
        self.activity.as_ref().unwrap_or_else(|| AccountActivity::default_instance())
    }

    fn get_activity_for_reflect(&self) -> &::protobuf::SingularPtrField<AccountActivity> {
        &self.activity
    }

    fn mut_activity_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AccountActivity> {
        &mut self.activity
    }

    // optional int32 player_level = 17;

    pub fn clear_player_level(&mut self) {
        self.player_level = ::std::option::Option::None;
    }

    pub fn has_player_level(&self) -> bool {
        self.player_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_level(&mut self, v: i32) {
        self.player_level = ::std::option::Option::Some(v);
    }

    pub fn get_player_level(&self) -> i32 {
        self.player_level.unwrap_or(0)
    }

    fn get_player_level_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_level
    }

    fn mut_player_level_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_level
    }

    // optional int32 player_cur_xp = 18;

    pub fn clear_player_cur_xp(&mut self) {
        self.player_cur_xp = ::std::option::Option::None;
    }

    pub fn has_player_cur_xp(&self) -> bool {
        self.player_cur_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_cur_xp(&mut self, v: i32) {
        self.player_cur_xp = ::std::option::Option::Some(v);
    }

    pub fn get_player_cur_xp(&self) -> i32 {
        self.player_cur_xp.unwrap_or(0)
    }

    fn get_player_cur_xp_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_cur_xp
    }

    fn mut_player_cur_xp_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_cur_xp
    }

    // optional int32 player_xp_bonus_flags = 19;

    pub fn clear_player_xp_bonus_flags(&mut self) {
        self.player_xp_bonus_flags = ::std::option::Option::None;
    }

    pub fn has_player_xp_bonus_flags(&self) -> bool {
        self.player_xp_bonus_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_xp_bonus_flags(&mut self, v: i32) {
        self.player_xp_bonus_flags = ::std::option::Option::Some(v);
    }

    pub fn get_player_xp_bonus_flags(&self) -> i32 {
        self.player_xp_bonus_flags.unwrap_or(0)
    }

    fn get_player_xp_bonus_flags_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_xp_bonus_flags
    }

    fn mut_player_xp_bonus_flags_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_xp_bonus_flags
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn is_initialized(&self) -> bool {
        for v in &self.ongoingmatch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.global_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ranking {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commendation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.medals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.my_current_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.my_current_event_teams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.my_current_team {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.my_current_event_stages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ongoingmatch)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.global_stats)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty_seconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty_reason = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vac_banned = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ranking)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commendation)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.medals)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.my_current_event)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.my_current_event_teams)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.my_current_team)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.my_current_event_stages)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.survey_vote = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.activity)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_level = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_cur_xp = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_xp_bonus_flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ongoingmatch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.global_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.penalty_seconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.penalty_reason {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vac_banned {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ranking.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.medals.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.my_current_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.my_current_event_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.my_current_team.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.my_current_event_stages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.survey_vote {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.activity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.player_level {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_cur_xp {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_xp_bonus_flags {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.ongoingmatch.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.global_stats.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.penalty_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.penalty_reason {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.vac_banned {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.ranking.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commendation.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.medals.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.my_current_event.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.my_current_event_teams {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.my_current_team.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.my_current_event_stages {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.survey_vote {
            os.write_uint32(14, v)?;
        }
        if let Some(ref v) = self.activity.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.player_level {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.player_cur_xp {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.player_xp_bonus_flags {
            os.write_int32(19, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_account_id_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>>(
                    "ongoingmatch",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_ongoingmatch_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_ongoingmatch_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlobalStatistics>>(
                    "global_stats",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_global_stats_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_global_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_seconds",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_penalty_seconds_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_penalty_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_reason",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_penalty_reason_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_penalty_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "vac_banned",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_vac_banned_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_vac_banned_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerRankingInfo>>(
                    "ranking",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_ranking_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_ranking_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerCommendationInfo>>(
                    "commendation",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_commendation_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_commendation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerMedalsInfo>>(
                    "medals",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_medals_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_medals_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentEvent>>(
                    "my_current_event",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_my_current_event_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_my_current_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentTeam>>(
                    "my_current_event_teams",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_my_current_event_teams_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_my_current_event_teams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentTeam>>(
                    "my_current_team",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_my_current_team_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_my_current_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentEvent>>(
                    "my_current_event_stages",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_my_current_event_stages_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_my_current_event_stages_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "survey_vote",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_survey_vote_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_survey_vote_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountActivity>>(
                    "activity",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_activity_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_activity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_level",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_player_level_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_player_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_cur_xp",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_player_cur_xp_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_player_cur_xp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_xp_bonus_flags",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::get_player_xp_bonus_flags_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::mut_player_xp_bonus_flags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ClientHello",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_ongoingmatch();
        self.clear_global_stats();
        self.clear_penalty_seconds();
        self.clear_penalty_reason();
        self.clear_vac_banned();
        self.clear_ranking();
        self.clear_commendation();
        self.clear_medals();
        self.clear_my_current_event();
        self.clear_my_current_event_teams();
        self.clear_my_current_team();
        self.clear_my_current_event_stages();
        self.clear_survey_vote();
        self.clear_activity();
        self.clear_player_level();
        self.clear_player_cur_xp();
        self.clear_player_xp_bonus_flags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_AccountPrivacySettings {
    // message fields
    settings: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_AccountPrivacySettings {}

impl CMsgGCCStrike15_v2_AccountPrivacySettings {
    pub fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_AccountPrivacySettings {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_AccountPrivacySettings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_AccountPrivacySettings,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_AccountPrivacySettings::new)
        }
    }

    // repeated .CMsgGCCStrike15_v2_AccountPrivacySettings.Setting settings = 1;

    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting>) {
        self.settings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_settings(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting> {
        &mut self.settings
    }

    // Take field
    pub fn take_settings(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting> {
        ::std::mem::replace(&mut self.settings, ::protobuf::RepeatedField::new())
    }

    pub fn get_settings(&self) -> &[CMsgGCCStrike15_v2_AccountPrivacySettings_Setting] {
        &self.settings
    }

    fn get_settings_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting> {
        &self.settings
    }

    fn mut_settings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting> {
        &mut self.settings
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn is_initialized(&self) -> bool {
        for v in &self.settings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.settings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.settings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings {
        CMsgGCCStrike15_v2_AccountPrivacySettings::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_AccountPrivacySettings>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting>>(
                    "settings",
                    CMsgGCCStrike15_v2_AccountPrivacySettings::get_settings_for_reflect,
                    CMsgGCCStrike15_v2_AccountPrivacySettings::mut_settings_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_AccountPrivacySettings>(
                    "CMsgGCCStrike15_v2_AccountPrivacySettings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn clear(&mut self) {
        self.clear_settings();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    // message fields
    setting_type: ::std::option::Option<u32>,
    setting_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {}

impl CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    pub fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_AccountPrivacySettings_Setting,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_AccountPrivacySettings_Setting::new)
        }
    }

    // optional uint32 setting_type = 1;

    pub fn clear_setting_type(&mut self) {
        self.setting_type = ::std::option::Option::None;
    }

    pub fn has_setting_type(&self) -> bool {
        self.setting_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_setting_type(&mut self, v: u32) {
        self.setting_type = ::std::option::Option::Some(v);
    }

    pub fn get_setting_type(&self) -> u32 {
        self.setting_type.unwrap_or(0)
    }

    fn get_setting_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.setting_type
    }

    fn mut_setting_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.setting_type
    }

    // optional uint32 setting_value = 2;

    pub fn clear_setting_value(&mut self) {
        self.setting_value = ::std::option::Option::None;
    }

    pub fn has_setting_value(&self) -> bool {
        self.setting_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_setting_value(&mut self, v: u32) {
        self.setting_value = ::std::option::Option::Some(v);
    }

    pub fn get_setting_value(&self) -> u32 {
        self.setting_value.unwrap_or(0)
    }

    fn get_setting_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.setting_value
    }

    fn mut_setting_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.setting_value
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.setting_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.setting_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.setting_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.setting_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.setting_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.setting_value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
        CMsgGCCStrike15_v2_AccountPrivacySettings_Setting::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "setting_type",
                    CMsgGCCStrike15_v2_AccountPrivacySettings_Setting::get_setting_type_for_reflect,
                    CMsgGCCStrike15_v2_AccountPrivacySettings_Setting::mut_setting_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "setting_value",
                    CMsgGCCStrike15_v2_AccountPrivacySettings_Setting::get_setting_value_for_reflect,
                    CMsgGCCStrike15_v2_AccountPrivacySettings_Setting::mut_setting_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting>(
                    "CMsgGCCStrike15_v2_AccountPrivacySettings_Setting",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    fn clear(&mut self) {
        self.clear_setting_type();
        self.clear_setting_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    // message fields
    account_id: ::std::option::Option<u32>,
    abandoned_match: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    penalty_seconds: ::std::option::Option<u32>,
    penalty_reason: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve abandoned_match = 2;

    pub fn clear_abandoned_match(&mut self) {
        self.abandoned_match.clear();
    }

    pub fn has_abandoned_match(&self) -> bool {
        self.abandoned_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandoned_match(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve) {
        self.abandoned_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_abandoned_match(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        if self.abandoned_match.is_none() {
            self.abandoned_match.set_default();
        }
        self.abandoned_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_abandoned_match(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.abandoned_match.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new())
    }

    pub fn get_abandoned_match(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.abandoned_match.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::default_instance())
    }

    fn get_abandoned_match_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve> {
        &self.abandoned_match
    }

    fn mut_abandoned_match_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve> {
        &mut self.abandoned_match
    }

    // optional uint32 penalty_seconds = 3;

    pub fn clear_penalty_seconds(&mut self) {
        self.penalty_seconds = ::std::option::Option::None;
    }

    pub fn has_penalty_seconds(&self) -> bool {
        self.penalty_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_seconds(&mut self, v: u32) {
        self.penalty_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_penalty_seconds(&self) -> u32 {
        self.penalty_seconds.unwrap_or(0)
    }

    fn get_penalty_seconds_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.penalty_seconds
    }

    fn mut_penalty_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.penalty_seconds
    }

    // optional uint32 penalty_reason = 4;

    pub fn clear_penalty_reason(&mut self) {
        self.penalty_reason = ::std::option::Option::None;
    }

    pub fn has_penalty_reason(&self) -> bool {
        self.penalty_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_reason(&mut self, v: u32) {
        self.penalty_reason = ::std::option::Option::Some(v);
    }

    pub fn get_penalty_reason(&self) -> u32 {
        self.penalty_reason.unwrap_or(0)
    }

    fn get_penalty_reason_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.penalty_reason
    }

    fn mut_penalty_reason_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.penalty_reason
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn is_initialized(&self) -> bool {
        for v in &self.abandoned_match {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.abandoned_match)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty_seconds = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty_reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.abandoned_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.penalty_seconds {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.penalty_reason {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.abandoned_match.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.penalty_seconds {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.penalty_reason {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::get_account_id_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>>(
                    "abandoned_match",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::get_abandoned_match_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::mut_abandoned_match_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_seconds",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::get_penalty_seconds_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::mut_penalty_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_reason",
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::get_penalty_reason_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::mut_penalty_reason_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_abandoned_match();
        self.clear_penalty_seconds();
        self.clear_penalty_reason();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    // message fields
    account_id: ::std::option::Option<u32>,
    reservation: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    reason: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {}

impl CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingServer2GCKick> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingServer2GCKick,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingServer2GCKick::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve reservation = 2;

    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        if self.reservation.is_none() {
            self.reservation.set_default();
        }
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new())
    }

    pub fn get_reservation(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::default_instance())
    }

    fn get_reservation_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve> {
        &self.reservation
    }

    fn mut_reservation_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve> {
        &mut self.reservation
    }

    // optional uint32 reason = 3;

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    pub fn get_reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    fn get_reason_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reason
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn is_initialized(&self) -> bool {
        for v in &self.reservation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
        CMsgGCCStrike15_v2_MatchmakingServer2GCKick::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingServer2GCKick>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCStrike15_v2_MatchmakingServer2GCKick::get_account_id_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServer2GCKick::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>>(
                    "reservation",
                    CMsgGCCStrike15_v2_MatchmakingServer2GCKick::get_reservation_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServer2GCKick::mut_reservation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reason",
                    CMsgGCCStrike15_v2_MatchmakingServer2GCKick::get_reason_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingServer2GCKick::mut_reason_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingServer2GCKick>(
                    "CMsgGCCStrike15_v2_MatchmakingServer2GCKick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_reservation();
        self.clear_reason();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    // message fields
    rankings: ::protobuf::RepeatedField<PlayerRankingInfo>,
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {}

impl CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate::new)
        }
    }

    // repeated .PlayerRankingInfo rankings = 1;

    pub fn clear_rankings(&mut self) {
        self.rankings.clear();
    }

    // Param is passed by value, moved
    pub fn set_rankings(&mut self, v: ::protobuf::RepeatedField<PlayerRankingInfo>) {
        self.rankings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rankings(&mut self) -> &mut ::protobuf::RepeatedField<PlayerRankingInfo> {
        &mut self.rankings
    }

    // Take field
    pub fn take_rankings(&mut self) -> ::protobuf::RepeatedField<PlayerRankingInfo> {
        ::std::mem::replace(&mut self.rankings, ::protobuf::RepeatedField::new())
    }

    pub fn get_rankings(&self) -> &[PlayerRankingInfo] {
        &self.rankings
    }

    fn get_rankings_for_reflect(&self) -> &::protobuf::RepeatedField<PlayerRankingInfo> {
        &self.rankings
    }

    fn mut_rankings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PlayerRankingInfo> {
        &mut self.rankings
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.rankings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rankings)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rankings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rankings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
        CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerRankingInfo>>(
                    "rankings",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate::get_rankings_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate::mut_rankings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate::get_match_id_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn clear(&mut self) {
        self.clear_rankings();
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    // message fields
    main_post_url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {}

impl CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate::new)
        }
    }

    // optional string main_post_url = 1;

    pub fn clear_main_post_url(&mut self) {
        self.main_post_url.clear();
    }

    pub fn has_main_post_url(&self) -> bool {
        self.main_post_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_post_url(&mut self, v: ::std::string::String) {
        self.main_post_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_post_url(&mut self) -> &mut ::std::string::String {
        if self.main_post_url.is_none() {
            self.main_post_url.set_default();
        }
        self.main_post_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_post_url(&mut self) -> ::std::string::String {
        self.main_post_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_main_post_url(&self) -> &str {
        match self.main_post_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_main_post_url_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.main_post_url
    }

    fn mut_main_post_url_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.main_post_url
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.main_post_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.main_post_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.main_post_url.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn new() -> CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "main_post_url",
                    CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate::get_main_post_url_for_reflect,
                    CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate::mut_main_post_url_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate>(
                    "CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn clear(&mut self) {
        self.clear_main_post_url();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    // message fields
    account_id: ::std::option::Option<u32>,
    reason: ::std::option::Option<u32>,
    seconds: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {}

impl CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    pub fn new() -> CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ServerNotificationForUserPenalty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ServerNotificationForUserPenalty,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 reason = 2;

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    pub fn get_reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    fn get_reason_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reason
    }

    // optional uint32 seconds = 3;

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    pub fn get_seconds(&self) -> u32 {
        self.seconds.unwrap_or(0)
    }

    fn get_seconds_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.seconds
    }

    fn mut_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.seconds
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn new() -> CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ServerNotificationForUserPenalty>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::get_account_id_for_reflect,
                    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reason",
                    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::get_reason_for_reflect,
                    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::mut_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "seconds",
                    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::get_seconds_for_reflect,
                    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::mut_seconds_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ServerNotificationForUserPenalty>(
                    "CMsgGCCStrike15_v2_ServerNotificationForUserPenalty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_reason();
        self.clear_seconds();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientReportPlayer {
    // message fields
    account_id: ::std::option::Option<u32>,
    rpt_aimbot: ::std::option::Option<u32>,
    rpt_wallhack: ::std::option::Option<u32>,
    rpt_speedhack: ::std::option::Option<u32>,
    rpt_teamharm: ::std::option::Option<u32>,
    rpt_textabuse: ::std::option::Option<u32>,
    rpt_voiceabuse: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientReportPlayer {}

impl CMsgGCCStrike15_v2_ClientReportPlayer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportPlayer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportPlayer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientReportPlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientReportPlayer,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientReportPlayer::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 rpt_aimbot = 2;

    pub fn clear_rpt_aimbot(&mut self) {
        self.rpt_aimbot = ::std::option::Option::None;
    }

    pub fn has_rpt_aimbot(&self) -> bool {
        self.rpt_aimbot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_aimbot(&mut self, v: u32) {
        self.rpt_aimbot = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_aimbot(&self) -> u32 {
        self.rpt_aimbot.unwrap_or(0)
    }

    fn get_rpt_aimbot_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_aimbot
    }

    fn mut_rpt_aimbot_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_aimbot
    }

    // optional uint32 rpt_wallhack = 3;

    pub fn clear_rpt_wallhack(&mut self) {
        self.rpt_wallhack = ::std::option::Option::None;
    }

    pub fn has_rpt_wallhack(&self) -> bool {
        self.rpt_wallhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_wallhack(&mut self, v: u32) {
        self.rpt_wallhack = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_wallhack(&self) -> u32 {
        self.rpt_wallhack.unwrap_or(0)
    }

    fn get_rpt_wallhack_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_wallhack
    }

    fn mut_rpt_wallhack_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_wallhack
    }

    // optional uint32 rpt_speedhack = 4;

    pub fn clear_rpt_speedhack(&mut self) {
        self.rpt_speedhack = ::std::option::Option::None;
    }

    pub fn has_rpt_speedhack(&self) -> bool {
        self.rpt_speedhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_speedhack(&mut self, v: u32) {
        self.rpt_speedhack = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_speedhack(&self) -> u32 {
        self.rpt_speedhack.unwrap_or(0)
    }

    fn get_rpt_speedhack_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_speedhack
    }

    fn mut_rpt_speedhack_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_speedhack
    }

    // optional uint32 rpt_teamharm = 5;

    pub fn clear_rpt_teamharm(&mut self) {
        self.rpt_teamharm = ::std::option::Option::None;
    }

    pub fn has_rpt_teamharm(&self) -> bool {
        self.rpt_teamharm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_teamharm(&mut self, v: u32) {
        self.rpt_teamharm = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_teamharm(&self) -> u32 {
        self.rpt_teamharm.unwrap_or(0)
    }

    fn get_rpt_teamharm_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_teamharm
    }

    fn mut_rpt_teamharm_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_teamharm
    }

    // optional uint32 rpt_textabuse = 6;

    pub fn clear_rpt_textabuse(&mut self) {
        self.rpt_textabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_textabuse(&self) -> bool {
        self.rpt_textabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_textabuse(&mut self, v: u32) {
        self.rpt_textabuse = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_textabuse(&self) -> u32 {
        self.rpt_textabuse.unwrap_or(0)
    }

    fn get_rpt_textabuse_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_textabuse
    }

    fn mut_rpt_textabuse_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_textabuse
    }

    // optional uint32 rpt_voiceabuse = 7;

    pub fn clear_rpt_voiceabuse(&mut self) {
        self.rpt_voiceabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_voiceabuse(&self) -> bool {
        self.rpt_voiceabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_voiceabuse(&mut self, v: u32) {
        self.rpt_voiceabuse = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_voiceabuse(&self) -> u32 {
        self.rpt_voiceabuse.unwrap_or(0)
    }

    fn get_rpt_voiceabuse_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_voiceabuse
    }

    fn mut_rpt_voiceabuse_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_voiceabuse
    }

    // optional uint64 match_id = 8;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_aimbot = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_wallhack = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_speedhack = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_teamharm = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_textabuse = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_voiceabuse = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_aimbot {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_wallhack {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_speedhack {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_teamharm {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_textabuse {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_voiceabuse {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rpt_aimbot {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rpt_wallhack {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rpt_speedhack {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_teamharm {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rpt_textabuse {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rpt_voiceabuse {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn new() -> CMsgGCCStrike15_v2_ClientReportPlayer {
        CMsgGCCStrike15_v2_ClientReportPlayer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientReportPlayer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCStrike15_v2_ClientReportPlayer::get_account_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportPlayer::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_aimbot",
                    CMsgGCCStrike15_v2_ClientReportPlayer::get_rpt_aimbot_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportPlayer::mut_rpt_aimbot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_wallhack",
                    CMsgGCCStrike15_v2_ClientReportPlayer::get_rpt_wallhack_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportPlayer::mut_rpt_wallhack_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_speedhack",
                    CMsgGCCStrike15_v2_ClientReportPlayer::get_rpt_speedhack_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportPlayer::mut_rpt_speedhack_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_teamharm",
                    CMsgGCCStrike15_v2_ClientReportPlayer::get_rpt_teamharm_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportPlayer::mut_rpt_teamharm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_textabuse",
                    CMsgGCCStrike15_v2_ClientReportPlayer::get_rpt_textabuse_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportPlayer::mut_rpt_textabuse_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_voiceabuse",
                    CMsgGCCStrike15_v2_ClientReportPlayer::get_rpt_voiceabuse_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportPlayer::mut_rpt_voiceabuse_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCCStrike15_v2_ClientReportPlayer::get_match_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportPlayer::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientReportPlayer>(
                    "CMsgGCCStrike15_v2_ClientReportPlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_rpt_aimbot();
        self.clear_rpt_wallhack();
        self.clear_rpt_speedhack();
        self.clear_rpt_teamharm();
        self.clear_rpt_textabuse();
        self.clear_rpt_voiceabuse();
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientCommendPlayer {
    // message fields
    account_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    commendation: ::protobuf::SingularPtrField<PlayerCommendationInfo>,
    tokens: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientCommendPlayer {}

impl CMsgGCCStrike15_v2_ClientCommendPlayer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientCommendPlayer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientCommendPlayer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientCommendPlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientCommendPlayer,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientCommendPlayer::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 match_id = 8;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional .PlayerCommendationInfo commendation = 9;

    pub fn clear_commendation(&mut self) {
        self.commendation.clear();
    }

    pub fn has_commendation(&self) -> bool {
        self.commendation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commendation(&mut self, v: PlayerCommendationInfo) {
        self.commendation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commendation(&mut self) -> &mut PlayerCommendationInfo {
        if self.commendation.is_none() {
            self.commendation.set_default();
        }
        self.commendation.as_mut().unwrap()
    }

    // Take field
    pub fn take_commendation(&mut self) -> PlayerCommendationInfo {
        self.commendation.take().unwrap_or_else(|| PlayerCommendationInfo::new())
    }

    pub fn get_commendation(&self) -> &PlayerCommendationInfo {
        self.commendation.as_ref().unwrap_or_else(|| PlayerCommendationInfo::default_instance())
    }

    fn get_commendation_for_reflect(&self) -> &::protobuf::SingularPtrField<PlayerCommendationInfo> {
        &self.commendation
    }

    fn mut_commendation_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PlayerCommendationInfo> {
        &mut self.commendation
    }

    // optional uint32 tokens = 10;

    pub fn clear_tokens(&mut self) {
        self.tokens = ::std::option::Option::None;
    }

    pub fn has_tokens(&self) -> bool {
        self.tokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: u32) {
        self.tokens = ::std::option::Option::Some(v);
    }

    pub fn get_tokens(&self) -> u32 {
        self.tokens.unwrap_or(0)
    }

    fn get_tokens_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tokens
    }

    fn mut_tokens_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tokens
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn is_initialized(&self) -> bool {
        for v in &self.commendation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commendation)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tokens = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tokens {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        if let Some(ref v) = self.commendation.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.tokens {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn new() -> CMsgGCCStrike15_v2_ClientCommendPlayer {
        CMsgGCCStrike15_v2_ClientCommendPlayer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientCommendPlayer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCStrike15_v2_ClientCommendPlayer::get_account_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientCommendPlayer::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCCStrike15_v2_ClientCommendPlayer::get_match_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientCommendPlayer::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerCommendationInfo>>(
                    "commendation",
                    CMsgGCCStrike15_v2_ClientCommendPlayer::get_commendation_for_reflect,
                    CMsgGCCStrike15_v2_ClientCommendPlayer::mut_commendation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tokens",
                    CMsgGCCStrike15_v2_ClientCommendPlayer::get_tokens_for_reflect,
                    CMsgGCCStrike15_v2_ClientCommendPlayer::mut_tokens_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientCommendPlayer>(
                    "CMsgGCCStrike15_v2_ClientCommendPlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_match_id();
        self.clear_commendation();
        self.clear_tokens();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientReportServer {
    // message fields
    rpt_poorperf: ::std::option::Option<u32>,
    rpt_abusivemodels: ::std::option::Option<u32>,
    rpt_badmotd: ::std::option::Option<u32>,
    rpt_listingabuse: ::std::option::Option<u32>,
    rpt_inventoryabuse: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientReportServer {}

impl CMsgGCCStrike15_v2_ClientReportServer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportServer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportServer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientReportServer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientReportServer,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientReportServer::new)
        }
    }

    // optional uint32 rpt_poorperf = 1;

    pub fn clear_rpt_poorperf(&mut self) {
        self.rpt_poorperf = ::std::option::Option::None;
    }

    pub fn has_rpt_poorperf(&self) -> bool {
        self.rpt_poorperf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_poorperf(&mut self, v: u32) {
        self.rpt_poorperf = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_poorperf(&self) -> u32 {
        self.rpt_poorperf.unwrap_or(0)
    }

    fn get_rpt_poorperf_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_poorperf
    }

    fn mut_rpt_poorperf_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_poorperf
    }

    // optional uint32 rpt_abusivemodels = 2;

    pub fn clear_rpt_abusivemodels(&mut self) {
        self.rpt_abusivemodels = ::std::option::Option::None;
    }

    pub fn has_rpt_abusivemodels(&self) -> bool {
        self.rpt_abusivemodels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_abusivemodels(&mut self, v: u32) {
        self.rpt_abusivemodels = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_abusivemodels(&self) -> u32 {
        self.rpt_abusivemodels.unwrap_or(0)
    }

    fn get_rpt_abusivemodels_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_abusivemodels
    }

    fn mut_rpt_abusivemodels_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_abusivemodels
    }

    // optional uint32 rpt_badmotd = 3;

    pub fn clear_rpt_badmotd(&mut self) {
        self.rpt_badmotd = ::std::option::Option::None;
    }

    pub fn has_rpt_badmotd(&self) -> bool {
        self.rpt_badmotd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_badmotd(&mut self, v: u32) {
        self.rpt_badmotd = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_badmotd(&self) -> u32 {
        self.rpt_badmotd.unwrap_or(0)
    }

    fn get_rpt_badmotd_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_badmotd
    }

    fn mut_rpt_badmotd_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_badmotd
    }

    // optional uint32 rpt_listingabuse = 4;

    pub fn clear_rpt_listingabuse(&mut self) {
        self.rpt_listingabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_listingabuse(&self) -> bool {
        self.rpt_listingabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_listingabuse(&mut self, v: u32) {
        self.rpt_listingabuse = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_listingabuse(&self) -> u32 {
        self.rpt_listingabuse.unwrap_or(0)
    }

    fn get_rpt_listingabuse_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_listingabuse
    }

    fn mut_rpt_listingabuse_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_listingabuse
    }

    // optional uint32 rpt_inventoryabuse = 5;

    pub fn clear_rpt_inventoryabuse(&mut self) {
        self.rpt_inventoryabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_inventoryabuse(&self) -> bool {
        self.rpt_inventoryabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_inventoryabuse(&mut self, v: u32) {
        self.rpt_inventoryabuse = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_inventoryabuse(&self) -> u32 {
        self.rpt_inventoryabuse.unwrap_or(0)
    }

    fn get_rpt_inventoryabuse_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_inventoryabuse
    }

    fn mut_rpt_inventoryabuse_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_inventoryabuse
    }

    // optional uint64 match_id = 8;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_poorperf = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_abusivemodels = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_badmotd = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_listingabuse = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_inventoryabuse = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.rpt_poorperf {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_abusivemodels {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_badmotd {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_listingabuse {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_inventoryabuse {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.rpt_poorperf {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rpt_abusivemodels {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rpt_badmotd {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rpt_listingabuse {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_inventoryabuse {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientReportServer {
    fn new() -> CMsgGCCStrike15_v2_ClientReportServer {
        CMsgGCCStrike15_v2_ClientReportServer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientReportServer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_poorperf",
                    CMsgGCCStrike15_v2_ClientReportServer::get_rpt_poorperf_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportServer::mut_rpt_poorperf_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_abusivemodels",
                    CMsgGCCStrike15_v2_ClientReportServer::get_rpt_abusivemodels_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportServer::mut_rpt_abusivemodels_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_badmotd",
                    CMsgGCCStrike15_v2_ClientReportServer::get_rpt_badmotd_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportServer::mut_rpt_badmotd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_listingabuse",
                    CMsgGCCStrike15_v2_ClientReportServer::get_rpt_listingabuse_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportServer::mut_rpt_listingabuse_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_inventoryabuse",
                    CMsgGCCStrike15_v2_ClientReportServer::get_rpt_inventoryabuse_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportServer::mut_rpt_inventoryabuse_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCCStrike15_v2_ClientReportServer::get_match_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportServer::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientReportServer>(
                    "CMsgGCCStrike15_v2_ClientReportServer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientReportServer {
    fn clear(&mut self) {
        self.clear_rpt_poorperf();
        self.clear_rpt_abusivemodels();
        self.clear_rpt_badmotd();
        self.clear_rpt_listingabuse();
        self.clear_rpt_inventoryabuse();
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientReportServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportServer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientReportResponse {
    // message fields
    confirmation_id: ::std::option::Option<u64>,
    account_id: ::std::option::Option<u32>,
    server_ip: ::std::option::Option<u32>,
    response_type: ::std::option::Option<u32>,
    response_result: ::std::option::Option<u32>,
    tokens: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientReportResponse {}

impl CMsgGCCStrike15_v2_ClientReportResponse {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientReportResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientReportResponse,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientReportResponse::new)
        }
    }

    // optional uint64 confirmation_id = 1;

    pub fn clear_confirmation_id(&mut self) {
        self.confirmation_id = ::std::option::Option::None;
    }

    pub fn has_confirmation_id(&self) -> bool {
        self.confirmation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confirmation_id(&mut self, v: u64) {
        self.confirmation_id = ::std::option::Option::Some(v);
    }

    pub fn get_confirmation_id(&self) -> u64 {
        self.confirmation_id.unwrap_or(0)
    }

    fn get_confirmation_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.confirmation_id
    }

    fn mut_confirmation_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.confirmation_id
    }

    // optional uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 server_ip = 3;

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    pub fn get_server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    fn get_server_ip_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_ip
    }

    fn mut_server_ip_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_ip
    }

    // optional uint32 response_type = 4;

    pub fn clear_response_type(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_response_type(&self) -> bool {
        self.response_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_type(&mut self, v: u32) {
        self.response_type = ::std::option::Option::Some(v);
    }

    pub fn get_response_type(&self) -> u32 {
        self.response_type.unwrap_or(0)
    }

    fn get_response_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.response_type
    }

    fn mut_response_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.response_type
    }

    // optional uint32 response_result = 5;

    pub fn clear_response_result(&mut self) {
        self.response_result = ::std::option::Option::None;
    }

    pub fn has_response_result(&self) -> bool {
        self.response_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_result(&mut self, v: u32) {
        self.response_result = ::std::option::Option::Some(v);
    }

    pub fn get_response_result(&self) -> u32 {
        self.response_result.unwrap_or(0)
    }

    fn get_response_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.response_result
    }

    fn mut_response_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.response_result
    }

    // optional uint32 tokens = 6;

    pub fn clear_tokens(&mut self) {
        self.tokens = ::std::option::Option::None;
    }

    pub fn has_tokens(&self) -> bool {
        self.tokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: u32) {
        self.tokens = ::std::option::Option::Some(v);
    }

    pub fn get_tokens(&self) -> u32 {
        self.tokens.unwrap_or(0)
    }

    fn get_tokens_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tokens
    }

    fn mut_tokens_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tokens
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.confirmation_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_ip = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.response_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.response_result = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tokens = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.confirmation_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.response_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.response_result {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tokens {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.confirmation_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.response_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.response_result {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tokens {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientReportResponse {
    fn new() -> CMsgGCCStrike15_v2_ClientReportResponse {
        CMsgGCCStrike15_v2_ClientReportResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientReportResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "confirmation_id",
                    CMsgGCCStrike15_v2_ClientReportResponse::get_confirmation_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportResponse::mut_confirmation_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCStrike15_v2_ClientReportResponse::get_account_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportResponse::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_ip",
                    CMsgGCCStrike15_v2_ClientReportResponse::get_server_ip_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportResponse::mut_server_ip_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "response_type",
                    CMsgGCCStrike15_v2_ClientReportResponse::get_response_type_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportResponse::mut_response_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "response_result",
                    CMsgGCCStrike15_v2_ClientReportResponse::get_response_result_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportResponse::mut_response_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tokens",
                    CMsgGCCStrike15_v2_ClientReportResponse::get_tokens_for_reflect,
                    CMsgGCCStrike15_v2_ClientReportResponse::mut_tokens_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientReportResponse>(
                    "CMsgGCCStrike15_v2_ClientReportResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientReportResponse {
    fn clear(&mut self) {
        self.clear_confirmation_id();
        self.clear_account_id();
        self.clear_server_ip();
        self.clear_response_type();
        self.clear_response_result();
        self.clear_tokens();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    // message fields
    request_id: ::std::option::Option<u32>,
    account_ids: ::std::vec::Vec<u32>,
    serverid: ::std::option::Option<u64>,
    matchid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {}

impl CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::new)
        }
    }

    // optional uint32 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    fn get_request_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.request_id
    }

    fn mut_request_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.request_id
    }

    // repeated uint32 account_ids = 2;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // optional uint64 serverid = 3;

    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    pub fn get_serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }

    fn get_serverid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.serverid
    }

    fn mut_serverid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.serverid
    }

    // optional uint64 matchid = 4;

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    pub fn get_matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    fn get_matchid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.matchid
    }

    fn mut_matchid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.matchid
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.serverid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.matchid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.serverid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.matchid {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn new() -> CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::get_request_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::mut_request_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::get_account_ids_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::mut_account_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "serverid",
                    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::get_serverid_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::mut_serverid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "matchid",
                    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::get_matchid_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::mut_matchid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends>(
                    "CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_account_ids();
        self.clear_serverid();
        self.clear_matchid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchableMatchInfo {
    // message fields
    server_ip: ::std::option::Option<u32>,
    tv_port: ::std::option::Option<u32>,
    tv_spectators: ::std::option::Option<u32>,
    tv_time: ::std::option::Option<u32>,
    tv_watch_password: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    cl_decryptdata_key: ::std::option::Option<u64>,
    cl_decryptdata_key_pub: ::std::option::Option<u64>,
    game_type: ::std::option::Option<u32>,
    game_mapgroup: ::protobuf::SingularField<::std::string::String>,
    game_map: ::protobuf::SingularField<::std::string::String>,
    server_id: ::std::option::Option<u64>,
    match_id: ::std::option::Option<u64>,
    reservation_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for WatchableMatchInfo {}

impl WatchableMatchInfo {
    pub fn new() -> WatchableMatchInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static WatchableMatchInfo {
        static mut instance: ::protobuf::lazy::Lazy<WatchableMatchInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WatchableMatchInfo,
        };
        unsafe {
            instance.get(WatchableMatchInfo::new)
        }
    }

    // optional uint32 server_ip = 1;

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    pub fn get_server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    fn get_server_ip_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_ip
    }

    fn mut_server_ip_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_ip
    }

    // optional uint32 tv_port = 2;

    pub fn clear_tv_port(&mut self) {
        self.tv_port = ::std::option::Option::None;
    }

    pub fn has_tv_port(&self) -> bool {
        self.tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_port(&mut self, v: u32) {
        self.tv_port = ::std::option::Option::Some(v);
    }

    pub fn get_tv_port(&self) -> u32 {
        self.tv_port.unwrap_or(0)
    }

    fn get_tv_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_port
    }

    fn mut_tv_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_port
    }

    // optional uint32 tv_spectators = 3;

    pub fn clear_tv_spectators(&mut self) {
        self.tv_spectators = ::std::option::Option::None;
    }

    pub fn has_tv_spectators(&self) -> bool {
        self.tv_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_spectators(&mut self, v: u32) {
        self.tv_spectators = ::std::option::Option::Some(v);
    }

    pub fn get_tv_spectators(&self) -> u32 {
        self.tv_spectators.unwrap_or(0)
    }

    fn get_tv_spectators_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_spectators
    }

    fn mut_tv_spectators_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_spectators
    }

    // optional uint32 tv_time = 4;

    pub fn clear_tv_time(&mut self) {
        self.tv_time = ::std::option::Option::None;
    }

    pub fn has_tv_time(&self) -> bool {
        self.tv_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_time(&mut self, v: u32) {
        self.tv_time = ::std::option::Option::Some(v);
    }

    pub fn get_tv_time(&self) -> u32 {
        self.tv_time.unwrap_or(0)
    }

    fn get_tv_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tv_time
    }

    fn mut_tv_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tv_time
    }

    // optional bytes tv_watch_password = 5;

    pub fn clear_tv_watch_password(&mut self) {
        self.tv_watch_password.clear();
    }

    pub fn has_tv_watch_password(&self) -> bool {
        self.tv_watch_password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_watch_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.tv_watch_password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tv_watch_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tv_watch_password.is_none() {
            self.tv_watch_password.set_default();
        }
        self.tv_watch_password.as_mut().unwrap()
    }

    // Take field
    pub fn take_tv_watch_password(&mut self) -> ::std::vec::Vec<u8> {
        self.tv_watch_password.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_tv_watch_password(&self) -> &[u8] {
        match self.tv_watch_password.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_tv_watch_password_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.tv_watch_password
    }

    fn mut_tv_watch_password_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.tv_watch_password
    }

    // optional uint64 cl_decryptdata_key = 6;

    pub fn clear_cl_decryptdata_key(&mut self) {
        self.cl_decryptdata_key = ::std::option::Option::None;
    }

    pub fn has_cl_decryptdata_key(&self) -> bool {
        self.cl_decryptdata_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cl_decryptdata_key(&mut self, v: u64) {
        self.cl_decryptdata_key = ::std::option::Option::Some(v);
    }

    pub fn get_cl_decryptdata_key(&self) -> u64 {
        self.cl_decryptdata_key.unwrap_or(0)
    }

    fn get_cl_decryptdata_key_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.cl_decryptdata_key
    }

    fn mut_cl_decryptdata_key_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.cl_decryptdata_key
    }

    // optional uint64 cl_decryptdata_key_pub = 7;

    pub fn clear_cl_decryptdata_key_pub(&mut self) {
        self.cl_decryptdata_key_pub = ::std::option::Option::None;
    }

    pub fn has_cl_decryptdata_key_pub(&self) -> bool {
        self.cl_decryptdata_key_pub.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cl_decryptdata_key_pub(&mut self, v: u64) {
        self.cl_decryptdata_key_pub = ::std::option::Option::Some(v);
    }

    pub fn get_cl_decryptdata_key_pub(&self) -> u64 {
        self.cl_decryptdata_key_pub.unwrap_or(0)
    }

    fn get_cl_decryptdata_key_pub_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.cl_decryptdata_key_pub
    }

    fn mut_cl_decryptdata_key_pub_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.cl_decryptdata_key_pub
    }

    // optional uint32 game_type = 8;

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    fn get_game_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_type
    }

    fn mut_game_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_type
    }

    // optional string game_mapgroup = 9;

    pub fn clear_game_mapgroup(&mut self) {
        self.game_mapgroup.clear();
    }

    pub fn has_game_mapgroup(&self) -> bool {
        self.game_mapgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mapgroup(&mut self, v: ::std::string::String) {
        self.game_mapgroup = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mapgroup(&mut self) -> &mut ::std::string::String {
        if self.game_mapgroup.is_none() {
            self.game_mapgroup.set_default();
        }
        self.game_mapgroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mapgroup(&mut self) -> ::std::string::String {
        self.game_mapgroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_game_mapgroup(&self) -> &str {
        match self.game_mapgroup.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_game_mapgroup_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.game_mapgroup
    }

    fn mut_game_mapgroup_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.game_mapgroup
    }

    // optional string game_map = 10;

    pub fn clear_game_map(&mut self) {
        self.game_map.clear();
    }

    pub fn has_game_map(&self) -> bool {
        self.game_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_map(&mut self, v: ::std::string::String) {
        self.game_map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_map(&mut self) -> &mut ::std::string::String {
        if self.game_map.is_none() {
            self.game_map.set_default();
        }
        self.game_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_map(&mut self) -> ::std::string::String {
        self.game_map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_game_map(&self) -> &str {
        match self.game_map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_game_map_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.game_map
    }

    fn mut_game_map_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.game_map
    }

    // optional uint64 server_id = 11;

    pub fn clear_server_id(&mut self) {
        self.server_id = ::std::option::Option::None;
    }

    pub fn has_server_id(&self) -> bool {
        self.server_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_id(&mut self, v: u64) {
        self.server_id = ::std::option::Option::Some(v);
    }

    pub fn get_server_id(&self) -> u64 {
        self.server_id.unwrap_or(0)
    }

    fn get_server_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.server_id
    }

    fn mut_server_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.server_id
    }

    // optional uint64 match_id = 12;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint64 reservation_id = 13;

    pub fn clear_reservation_id(&mut self) {
        self.reservation_id = ::std::option::Option::None;
    }

    pub fn has_reservation_id(&self) -> bool {
        self.reservation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_id(&mut self, v: u64) {
        self.reservation_id = ::std::option::Option::Some(v);
    }

    pub fn get_reservation_id(&self) -> u64 {
        self.reservation_id.unwrap_or(0)
    }

    fn get_reservation_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.reservation_id
    }

    fn mut_reservation_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.reservation_id
    }
}

impl ::protobuf::Message for WatchableMatchInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_ip = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_spectators = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tv_watch_password)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cl_decryptdata_key = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cl_decryptdata_key_pub = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_mapgroup)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_map)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.server_id = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reservation_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_spectators {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tv_watch_password.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.cl_decryptdata_key {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cl_decryptdata_key_pub {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_mapgroup.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.game_map.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.server_id {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reservation_id {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_ip {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tv_port {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tv_spectators {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tv_time {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.tv_watch_password.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.cl_decryptdata_key {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.cl_decryptdata_key_pub {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(8, v)?;
        }
        if let Some(ref v) = self.game_mapgroup.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.game_map.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.server_id {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.reservation_id {
            os.write_uint64(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for WatchableMatchInfo {
    fn new() -> WatchableMatchInfo {
        WatchableMatchInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<WatchableMatchInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_ip",
                    WatchableMatchInfo::get_server_ip_for_reflect,
                    WatchableMatchInfo::mut_server_ip_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_port",
                    WatchableMatchInfo::get_tv_port_for_reflect,
                    WatchableMatchInfo::mut_tv_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_spectators",
                    WatchableMatchInfo::get_tv_spectators_for_reflect,
                    WatchableMatchInfo::mut_tv_spectators_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_time",
                    WatchableMatchInfo::get_tv_time_for_reflect,
                    WatchableMatchInfo::mut_tv_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "tv_watch_password",
                    WatchableMatchInfo::get_tv_watch_password_for_reflect,
                    WatchableMatchInfo::mut_tv_watch_password_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cl_decryptdata_key",
                    WatchableMatchInfo::get_cl_decryptdata_key_for_reflect,
                    WatchableMatchInfo::mut_cl_decryptdata_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cl_decryptdata_key_pub",
                    WatchableMatchInfo::get_cl_decryptdata_key_pub_for_reflect,
                    WatchableMatchInfo::mut_cl_decryptdata_key_pub_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    WatchableMatchInfo::get_game_type_for_reflect,
                    WatchableMatchInfo::mut_game_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "game_mapgroup",
                    WatchableMatchInfo::get_game_mapgroup_for_reflect,
                    WatchableMatchInfo::mut_game_mapgroup_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "game_map",
                    WatchableMatchInfo::get_game_map_for_reflect,
                    WatchableMatchInfo::mut_game_map_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "server_id",
                    WatchableMatchInfo::get_server_id_for_reflect,
                    WatchableMatchInfo::mut_server_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    WatchableMatchInfo::get_match_id_for_reflect,
                    WatchableMatchInfo::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "reservation_id",
                    WatchableMatchInfo::get_reservation_id_for_reflect,
                    WatchableMatchInfo::mut_reservation_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WatchableMatchInfo>(
                    "WatchableMatchInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for WatchableMatchInfo {
    fn clear(&mut self) {
        self.clear_server_ip();
        self.clear_tv_port();
        self.clear_tv_spectators();
        self.clear_tv_time();
        self.clear_tv_watch_password();
        self.clear_cl_decryptdata_key();
        self.clear_cl_decryptdata_key_pub();
        self.clear_game_type();
        self.clear_game_mapgroup();
        self.clear_game_map();
        self.clear_server_id();
        self.clear_match_id();
        self.clear_reservation_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchableMatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchableMatchInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    // message fields
    version: ::std::option::Option<u32>,
    account_id: ::std::option::Option<u32>,
    join_token: ::std::option::Option<u32>,
    join_ipp: ::std::option::Option<u32>,
    res: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    errormsg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {}

impl CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientRequestJoinFriendData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientRequestJoinFriendData,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientRequestJoinFriendData::new)
        }
    }

    // optional uint32 version = 1;

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    fn get_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.version
    }

    fn mut_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.version
    }

    // optional uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 join_token = 3;

    pub fn clear_join_token(&mut self) {
        self.join_token = ::std::option::Option::None;
    }

    pub fn has_join_token(&self) -> bool {
        self.join_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_token(&mut self, v: u32) {
        self.join_token = ::std::option::Option::Some(v);
    }

    pub fn get_join_token(&self) -> u32 {
        self.join_token.unwrap_or(0)
    }

    fn get_join_token_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.join_token
    }

    fn mut_join_token_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.join_token
    }

    // optional uint32 join_ipp = 4;

    pub fn clear_join_ipp(&mut self) {
        self.join_ipp = ::std::option::Option::None;
    }

    pub fn has_join_ipp(&self) -> bool {
        self.join_ipp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_ipp(&mut self, v: u32) {
        self.join_ipp = ::std::option::Option::Some(v);
    }

    pub fn get_join_ipp(&self) -> u32 {
        self.join_ipp.unwrap_or(0)
    }

    fn get_join_ipp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.join_ipp
    }

    fn mut_join_ipp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.join_ipp
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve res = 5;

    pub fn clear_res(&mut self) {
        self.res.clear();
    }

    pub fn has_res(&self) -> bool {
        self.res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_res(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve) {
        self.res = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_res(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        if self.res.is_none() {
            self.res.set_default();
        }
        self.res.as_mut().unwrap()
    }

    // Take field
    pub fn take_res(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.res.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new())
    }

    pub fn get_res(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.res.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::default_instance())
    }

    fn get_res_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve> {
        &self.res
    }

    fn mut_res_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve> {
        &mut self.res
    }

    // optional string errormsg = 6;

    pub fn clear_errormsg(&mut self) {
        self.errormsg.clear();
    }

    pub fn has_errormsg(&self) -> bool {
        self.errormsg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errormsg(&mut self, v: ::std::string::String) {
        self.errormsg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errormsg(&mut self) -> &mut ::std::string::String {
        if self.errormsg.is_none() {
            self.errormsg.set_default();
        }
        self.errormsg.as_mut().unwrap()
    }

    // Take field
    pub fn take_errormsg(&mut self) -> ::std::string::String {
        self.errormsg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_errormsg(&self) -> &str {
        match self.errormsg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_errormsg_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.errormsg
    }

    fn mut_errormsg_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.errormsg
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn is_initialized(&self) -> bool {
        for v in &self.res {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.join_token = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.join_ipp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.res)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errormsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.join_token {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.join_ipp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.res.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.errormsg.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.join_token {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.join_ipp {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.res.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.errormsg.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        CMsgGCCStrike15_v2_ClientRequestJoinFriendData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientRequestJoinFriendData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::get_version_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::mut_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::get_account_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "join_token",
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::get_join_token_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::mut_join_token_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "join_ipp",
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::get_join_ipp_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::mut_join_ipp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>>(
                    "res",
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::get_res_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::mut_res_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "errormsg",
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::get_errormsg_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinFriendData::mut_errormsg_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientRequestJoinFriendData>(
                    "CMsgGCCStrike15_v2_ClientRequestJoinFriendData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_account_id();
        self.clear_join_token();
        self.clear_join_ipp();
        self.clear_res();
        self.clear_errormsg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    // message fields
    version: ::std::option::Option<u32>,
    account_id: ::std::option::Option<u32>,
    serverid: ::std::option::Option<u64>,
    server_ip: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    res: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientRequestJoinServerData {}

impl CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientRequestJoinServerData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientRequestJoinServerData,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientRequestJoinServerData::new)
        }
    }

    // optional uint32 version = 1;

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    fn get_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.version
    }

    fn mut_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.version
    }

    // optional uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 serverid = 3;

    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    pub fn get_serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }

    fn get_serverid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.serverid
    }

    fn mut_serverid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.serverid
    }

    // optional uint32 server_ip = 4;

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    pub fn get_server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    fn get_server_ip_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_ip
    }

    fn mut_server_ip_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_ip
    }

    // optional uint32 server_port = 5;

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    fn get_server_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_port
    }

    fn mut_server_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_port
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve res = 6;

    pub fn clear_res(&mut self) {
        self.res.clear();
    }

    pub fn has_res(&self) -> bool {
        self.res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_res(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve) {
        self.res = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_res(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        if self.res.is_none() {
            self.res.set_default();
        }
        self.res.as_mut().unwrap()
    }

    // Take field
    pub fn take_res(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.res.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new())
    }

    pub fn get_res(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.res.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::default_instance())
    }

    fn get_res_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve> {
        &self.res
    }

    fn mut_res_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve> {
        &mut self.res
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn is_initialized(&self) -> bool {
        for v in &self.res {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.serverid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_ip = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.res)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.res.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.serverid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.server_ip {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.res.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        CMsgGCCStrike15_v2_ClientRequestJoinServerData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientRequestJoinServerData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::get_version_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::mut_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::get_account_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "serverid",
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::get_serverid_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::mut_serverid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_ip",
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::get_server_ip_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::mut_server_ip_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_port",
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::get_server_port_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::mut_server_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>>(
                    "res",
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::get_res_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestJoinServerData::mut_res_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientRequestJoinServerData>(
                    "CMsgGCCStrike15_v2_ClientRequestJoinServerData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_account_id();
        self.clear_serverid();
        self.clear_server_ip();
        self.clear_server_port();
        self.clear_res();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCstrike15_v2_ClientRequestNewMission {
    // message fields
    mission_id: ::std::option::Option<u32>,
    campaign_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCstrike15_v2_ClientRequestNewMission {}

impl CMsgGCCstrike15_v2_ClientRequestNewMission {
    pub fn new() -> CMsgGCCstrike15_v2_ClientRequestNewMission {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCstrike15_v2_ClientRequestNewMission {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCstrike15_v2_ClientRequestNewMission> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCstrike15_v2_ClientRequestNewMission,
        };
        unsafe {
            instance.get(CMsgGCCstrike15_v2_ClientRequestNewMission::new)
        }
    }

    // optional uint32 mission_id = 2;

    pub fn clear_mission_id(&mut self) {
        self.mission_id = ::std::option::Option::None;
    }

    pub fn has_mission_id(&self) -> bool {
        self.mission_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_id(&mut self, v: u32) {
        self.mission_id = ::std::option::Option::Some(v);
    }

    pub fn get_mission_id(&self) -> u32 {
        self.mission_id.unwrap_or(0)
    }

    fn get_mission_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mission_id
    }

    fn mut_mission_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mission_id
    }

    // optional uint32 campaign_id = 3;

    pub fn clear_campaign_id(&mut self) {
        self.campaign_id = ::std::option::Option::None;
    }

    pub fn has_campaign_id(&self) -> bool {
        self.campaign_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaign_id(&mut self, v: u32) {
        self.campaign_id = ::std::option::Option::Some(v);
    }

    pub fn get_campaign_id(&self) -> u32 {
        self.campaign_id.unwrap_or(0)
    }

    fn get_campaign_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.campaign_id
    }

    fn mut_campaign_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.campaign_id
    }
}

impl ::protobuf::Message for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mission_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.campaign_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mission_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.campaign_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mission_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.campaign_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn new() -> CMsgGCCstrike15_v2_ClientRequestNewMission {
        CMsgGCCstrike15_v2_ClientRequestNewMission::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCstrike15_v2_ClientRequestNewMission>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mission_id",
                    CMsgGCCstrike15_v2_ClientRequestNewMission::get_mission_id_for_reflect,
                    CMsgGCCstrike15_v2_ClientRequestNewMission::mut_mission_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "campaign_id",
                    CMsgGCCstrike15_v2_ClientRequestNewMission::get_campaign_id_for_reflect,
                    CMsgGCCstrike15_v2_ClientRequestNewMission::mut_campaign_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCstrike15_v2_ClientRequestNewMission>(
                    "CMsgGCCstrike15_v2_ClientRequestNewMission",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn clear(&mut self) {
        self.clear_mission_id();
        self.clear_campaign_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    // message fields
    xp_progress_data: ::protobuf::RepeatedField<XpProgressData>,
    account_id: ::std::option::Option<u32>,
    current_xp: ::std::option::Option<u32>,
    current_level: ::std::option::Option<u32>,
    upgraded_defidx: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {}

impl CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    pub fn new() -> CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded,
        };
        unsafe {
            instance.get(CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::new)
        }
    }

    // repeated .XpProgressData xp_progress_data = 1;

    pub fn clear_xp_progress_data(&mut self) {
        self.xp_progress_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_xp_progress_data(&mut self, v: ::protobuf::RepeatedField<XpProgressData>) {
        self.xp_progress_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xp_progress_data(&mut self) -> &mut ::protobuf::RepeatedField<XpProgressData> {
        &mut self.xp_progress_data
    }

    // Take field
    pub fn take_xp_progress_data(&mut self) -> ::protobuf::RepeatedField<XpProgressData> {
        ::std::mem::replace(&mut self.xp_progress_data, ::protobuf::RepeatedField::new())
    }

    pub fn get_xp_progress_data(&self) -> &[XpProgressData] {
        &self.xp_progress_data
    }

    fn get_xp_progress_data_for_reflect(&self) -> &::protobuf::RepeatedField<XpProgressData> {
        &self.xp_progress_data
    }

    fn mut_xp_progress_data_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<XpProgressData> {
        &mut self.xp_progress_data
    }

    // optional uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 current_xp = 3;

    pub fn clear_current_xp(&mut self) {
        self.current_xp = ::std::option::Option::None;
    }

    pub fn has_current_xp(&self) -> bool {
        self.current_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_xp(&mut self, v: u32) {
        self.current_xp = ::std::option::Option::Some(v);
    }

    pub fn get_current_xp(&self) -> u32 {
        self.current_xp.unwrap_or(0)
    }

    fn get_current_xp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.current_xp
    }

    fn mut_current_xp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.current_xp
    }

    // optional uint32 current_level = 4;

    pub fn clear_current_level(&mut self) {
        self.current_level = ::std::option::Option::None;
    }

    pub fn has_current_level(&self) -> bool {
        self.current_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_level(&mut self, v: u32) {
        self.current_level = ::std::option::Option::Some(v);
    }

    pub fn get_current_level(&self) -> u32 {
        self.current_level.unwrap_or(0)
    }

    fn get_current_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.current_level
    }

    fn mut_current_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.current_level
    }

    // optional uint32 upgraded_defidx = 5;

    pub fn clear_upgraded_defidx(&mut self) {
        self.upgraded_defidx = ::std::option::Option::None;
    }

    pub fn has_upgraded_defidx(&self) -> bool {
        self.upgraded_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgraded_defidx(&mut self, v: u32) {
        self.upgraded_defidx = ::std::option::Option::Some(v);
    }

    pub fn get_upgraded_defidx(&self) -> u32 {
        self.upgraded_defidx.unwrap_or(0)
    }

    fn get_upgraded_defidx_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.upgraded_defidx
    }

    fn mut_upgraded_defidx_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.upgraded_defidx
    }
}

impl ::protobuf::Message for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn is_initialized(&self) -> bool {
        for v in &self.xp_progress_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.xp_progress_data)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.current_xp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.current_level = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.upgraded_defidx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.xp_progress_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current_xp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current_level {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.upgraded_defidx {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.xp_progress_data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.current_xp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.current_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.upgraded_defidx {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn new() -> CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<XpProgressData>>(
                    "xp_progress_data",
                    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::get_xp_progress_data_for_reflect,
                    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::mut_xp_progress_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::get_account_id_for_reflect,
                    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "current_xp",
                    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::get_current_xp_for_reflect,
                    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::mut_current_xp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "current_level",
                    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::get_current_level_for_reflect,
                    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::mut_current_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "upgraded_defidx",
                    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::get_upgraded_defidx_for_reflect,
                    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::mut_upgraded_defidx_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>(
                    "CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn clear(&mut self) {
        self.clear_xp_progress_data();
        self.clear_account_id();
        self.clear_current_xp();
        self.clear_current_level();
        self.clear_upgraded_defidx();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_WatchInfoUsers {
    // message fields
    request_id: ::std::option::Option<u32>,
    account_ids: ::std::vec::Vec<u32>,
    watchable_match_infos: ::protobuf::RepeatedField<WatchableMatchInfo>,
    extended_timeout: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_WatchInfoUsers {}

impl CMsgGCCStrike15_v2_WatchInfoUsers {
    pub fn new() -> CMsgGCCStrike15_v2_WatchInfoUsers {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_WatchInfoUsers {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_WatchInfoUsers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_WatchInfoUsers,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_WatchInfoUsers::new)
        }
    }

    // optional uint32 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    fn get_request_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.request_id
    }

    fn mut_request_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.request_id
    }

    // repeated uint32 account_ids = 2;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // repeated .WatchableMatchInfo watchable_match_infos = 3;

    pub fn clear_watchable_match_infos(&mut self) {
        self.watchable_match_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_watchable_match_infos(&mut self, v: ::protobuf::RepeatedField<WatchableMatchInfo>) {
        self.watchable_match_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_watchable_match_infos(&mut self) -> &mut ::protobuf::RepeatedField<WatchableMatchInfo> {
        &mut self.watchable_match_infos
    }

    // Take field
    pub fn take_watchable_match_infos(&mut self) -> ::protobuf::RepeatedField<WatchableMatchInfo> {
        ::std::mem::replace(&mut self.watchable_match_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_watchable_match_infos(&self) -> &[WatchableMatchInfo] {
        &self.watchable_match_infos
    }

    fn get_watchable_match_infos_for_reflect(&self) -> &::protobuf::RepeatedField<WatchableMatchInfo> {
        &self.watchable_match_infos
    }

    fn mut_watchable_match_infos_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<WatchableMatchInfo> {
        &mut self.watchable_match_infos
    }

    // optional uint32 extended_timeout = 5;

    pub fn clear_extended_timeout(&mut self) {
        self.extended_timeout = ::std::option::Option::None;
    }

    pub fn has_extended_timeout(&self) -> bool {
        self.extended_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extended_timeout(&mut self, v: u32) {
        self.extended_timeout = ::std::option::Option::Some(v);
    }

    pub fn get_extended_timeout(&self) -> u32 {
        self.extended_timeout.unwrap_or(0)
    }

    fn get_extended_timeout_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.extended_timeout
    }

    fn mut_extended_timeout_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.extended_timeout
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn is_initialized(&self) -> bool {
        for v in &self.watchable_match_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.watchable_match_infos)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extended_timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.watchable_match_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.extended_timeout {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.watchable_match_infos {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.extended_timeout {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn new() -> CMsgGCCStrike15_v2_WatchInfoUsers {
        CMsgGCCStrike15_v2_WatchInfoUsers::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_WatchInfoUsers>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    CMsgGCCStrike15_v2_WatchInfoUsers::get_request_id_for_reflect,
                    CMsgGCCStrike15_v2_WatchInfoUsers::mut_request_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgGCCStrike15_v2_WatchInfoUsers::get_account_ids_for_reflect,
                    CMsgGCCStrike15_v2_WatchInfoUsers::mut_account_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WatchableMatchInfo>>(
                    "watchable_match_infos",
                    CMsgGCCStrike15_v2_WatchInfoUsers::get_watchable_match_infos_for_reflect,
                    CMsgGCCStrike15_v2_WatchInfoUsers::mut_watchable_match_infos_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "extended_timeout",
                    CMsgGCCStrike15_v2_WatchInfoUsers::get_extended_timeout_for_reflect,
                    CMsgGCCStrike15_v2_WatchInfoUsers::mut_extended_timeout_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_WatchInfoUsers>(
                    "CMsgGCCStrike15_v2_WatchInfoUsers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_account_ids();
        self.clear_watchable_match_infos();
        self.clear_extended_timeout();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    // message fields
    request_id__deprecated: ::std::option::Option<u32>,
    account_ids__deprecated: ::std::vec::Vec<u32>,
    account_id: ::std::option::Option<u32>,
    request_level: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {}

impl CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientRequestPlayersProfile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientRequestPlayersProfile,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientRequestPlayersProfile::new)
        }
    }

    // optional uint32 request_id__deprecated = 1;

    pub fn clear_request_id__deprecated(&mut self) {
        self.request_id__deprecated = ::std::option::Option::None;
    }

    pub fn has_request_id__deprecated(&self) -> bool {
        self.request_id__deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id__deprecated(&mut self, v: u32) {
        self.request_id__deprecated = ::std::option::Option::Some(v);
    }

    pub fn get_request_id__deprecated(&self) -> u32 {
        self.request_id__deprecated.unwrap_or(0)
    }

    fn get_request_id__deprecated_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.request_id__deprecated
    }

    fn mut_request_id__deprecated_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.request_id__deprecated
    }

    // repeated uint32 account_ids__deprecated = 2;

    pub fn clear_account_ids__deprecated(&mut self) {
        self.account_ids__deprecated.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids__deprecated(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids__deprecated = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids__deprecated(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids__deprecated
    }

    // Take field
    pub fn take_account_ids__deprecated(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids__deprecated, ::std::vec::Vec::new())
    }

    pub fn get_account_ids__deprecated(&self) -> &[u32] {
        &self.account_ids__deprecated
    }

    fn get_account_ids__deprecated_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids__deprecated
    }

    fn mut_account_ids__deprecated_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids__deprecated
    }

    // optional uint32 account_id = 3;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 request_level = 4;

    pub fn clear_request_level(&mut self) {
        self.request_level = ::std::option::Option::None;
    }

    pub fn has_request_level(&self) -> bool {
        self.request_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_level(&mut self, v: u32) {
        self.request_level = ::std::option::Option::Some(v);
    }

    pub fn get_request_level(&self) -> u32 {
        self.request_level.unwrap_or(0)
    }

    fn get_request_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.request_level
    }

    fn mut_request_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.request_level
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id__deprecated = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids__deprecated)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id__deprecated {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_ids__deprecated {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_level {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id__deprecated {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids__deprecated {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.request_level {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn new() -> CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        CMsgGCCStrike15_v2_ClientRequestPlayersProfile::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientRequestPlayersProfile>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id__deprecated",
                    CMsgGCCStrike15_v2_ClientRequestPlayersProfile::get_request_id__deprecated_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestPlayersProfile::mut_request_id__deprecated_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids__deprecated",
                    CMsgGCCStrike15_v2_ClientRequestPlayersProfile::get_account_ids__deprecated_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestPlayersProfile::mut_account_ids__deprecated_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCStrike15_v2_ClientRequestPlayersProfile::get_account_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestPlayersProfile::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_level",
                    CMsgGCCStrike15_v2_ClientRequestPlayersProfile::get_request_level_for_reflect,
                    CMsgGCCStrike15_v2_ClientRequestPlayersProfile::mut_request_level_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientRequestPlayersProfile>(
                    "CMsgGCCStrike15_v2_ClientRequestPlayersProfile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn clear(&mut self) {
        self.clear_request_id__deprecated();
        self.clear_account_ids__deprecated();
        self.clear_account_id();
        self.clear_request_level();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_PlayersProfile {
    // message fields
    request_id: ::std::option::Option<u32>,
    account_profiles: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_PlayersProfile {}

impl CMsgGCCStrike15_v2_PlayersProfile {
    pub fn new() -> CMsgGCCStrike15_v2_PlayersProfile {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayersProfile {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_PlayersProfile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_PlayersProfile,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_PlayersProfile::new)
        }
    }

    // optional uint32 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    fn get_request_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.request_id
    }

    fn mut_request_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.request_id
    }

    // repeated .CMsgGCCStrike15_v2_MatchmakingGC2ClientHello account_profiles = 2;

    pub fn clear_account_profiles(&mut self) {
        self.account_profiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_profiles(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>) {
        self.account_profiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_profiles(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello> {
        &mut self.account_profiles
    }

    // Take field
    pub fn take_account_profiles(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello> {
        ::std::mem::replace(&mut self.account_profiles, ::protobuf::RepeatedField::new())
    }

    pub fn get_account_profiles(&self) -> &[CMsgGCCStrike15_v2_MatchmakingGC2ClientHello] {
        &self.account_profiles
    }

    fn get_account_profiles_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello> {
        &self.account_profiles
    }

    fn mut_account_profiles_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello> {
        &mut self.account_profiles
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayersProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.account_profiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.account_profiles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_profiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_profiles {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_PlayersProfile {
    fn new() -> CMsgGCCStrike15_v2_PlayersProfile {
        CMsgGCCStrike15_v2_PlayersProfile::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_PlayersProfile>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    CMsgGCCStrike15_v2_PlayersProfile::get_request_id_for_reflect,
                    CMsgGCCStrike15_v2_PlayersProfile::mut_request_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>>(
                    "account_profiles",
                    CMsgGCCStrike15_v2_PlayersProfile::get_account_profiles_for_reflect,
                    CMsgGCCStrike15_v2_PlayersProfile::mut_account_profiles_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_PlayersProfile>(
                    "CMsgGCCStrike15_v2_PlayersProfile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_PlayersProfile {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_account_profiles();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_PlayersProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayersProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    // message fields
    caseid: ::std::option::Option<u64>,
    suspectid: ::std::option::Option<u32>,
    fractionid: ::std::option::Option<u32>,
    rpt_aimbot: ::std::option::Option<u32>,
    rpt_wallhack: ::std::option::Option<u32>,
    rpt_speedhack: ::std::option::Option<u32>,
    rpt_teamharm: ::std::option::Option<u32>,
    reason: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::new)
        }
    }

    // optional uint64 caseid = 1;

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    pub fn get_caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    fn get_caseid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.caseid
    }

    fn mut_caseid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.caseid
    }

    // optional uint32 suspectid = 3;

    pub fn clear_suspectid(&mut self) {
        self.suspectid = ::std::option::Option::None;
    }

    pub fn has_suspectid(&self) -> bool {
        self.suspectid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suspectid(&mut self, v: u32) {
        self.suspectid = ::std::option::Option::Some(v);
    }

    pub fn get_suspectid(&self) -> u32 {
        self.suspectid.unwrap_or(0)
    }

    fn get_suspectid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.suspectid
    }

    fn mut_suspectid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.suspectid
    }

    // optional uint32 fractionid = 4;

    pub fn clear_fractionid(&mut self) {
        self.fractionid = ::std::option::Option::None;
    }

    pub fn has_fractionid(&self) -> bool {
        self.fractionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionid(&mut self, v: u32) {
        self.fractionid = ::std::option::Option::Some(v);
    }

    pub fn get_fractionid(&self) -> u32 {
        self.fractionid.unwrap_or(0)
    }

    fn get_fractionid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fractionid
    }

    fn mut_fractionid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fractionid
    }

    // optional uint32 rpt_aimbot = 5;

    pub fn clear_rpt_aimbot(&mut self) {
        self.rpt_aimbot = ::std::option::Option::None;
    }

    pub fn has_rpt_aimbot(&self) -> bool {
        self.rpt_aimbot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_aimbot(&mut self, v: u32) {
        self.rpt_aimbot = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_aimbot(&self) -> u32 {
        self.rpt_aimbot.unwrap_or(0)
    }

    fn get_rpt_aimbot_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_aimbot
    }

    fn mut_rpt_aimbot_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_aimbot
    }

    // optional uint32 rpt_wallhack = 6;

    pub fn clear_rpt_wallhack(&mut self) {
        self.rpt_wallhack = ::std::option::Option::None;
    }

    pub fn has_rpt_wallhack(&self) -> bool {
        self.rpt_wallhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_wallhack(&mut self, v: u32) {
        self.rpt_wallhack = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_wallhack(&self) -> u32 {
        self.rpt_wallhack.unwrap_or(0)
    }

    fn get_rpt_wallhack_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_wallhack
    }

    fn mut_rpt_wallhack_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_wallhack
    }

    // optional uint32 rpt_speedhack = 7;

    pub fn clear_rpt_speedhack(&mut self) {
        self.rpt_speedhack = ::std::option::Option::None;
    }

    pub fn has_rpt_speedhack(&self) -> bool {
        self.rpt_speedhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_speedhack(&mut self, v: u32) {
        self.rpt_speedhack = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_speedhack(&self) -> u32 {
        self.rpt_speedhack.unwrap_or(0)
    }

    fn get_rpt_speedhack_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_speedhack
    }

    fn mut_rpt_speedhack_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_speedhack
    }

    // optional uint32 rpt_teamharm = 8;

    pub fn clear_rpt_teamharm(&mut self) {
        self.rpt_teamharm = ::std::option::Option::None;
    }

    pub fn has_rpt_teamharm(&self) -> bool {
        self.rpt_teamharm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_teamharm(&mut self, v: u32) {
        self.rpt_teamharm = ::std::option::Option::Some(v);
    }

    pub fn get_rpt_teamharm(&self) -> u32 {
        self.rpt_teamharm.unwrap_or(0)
    }

    fn get_rpt_teamharm_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rpt_teamharm
    }

    fn mut_rpt_teamharm_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rpt_teamharm
    }

    // optional uint32 reason = 9;

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    pub fn get_reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    fn get_reason_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reason
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.caseid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.suspectid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fractionid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_aimbot = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_wallhack = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_speedhack = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_teamharm = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.suspectid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fractionid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_aimbot {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_wallhack {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_speedhack {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_teamharm {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.suspectid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.fractionid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_aimbot {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rpt_wallhack {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rpt_speedhack {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.rpt_teamharm {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "caseid",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::get_caseid_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::mut_caseid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "suspectid",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::get_suspectid_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::mut_suspectid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fractionid",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::get_fractionid_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::mut_fractionid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_aimbot",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::get_rpt_aimbot_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::mut_rpt_aimbot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_wallhack",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::get_rpt_wallhack_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::mut_rpt_wallhack_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_speedhack",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::get_rpt_speedhack_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::mut_rpt_speedhack_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_teamharm",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::get_rpt_teamharm_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::mut_rpt_teamharm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reason",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::get_reason_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::mut_reason_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate>(
                    "CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn clear(&mut self) {
        self.clear_caseid();
        self.clear_suspectid();
        self.clear_fractionid();
        self.clear_rpt_aimbot();
        self.clear_rpt_wallhack();
        self.clear_rpt_speedhack();
        self.clear_rpt_teamharm();
        self.clear_reason();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    // message fields
    caseid: ::std::option::Option<u64>,
    caseurl: ::protobuf::SingularField<::std::string::String>,
    verdict: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    throttleseconds: ::std::option::Option<u32>,
    suspectid: ::std::option::Option<u32>,
    fractionid: ::std::option::Option<u32>,
    numrounds: ::std::option::Option<u32>,
    fractionrounds: ::std::option::Option<u32>,
    streakconvictions: ::std::option::Option<i32>,
    reason: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::new)
        }
    }

    // optional uint64 caseid = 1;

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    pub fn get_caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    fn get_caseid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.caseid
    }

    fn mut_caseid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.caseid
    }

    // optional string caseurl = 2;

    pub fn clear_caseurl(&mut self) {
        self.caseurl.clear();
    }

    pub fn has_caseurl(&self) -> bool {
        self.caseurl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseurl(&mut self, v: ::std::string::String) {
        self.caseurl = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caseurl(&mut self) -> &mut ::std::string::String {
        if self.caseurl.is_none() {
            self.caseurl.set_default();
        }
        self.caseurl.as_mut().unwrap()
    }

    // Take field
    pub fn take_caseurl(&mut self) -> ::std::string::String {
        self.caseurl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_caseurl(&self) -> &str {
        match self.caseurl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_caseurl_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.caseurl
    }

    fn mut_caseurl_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.caseurl
    }

    // optional uint32 verdict = 3;

    pub fn clear_verdict(&mut self) {
        self.verdict = ::std::option::Option::None;
    }

    pub fn has_verdict(&self) -> bool {
        self.verdict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verdict(&mut self, v: u32) {
        self.verdict = ::std::option::Option::Some(v);
    }

    pub fn get_verdict(&self) -> u32 {
        self.verdict.unwrap_or(0)
    }

    fn get_verdict_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.verdict
    }

    fn mut_verdict_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.verdict
    }

    // optional uint32 timestamp = 4;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint32 throttleseconds = 5;

    pub fn clear_throttleseconds(&mut self) {
        self.throttleseconds = ::std::option::Option::None;
    }

    pub fn has_throttleseconds(&self) -> bool {
        self.throttleseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttleseconds(&mut self, v: u32) {
        self.throttleseconds = ::std::option::Option::Some(v);
    }

    pub fn get_throttleseconds(&self) -> u32 {
        self.throttleseconds.unwrap_or(0)
    }

    fn get_throttleseconds_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.throttleseconds
    }

    fn mut_throttleseconds_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.throttleseconds
    }

    // optional uint32 suspectid = 6;

    pub fn clear_suspectid(&mut self) {
        self.suspectid = ::std::option::Option::None;
    }

    pub fn has_suspectid(&self) -> bool {
        self.suspectid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suspectid(&mut self, v: u32) {
        self.suspectid = ::std::option::Option::Some(v);
    }

    pub fn get_suspectid(&self) -> u32 {
        self.suspectid.unwrap_or(0)
    }

    fn get_suspectid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.suspectid
    }

    fn mut_suspectid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.suspectid
    }

    // optional uint32 fractionid = 7;

    pub fn clear_fractionid(&mut self) {
        self.fractionid = ::std::option::Option::None;
    }

    pub fn has_fractionid(&self) -> bool {
        self.fractionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionid(&mut self, v: u32) {
        self.fractionid = ::std::option::Option::Some(v);
    }

    pub fn get_fractionid(&self) -> u32 {
        self.fractionid.unwrap_or(0)
    }

    fn get_fractionid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fractionid
    }

    fn mut_fractionid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fractionid
    }

    // optional uint32 numrounds = 8;

    pub fn clear_numrounds(&mut self) {
        self.numrounds = ::std::option::Option::None;
    }

    pub fn has_numrounds(&self) -> bool {
        self.numrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numrounds(&mut self, v: u32) {
        self.numrounds = ::std::option::Option::Some(v);
    }

    pub fn get_numrounds(&self) -> u32 {
        self.numrounds.unwrap_or(0)
    }

    fn get_numrounds_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.numrounds
    }

    fn mut_numrounds_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.numrounds
    }

    // optional uint32 fractionrounds = 9;

    pub fn clear_fractionrounds(&mut self) {
        self.fractionrounds = ::std::option::Option::None;
    }

    pub fn has_fractionrounds(&self) -> bool {
        self.fractionrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionrounds(&mut self, v: u32) {
        self.fractionrounds = ::std::option::Option::Some(v);
    }

    pub fn get_fractionrounds(&self) -> u32 {
        self.fractionrounds.unwrap_or(0)
    }

    fn get_fractionrounds_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fractionrounds
    }

    fn mut_fractionrounds_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fractionrounds
    }

    // optional int32 streakconvictions = 10;

    pub fn clear_streakconvictions(&mut self) {
        self.streakconvictions = ::std::option::Option::None;
    }

    pub fn has_streakconvictions(&self) -> bool {
        self.streakconvictions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streakconvictions(&mut self, v: i32) {
        self.streakconvictions = ::std::option::Option::Some(v);
    }

    pub fn get_streakconvictions(&self) -> i32 {
        self.streakconvictions.unwrap_or(0)
    }

    fn get_streakconvictions_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.streakconvictions
    }

    fn mut_streakconvictions_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.streakconvictions
    }

    // optional uint32 reason = 11;

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    pub fn get_reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    fn get_reason_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reason
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.caseid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caseurl)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.verdict = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.throttleseconds = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.suspectid = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fractionid = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numrounds = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fractionrounds = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.streakconvictions = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.caseurl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.verdict {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.throttleseconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.suspectid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fractionid {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numrounds {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fractionrounds {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.streakconvictions {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.caseurl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.verdict {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.throttleseconds {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.suspectid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.fractionid {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.numrounds {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.fractionrounds {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.streakconvictions {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "caseid",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::get_caseid_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::mut_caseid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "caseurl",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::get_caseurl_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::mut_caseurl_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "verdict",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::get_verdict_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::mut_verdict_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::get_timestamp_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "throttleseconds",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::get_throttleseconds_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::mut_throttleseconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "suspectid",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::get_suspectid_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::mut_suspectid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fractionid",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::get_fractionid_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::mut_fractionid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "numrounds",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::get_numrounds_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::mut_numrounds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fractionrounds",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::get_fractionrounds_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::mut_fractionrounds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "streakconvictions",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::get_streakconvictions_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::mut_streakconvictions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reason",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::get_reason_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::mut_reason_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment>(
                    "CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn clear(&mut self) {
        self.clear_caseid();
        self.clear_caseurl();
        self.clear_verdict();
        self.clear_timestamp();
        self.clear_throttleseconds();
        self.clear_suspectid();
        self.clear_fractionid();
        self.clear_numrounds();
        self.clear_fractionrounds();
        self.clear_streakconvictions();
        self.clear_reason();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    // message fields
    caseid: ::std::option::Option<u64>,
    statusid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::new)
        }
    }

    // optional uint64 caseid = 1;

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    pub fn get_caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    fn get_caseid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.caseid
    }

    fn mut_caseid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.caseid
    }

    // optional uint32 statusid = 2;

    pub fn clear_statusid(&mut self) {
        self.statusid = ::std::option::Option::None;
    }

    pub fn has_statusid(&self) -> bool {
        self.statusid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusid(&mut self, v: u32) {
        self.statusid = ::std::option::Option::Some(v);
    }

    pub fn get_statusid(&self) -> u32 {
        self.statusid.unwrap_or(0)
    }

    fn get_statusid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.statusid
    }

    fn mut_statusid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.statusid
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.caseid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.statusid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.statusid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.statusid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "caseid",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::get_caseid_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::mut_caseid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "statusid",
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::get_statusid_for_reflect,
                    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::mut_statusid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus>(
                    "CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn clear(&mut self) {
        self.clear_caseid();
        self.clear_statusid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CClientHeaderOverwatchEvidence {
    // message fields
    accountid: ::std::option::Option<u32>,
    caseid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CClientHeaderOverwatchEvidence {}

impl CClientHeaderOverwatchEvidence {
    pub fn new() -> CClientHeaderOverwatchEvidence {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CClientHeaderOverwatchEvidence {
        static mut instance: ::protobuf::lazy::Lazy<CClientHeaderOverwatchEvidence> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClientHeaderOverwatchEvidence,
        };
        unsafe {
            instance.get(CClientHeaderOverwatchEvidence::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }

    // optional uint64 caseid = 2;

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    pub fn get_caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    fn get_caseid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.caseid
    }

    fn mut_caseid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.caseid
    }
}

impl ::protobuf::Message for CClientHeaderOverwatchEvidence {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.caseid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.caseid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CClientHeaderOverwatchEvidence {
    fn new() -> CClientHeaderOverwatchEvidence {
        CClientHeaderOverwatchEvidence::new()
    }

    fn descriptor_static(_: ::std::option::Option<CClientHeaderOverwatchEvidence>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CClientHeaderOverwatchEvidence::get_accountid_for_reflect,
                    CClientHeaderOverwatchEvidence::mut_accountid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "caseid",
                    CClientHeaderOverwatchEvidence::get_caseid_for_reflect,
                    CClientHeaderOverwatchEvidence::mut_caseid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClientHeaderOverwatchEvidence>(
                    "CClientHeaderOverwatchEvidence",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CClientHeaderOverwatchEvidence {
    fn clear(&mut self) {
        self.clear_accountid();
        self.clear_caseid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientHeaderOverwatchEvidence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientHeaderOverwatchEvidence {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GC2ClientTextMsg {
    // message fields
    id: ::std::option::Option<u32>,
    field_type: ::std::option::Option<u32>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_GC2ClientTextMsg {}

impl CMsgGCCStrike15_v2_GC2ClientTextMsg {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientTextMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientTextMsg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GC2ClientTextMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GC2ClientTextMsg,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GC2ClientTextMsg::new)
        }
    }

    // optional uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.id
    }

    // optional uint32 type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.field_type
    }

    // optional bytes payload = 3;

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_payload_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.payload
    }

    fn mut_payload_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.payload
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn new() -> CMsgGCCStrike15_v2_GC2ClientTextMsg {
        CMsgGCCStrike15_v2_GC2ClientTextMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_GC2ClientTextMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    CMsgGCCStrike15_v2_GC2ClientTextMsg::get_id_for_reflect,
                    CMsgGCCStrike15_v2_GC2ClientTextMsg::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    CMsgGCCStrike15_v2_GC2ClientTextMsg::get_field_type_for_reflect,
                    CMsgGCCStrike15_v2_GC2ClientTextMsg::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    CMsgGCCStrike15_v2_GC2ClientTextMsg::get_payload_for_reflect,
                    CMsgGCCStrike15_v2_GC2ClientTextMsg::mut_payload_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GC2ClientTextMsg>(
                    "CMsgGCCStrike15_v2_GC2ClientTextMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_field_type();
        self.clear_payload();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Client2GCTextMsg {
    // message fields
    id: ::std::option::Option<u32>,
    args: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Client2GCTextMsg {}

impl CMsgGCCStrike15_v2_Client2GCTextMsg {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCTextMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCTextMsg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Client2GCTextMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Client2GCTextMsg,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Client2GCTextMsg::new)
        }
    }

    // optional uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.id
    }

    // repeated bytes args = 2;

    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    pub fn get_args(&self) -> &[::std::vec::Vec<u8>] {
        &self.args
    }

    fn get_args_for_reflect(&self) -> &::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &self.args
    }

    fn mut_args_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.args
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.args {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        for v in &self.args {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn new() -> CMsgGCCStrike15_v2_Client2GCTextMsg {
        CMsgGCCStrike15_v2_Client2GCTextMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Client2GCTextMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    CMsgGCCStrike15_v2_Client2GCTextMsg::get_id_for_reflect,
                    CMsgGCCStrike15_v2_Client2GCTextMsg::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "args",
                    CMsgGCCStrike15_v2_Client2GCTextMsg::get_args_for_reflect,
                    CMsgGCCStrike15_v2_Client2GCTextMsg::mut_args_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Client2GCTextMsg>(
                    "CMsgGCCStrike15_v2_Client2GCTextMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_args();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    // message fields
    serverinfo: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>,
    match_end_quest_data: ::protobuf::SingularPtrField<CMsgGC_ServerQuestUpdateData>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {}

impl CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    pub fn new() -> CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchEndRunRewardDrops> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchEndRunRewardDrops,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchEndRunRewardDrops::new)
        }
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingServerReservationResponse serverinfo = 3;

    pub fn clear_serverinfo(&mut self) {
        self.serverinfo.clear();
    }

    pub fn has_serverinfo(&self) -> bool {
        self.serverinfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverinfo(&mut self, v: CMsgGCCStrike15_v2_MatchmakingServerReservationResponse) {
        self.serverinfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverinfo(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        if self.serverinfo.is_none() {
            self.serverinfo.set_default();
        }
        self.serverinfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverinfo(&mut self) -> CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        self.serverinfo.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::new())
    }

    pub fn get_serverinfo(&self) -> &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        self.serverinfo.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::default_instance())
    }

    fn get_serverinfo_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse> {
        &self.serverinfo
    }

    fn mut_serverinfo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse> {
        &mut self.serverinfo
    }

    // optional .CMsgGC_ServerQuestUpdateData match_end_quest_data = 4;

    pub fn clear_match_end_quest_data(&mut self) {
        self.match_end_quest_data.clear();
    }

    pub fn has_match_end_quest_data(&self) -> bool {
        self.match_end_quest_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_end_quest_data(&mut self, v: CMsgGC_ServerQuestUpdateData) {
        self.match_end_quest_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_end_quest_data(&mut self) -> &mut CMsgGC_ServerQuestUpdateData {
        if self.match_end_quest_data.is_none() {
            self.match_end_quest_data.set_default();
        }
        self.match_end_quest_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_match_end_quest_data(&mut self) -> CMsgGC_ServerQuestUpdateData {
        self.match_end_quest_data.take().unwrap_or_else(|| CMsgGC_ServerQuestUpdateData::new())
    }

    pub fn get_match_end_quest_data(&self) -> &CMsgGC_ServerQuestUpdateData {
        self.match_end_quest_data.as_ref().unwrap_or_else(|| CMsgGC_ServerQuestUpdateData::default_instance())
    }

    fn get_match_end_quest_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGC_ServerQuestUpdateData> {
        &self.match_end_quest_data
    }

    fn mut_match_end_quest_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGC_ServerQuestUpdateData> {
        &mut self.match_end_quest_data
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn is_initialized(&self) -> bool {
        for v in &self.serverinfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.match_end_quest_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverinfo)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.match_end_quest_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.serverinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.match_end_quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.serverinfo.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.match_end_quest_data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn new() -> CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        CMsgGCCStrike15_v2_MatchEndRunRewardDrops::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchEndRunRewardDrops>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>>(
                    "serverinfo",
                    CMsgGCCStrike15_v2_MatchEndRunRewardDrops::get_serverinfo_for_reflect,
                    CMsgGCCStrike15_v2_MatchEndRunRewardDrops::mut_serverinfo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGC_ServerQuestUpdateData>>(
                    "match_end_quest_data",
                    CMsgGCCStrike15_v2_MatchEndRunRewardDrops::get_match_end_quest_data_for_reflect,
                    CMsgGCCStrike15_v2_MatchEndRunRewardDrops::mut_match_end_quest_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchEndRunRewardDrops>(
                    "CMsgGCCStrike15_v2_MatchEndRunRewardDrops",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn clear(&mut self) {
        self.clear_serverinfo();
        self.clear_match_end_quest_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CEconItemPreviewDataBlock {
    // message fields
    accountid: ::std::option::Option<u32>,
    itemid: ::std::option::Option<u64>,
    defindex: ::std::option::Option<u32>,
    paintindex: ::std::option::Option<u32>,
    rarity: ::std::option::Option<u32>,
    quality: ::std::option::Option<u32>,
    paintwear: ::std::option::Option<u32>,
    paintseed: ::std::option::Option<u32>,
    killeaterscoretype: ::std::option::Option<u32>,
    killeatervalue: ::std::option::Option<u32>,
    customname: ::protobuf::SingularField<::std::string::String>,
    stickers: ::protobuf::RepeatedField<CEconItemPreviewDataBlock_Sticker>,
    inventory: ::std::option::Option<u32>,
    origin: ::std::option::Option<u32>,
    questid: ::std::option::Option<u32>,
    dropreason: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CEconItemPreviewDataBlock {}

impl CEconItemPreviewDataBlock {
    pub fn new() -> CEconItemPreviewDataBlock {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CEconItemPreviewDataBlock {
        static mut instance: ::protobuf::lazy::Lazy<CEconItemPreviewDataBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CEconItemPreviewDataBlock,
        };
        unsafe {
            instance.get(CEconItemPreviewDataBlock::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }

    // optional uint64 itemid = 2;

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    pub fn get_itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }

    fn get_itemid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.itemid
    }

    fn mut_itemid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.itemid
    }

    // optional uint32 defindex = 3;

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    pub fn get_defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    fn get_defindex_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.defindex
    }

    fn mut_defindex_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.defindex
    }

    // optional uint32 paintindex = 4;

    pub fn clear_paintindex(&mut self) {
        self.paintindex = ::std::option::Option::None;
    }

    pub fn has_paintindex(&self) -> bool {
        self.paintindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintindex(&mut self, v: u32) {
        self.paintindex = ::std::option::Option::Some(v);
    }

    pub fn get_paintindex(&self) -> u32 {
        self.paintindex.unwrap_or(0)
    }

    fn get_paintindex_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.paintindex
    }

    fn mut_paintindex_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.paintindex
    }

    // optional uint32 rarity = 5;

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    pub fn get_rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }

    fn get_rarity_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rarity
    }

    fn mut_rarity_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rarity
    }

    // optional uint32 quality = 6;

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    pub fn get_quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    fn get_quality_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quality
    }

    fn mut_quality_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quality
    }

    // optional uint32 paintwear = 7;

    pub fn clear_paintwear(&mut self) {
        self.paintwear = ::std::option::Option::None;
    }

    pub fn has_paintwear(&self) -> bool {
        self.paintwear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintwear(&mut self, v: u32) {
        self.paintwear = ::std::option::Option::Some(v);
    }

    pub fn get_paintwear(&self) -> u32 {
        self.paintwear.unwrap_or(0)
    }

    fn get_paintwear_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.paintwear
    }

    fn mut_paintwear_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.paintwear
    }

    // optional uint32 paintseed = 8;

    pub fn clear_paintseed(&mut self) {
        self.paintseed = ::std::option::Option::None;
    }

    pub fn has_paintseed(&self) -> bool {
        self.paintseed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintseed(&mut self, v: u32) {
        self.paintseed = ::std::option::Option::Some(v);
    }

    pub fn get_paintseed(&self) -> u32 {
        self.paintseed.unwrap_or(0)
    }

    fn get_paintseed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.paintseed
    }

    fn mut_paintseed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.paintseed
    }

    // optional uint32 killeaterscoretype = 9;

    pub fn clear_killeaterscoretype(&mut self) {
        self.killeaterscoretype = ::std::option::Option::None;
    }

    pub fn has_killeaterscoretype(&self) -> bool {
        self.killeaterscoretype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killeaterscoretype(&mut self, v: u32) {
        self.killeaterscoretype = ::std::option::Option::Some(v);
    }

    pub fn get_killeaterscoretype(&self) -> u32 {
        self.killeaterscoretype.unwrap_or(0)
    }

    fn get_killeaterscoretype_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.killeaterscoretype
    }

    fn mut_killeaterscoretype_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.killeaterscoretype
    }

    // optional uint32 killeatervalue = 10;

    pub fn clear_killeatervalue(&mut self) {
        self.killeatervalue = ::std::option::Option::None;
    }

    pub fn has_killeatervalue(&self) -> bool {
        self.killeatervalue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killeatervalue(&mut self, v: u32) {
        self.killeatervalue = ::std::option::Option::Some(v);
    }

    pub fn get_killeatervalue(&self) -> u32 {
        self.killeatervalue.unwrap_or(0)
    }

    fn get_killeatervalue_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.killeatervalue
    }

    fn mut_killeatervalue_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.killeatervalue
    }

    // optional string customname = 11;

    pub fn clear_customname(&mut self) {
        self.customname.clear();
    }

    pub fn has_customname(&self) -> bool {
        self.customname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_customname(&mut self, v: ::std::string::String) {
        self.customname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_customname(&mut self) -> &mut ::std::string::String {
        if self.customname.is_none() {
            self.customname.set_default();
        }
        self.customname.as_mut().unwrap()
    }

    // Take field
    pub fn take_customname(&mut self) -> ::std::string::String {
        self.customname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_customname(&self) -> &str {
        match self.customname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_customname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.customname
    }

    fn mut_customname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.customname
    }

    // repeated .CEconItemPreviewDataBlock.Sticker stickers = 12;

    pub fn clear_stickers(&mut self) {
        self.stickers.clear();
    }

    // Param is passed by value, moved
    pub fn set_stickers(&mut self, v: ::protobuf::RepeatedField<CEconItemPreviewDataBlock_Sticker>) {
        self.stickers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stickers(&mut self) -> &mut ::protobuf::RepeatedField<CEconItemPreviewDataBlock_Sticker> {
        &mut self.stickers
    }

    // Take field
    pub fn take_stickers(&mut self) -> ::protobuf::RepeatedField<CEconItemPreviewDataBlock_Sticker> {
        ::std::mem::replace(&mut self.stickers, ::protobuf::RepeatedField::new())
    }

    pub fn get_stickers(&self) -> &[CEconItemPreviewDataBlock_Sticker] {
        &self.stickers
    }

    fn get_stickers_for_reflect(&self) -> &::protobuf::RepeatedField<CEconItemPreviewDataBlock_Sticker> {
        &self.stickers
    }

    fn mut_stickers_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CEconItemPreviewDataBlock_Sticker> {
        &mut self.stickers
    }

    // optional uint32 inventory = 13;

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    pub fn get_inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    fn get_inventory_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.inventory
    }

    fn mut_inventory_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.inventory
    }

    // optional uint32 origin = 14;

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    pub fn get_origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    fn get_origin_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.origin
    }

    fn mut_origin_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.origin
    }

    // optional uint32 questid = 15;

    pub fn clear_questid(&mut self) {
        self.questid = ::std::option::Option::None;
    }

    pub fn has_questid(&self) -> bool {
        self.questid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_questid(&mut self, v: u32) {
        self.questid = ::std::option::Option::Some(v);
    }

    pub fn get_questid(&self) -> u32 {
        self.questid.unwrap_or(0)
    }

    fn get_questid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.questid
    }

    fn mut_questid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.questid
    }

    // optional uint32 dropreason = 16;

    pub fn clear_dropreason(&mut self) {
        self.dropreason = ::std::option::Option::None;
    }

    pub fn has_dropreason(&self) -> bool {
        self.dropreason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dropreason(&mut self, v: u32) {
        self.dropreason = ::std::option::Option::Some(v);
    }

    pub fn get_dropreason(&self) -> u32 {
        self.dropreason.unwrap_or(0)
    }

    fn get_dropreason_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dropreason
    }

    fn mut_dropreason_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dropreason
    }
}

impl ::protobuf::Message for CEconItemPreviewDataBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.stickers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defindex = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.paintindex = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rarity = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.paintwear = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.paintseed = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.killeaterscoretype = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.killeatervalue = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.customname)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stickers)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.inventory = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.origin = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.questid = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dropreason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.paintindex {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.paintwear {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.paintseed {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.killeaterscoretype {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.killeatervalue {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.customname.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.stickers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.questid {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dropreason {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.itemid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.paintindex {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.paintwear {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.paintseed {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.killeaterscoretype {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.killeatervalue {
            os.write_uint32(10, v)?;
        }
        if let Some(ref v) = self.customname.as_ref() {
            os.write_string(11, &v)?;
        }
        for v in &self.stickers {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.inventory {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.questid {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.dropreason {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CEconItemPreviewDataBlock {
    fn new() -> CEconItemPreviewDataBlock {
        CEconItemPreviewDataBlock::new()
    }

    fn descriptor_static(_: ::std::option::Option<CEconItemPreviewDataBlock>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CEconItemPreviewDataBlock::get_accountid_for_reflect,
                    CEconItemPreviewDataBlock::mut_accountid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "itemid",
                    CEconItemPreviewDataBlock::get_itemid_for_reflect,
                    CEconItemPreviewDataBlock::mut_itemid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "defindex",
                    CEconItemPreviewDataBlock::get_defindex_for_reflect,
                    CEconItemPreviewDataBlock::mut_defindex_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "paintindex",
                    CEconItemPreviewDataBlock::get_paintindex_for_reflect,
                    CEconItemPreviewDataBlock::mut_paintindex_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rarity",
                    CEconItemPreviewDataBlock::get_rarity_for_reflect,
                    CEconItemPreviewDataBlock::mut_rarity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quality",
                    CEconItemPreviewDataBlock::get_quality_for_reflect,
                    CEconItemPreviewDataBlock::mut_quality_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "paintwear",
                    CEconItemPreviewDataBlock::get_paintwear_for_reflect,
                    CEconItemPreviewDataBlock::mut_paintwear_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "paintseed",
                    CEconItemPreviewDataBlock::get_paintseed_for_reflect,
                    CEconItemPreviewDataBlock::mut_paintseed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "killeaterscoretype",
                    CEconItemPreviewDataBlock::get_killeaterscoretype_for_reflect,
                    CEconItemPreviewDataBlock::mut_killeaterscoretype_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "killeatervalue",
                    CEconItemPreviewDataBlock::get_killeatervalue_for_reflect,
                    CEconItemPreviewDataBlock::mut_killeatervalue_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "customname",
                    CEconItemPreviewDataBlock::get_customname_for_reflect,
                    CEconItemPreviewDataBlock::mut_customname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CEconItemPreviewDataBlock_Sticker>>(
                    "stickers",
                    CEconItemPreviewDataBlock::get_stickers_for_reflect,
                    CEconItemPreviewDataBlock::mut_stickers_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "inventory",
                    CEconItemPreviewDataBlock::get_inventory_for_reflect,
                    CEconItemPreviewDataBlock::mut_inventory_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "origin",
                    CEconItemPreviewDataBlock::get_origin_for_reflect,
                    CEconItemPreviewDataBlock::mut_origin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "questid",
                    CEconItemPreviewDataBlock::get_questid_for_reflect,
                    CEconItemPreviewDataBlock::mut_questid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dropreason",
                    CEconItemPreviewDataBlock::get_dropreason_for_reflect,
                    CEconItemPreviewDataBlock::mut_dropreason_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CEconItemPreviewDataBlock>(
                    "CEconItemPreviewDataBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CEconItemPreviewDataBlock {
    fn clear(&mut self) {
        self.clear_accountid();
        self.clear_itemid();
        self.clear_defindex();
        self.clear_paintindex();
        self.clear_rarity();
        self.clear_quality();
        self.clear_paintwear();
        self.clear_paintseed();
        self.clear_killeaterscoretype();
        self.clear_killeatervalue();
        self.clear_customname();
        self.clear_stickers();
        self.clear_inventory();
        self.clear_origin();
        self.clear_questid();
        self.clear_dropreason();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CEconItemPreviewDataBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEconItemPreviewDataBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CEconItemPreviewDataBlock_Sticker {
    // message fields
    slot: ::std::option::Option<u32>,
    sticker_id: ::std::option::Option<u32>,
    wear: ::std::option::Option<f32>,
    scale: ::std::option::Option<f32>,
    rotation: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CEconItemPreviewDataBlock_Sticker {}

impl CEconItemPreviewDataBlock_Sticker {
    pub fn new() -> CEconItemPreviewDataBlock_Sticker {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CEconItemPreviewDataBlock_Sticker {
        static mut instance: ::protobuf::lazy::Lazy<CEconItemPreviewDataBlock_Sticker> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CEconItemPreviewDataBlock_Sticker,
        };
        unsafe {
            instance.get(CEconItemPreviewDataBlock_Sticker::new)
        }
    }

    // optional uint32 slot = 1;

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: u32) {
        self.slot = ::std::option::Option::Some(v);
    }

    pub fn get_slot(&self) -> u32 {
        self.slot.unwrap_or(0)
    }

    fn get_slot_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot
    }

    fn mut_slot_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot
    }

    // optional uint32 sticker_id = 2;

    pub fn clear_sticker_id(&mut self) {
        self.sticker_id = ::std::option::Option::None;
    }

    pub fn has_sticker_id(&self) -> bool {
        self.sticker_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_id(&mut self, v: u32) {
        self.sticker_id = ::std::option::Option::Some(v);
    }

    pub fn get_sticker_id(&self) -> u32 {
        self.sticker_id.unwrap_or(0)
    }

    fn get_sticker_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.sticker_id
    }

    fn mut_sticker_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.sticker_id
    }

    // optional float wear = 3;

    pub fn clear_wear(&mut self) {
        self.wear = ::std::option::Option::None;
    }

    pub fn has_wear(&self) -> bool {
        self.wear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wear(&mut self, v: f32) {
        self.wear = ::std::option::Option::Some(v);
    }

    pub fn get_wear(&self) -> f32 {
        self.wear.unwrap_or(0.)
    }

    fn get_wear_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.wear
    }

    fn mut_wear_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.wear
    }

    // optional float scale = 4;

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    pub fn get_scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    fn get_scale_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.scale
    }

    fn mut_scale_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.scale
    }

    // optional float rotation = 5;

    pub fn clear_rotation(&mut self) {
        self.rotation = ::std::option::Option::None;
    }

    pub fn has_rotation(&self) -> bool {
        self.rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotation(&mut self, v: f32) {
        self.rotation = ::std::option::Option::Some(v);
    }

    pub fn get_rotation(&self) -> f32 {
        self.rotation.unwrap_or(0.)
    }

    fn get_rotation_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.rotation
    }

    fn mut_rotation_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.rotation
    }
}

impl ::protobuf::Message for CEconItemPreviewDataBlock_Sticker {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sticker_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.wear = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scale = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rotation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sticker_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wear {
            my_size += 5;
        }
        if let Some(v) = self.scale {
            my_size += 5;
        }
        if let Some(v) = self.rotation {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.slot {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sticker_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.wear {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.rotation {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CEconItemPreviewDataBlock_Sticker {
    fn new() -> CEconItemPreviewDataBlock_Sticker {
        CEconItemPreviewDataBlock_Sticker::new()
    }

    fn descriptor_static(_: ::std::option::Option<CEconItemPreviewDataBlock_Sticker>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot",
                    CEconItemPreviewDataBlock_Sticker::get_slot_for_reflect,
                    CEconItemPreviewDataBlock_Sticker::mut_slot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sticker_id",
                    CEconItemPreviewDataBlock_Sticker::get_sticker_id_for_reflect,
                    CEconItemPreviewDataBlock_Sticker::mut_sticker_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "wear",
                    CEconItemPreviewDataBlock_Sticker::get_wear_for_reflect,
                    CEconItemPreviewDataBlock_Sticker::mut_wear_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scale",
                    CEconItemPreviewDataBlock_Sticker::get_scale_for_reflect,
                    CEconItemPreviewDataBlock_Sticker::mut_scale_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rotation",
                    CEconItemPreviewDataBlock_Sticker::get_rotation_for_reflect,
                    CEconItemPreviewDataBlock_Sticker::mut_rotation_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CEconItemPreviewDataBlock_Sticker>(
                    "CEconItemPreviewDataBlock_Sticker",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CEconItemPreviewDataBlock_Sticker {
    fn clear(&mut self) {
        self.clear_slot();
        self.clear_sticker_id();
        self.clear_wear();
        self.clear_scale();
        self.clear_rotation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CEconItemPreviewDataBlock_Sticker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEconItemPreviewDataBlock_Sticker {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    // message fields
    iteminfo: ::protobuf::SingularPtrField<CEconItemPreviewDataBlock>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {}

impl CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    pub fn new() -> CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchEndRewardDropsNotification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchEndRewardDropsNotification,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchEndRewardDropsNotification::new)
        }
    }

    // optional .CEconItemPreviewDataBlock iteminfo = 6;

    pub fn clear_iteminfo(&mut self) {
        self.iteminfo.clear();
    }

    pub fn has_iteminfo(&self) -> bool {
        self.iteminfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iteminfo(&mut self, v: CEconItemPreviewDataBlock) {
        self.iteminfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iteminfo(&mut self) -> &mut CEconItemPreviewDataBlock {
        if self.iteminfo.is_none() {
            self.iteminfo.set_default();
        }
        self.iteminfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_iteminfo(&mut self) -> CEconItemPreviewDataBlock {
        self.iteminfo.take().unwrap_or_else(|| CEconItemPreviewDataBlock::new())
    }

    pub fn get_iteminfo(&self) -> &CEconItemPreviewDataBlock {
        self.iteminfo.as_ref().unwrap_or_else(|| CEconItemPreviewDataBlock::default_instance())
    }

    fn get_iteminfo_for_reflect(&self) -> &::protobuf::SingularPtrField<CEconItemPreviewDataBlock> {
        &self.iteminfo
    }

    fn mut_iteminfo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CEconItemPreviewDataBlock> {
        &mut self.iteminfo
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn is_initialized(&self) -> bool {
        for v in &self.iteminfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iteminfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iteminfo.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn new() -> CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        CMsgGCCStrike15_v2_MatchEndRewardDropsNotification::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchEndRewardDropsNotification>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CEconItemPreviewDataBlock>>(
                    "iteminfo",
                    CMsgGCCStrike15_v2_MatchEndRewardDropsNotification::get_iteminfo_for_reflect,
                    CMsgGCCStrike15_v2_MatchEndRewardDropsNotification::mut_iteminfo_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchEndRewardDropsNotification>(
                    "CMsgGCCStrike15_v2_MatchEndRewardDropsNotification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn clear(&mut self) {
        self.clear_iteminfo();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgItemAcknowledged {
    // message fields
    iteminfo: ::protobuf::SingularPtrField<CEconItemPreviewDataBlock>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgItemAcknowledged {}

impl CMsgItemAcknowledged {
    pub fn new() -> CMsgItemAcknowledged {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgItemAcknowledged {
        static mut instance: ::protobuf::lazy::Lazy<CMsgItemAcknowledged> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgItemAcknowledged,
        };
        unsafe {
            instance.get(CMsgItemAcknowledged::new)
        }
    }

    // optional .CEconItemPreviewDataBlock iteminfo = 1;

    pub fn clear_iteminfo(&mut self) {
        self.iteminfo.clear();
    }

    pub fn has_iteminfo(&self) -> bool {
        self.iteminfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iteminfo(&mut self, v: CEconItemPreviewDataBlock) {
        self.iteminfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iteminfo(&mut self) -> &mut CEconItemPreviewDataBlock {
        if self.iteminfo.is_none() {
            self.iteminfo.set_default();
        }
        self.iteminfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_iteminfo(&mut self) -> CEconItemPreviewDataBlock {
        self.iteminfo.take().unwrap_or_else(|| CEconItemPreviewDataBlock::new())
    }

    pub fn get_iteminfo(&self) -> &CEconItemPreviewDataBlock {
        self.iteminfo.as_ref().unwrap_or_else(|| CEconItemPreviewDataBlock::default_instance())
    }

    fn get_iteminfo_for_reflect(&self) -> &::protobuf::SingularPtrField<CEconItemPreviewDataBlock> {
        &self.iteminfo
    }

    fn mut_iteminfo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CEconItemPreviewDataBlock> {
        &mut self.iteminfo
    }
}

impl ::protobuf::Message for CMsgItemAcknowledged {
    fn is_initialized(&self) -> bool {
        for v in &self.iteminfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iteminfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iteminfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgItemAcknowledged {
    fn new() -> CMsgItemAcknowledged {
        CMsgItemAcknowledged::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgItemAcknowledged>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CEconItemPreviewDataBlock>>(
                    "iteminfo",
                    CMsgItemAcknowledged::get_iteminfo_for_reflect,
                    CMsgItemAcknowledged::mut_iteminfo_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgItemAcknowledged>(
                    "CMsgItemAcknowledged",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgItemAcknowledged {
    fn clear(&mut self) {
        self.clear_iteminfo();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgItemAcknowledged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemAcknowledged {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    // message fields
    param_s: ::std::option::Option<u64>,
    param_a: ::std::option::Option<u64>,
    param_d: ::std::option::Option<u64>,
    param_m: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {}

impl CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::new)
        }
    }

    // optional uint64 param_s = 1;

    pub fn clear_param_s(&mut self) {
        self.param_s = ::std::option::Option::None;
    }

    pub fn has_param_s(&self) -> bool {
        self.param_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_s(&mut self, v: u64) {
        self.param_s = ::std::option::Option::Some(v);
    }

    pub fn get_param_s(&self) -> u64 {
        self.param_s.unwrap_or(0)
    }

    fn get_param_s_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.param_s
    }

    fn mut_param_s_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.param_s
    }

    // optional uint64 param_a = 2;

    pub fn clear_param_a(&mut self) {
        self.param_a = ::std::option::Option::None;
    }

    pub fn has_param_a(&self) -> bool {
        self.param_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_a(&mut self, v: u64) {
        self.param_a = ::std::option::Option::Some(v);
    }

    pub fn get_param_a(&self) -> u64 {
        self.param_a.unwrap_or(0)
    }

    fn get_param_a_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.param_a
    }

    fn mut_param_a_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.param_a
    }

    // optional uint64 param_d = 3;

    pub fn clear_param_d(&mut self) {
        self.param_d = ::std::option::Option::None;
    }

    pub fn has_param_d(&self) -> bool {
        self.param_d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_d(&mut self, v: u64) {
        self.param_d = ::std::option::Option::Some(v);
    }

    pub fn get_param_d(&self) -> u64 {
        self.param_d.unwrap_or(0)
    }

    fn get_param_d_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.param_d
    }

    fn mut_param_d_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.param_d
    }

    // optional uint64 param_m = 4;

    pub fn clear_param_m(&mut self) {
        self.param_m = ::std::option::Option::None;
    }

    pub fn has_param_m(&self) -> bool {
        self.param_m.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_m(&mut self, v: u64) {
        self.param_m = ::std::option::Option::Some(v);
    }

    pub fn get_param_m(&self) -> u64 {
        self.param_m.unwrap_or(0)
    }

    fn get_param_m_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.param_m
    }

    fn mut_param_m_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.param_m
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_s = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_a = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_d = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_m = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.param_s {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.param_a {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.param_d {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.param_m {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.param_s {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.param_a {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.param_d {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.param_m {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "param_s",
                    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::get_param_s_for_reflect,
                    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::mut_param_s_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "param_a",
                    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::get_param_a_for_reflect,
                    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::mut_param_a_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "param_d",
                    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::get_param_d_for_reflect,
                    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::mut_param_d_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "param_m",
                    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::get_param_m_for_reflect,
                    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::mut_param_m_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest>(
                    "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn clear(&mut self) {
        self.clear_param_s();
        self.clear_param_a();
        self.clear_param_d();
        self.clear_param_m();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    // message fields
    iteminfo: ::protobuf::SingularPtrField<CEconItemPreviewDataBlock>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {}

impl CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse::new)
        }
    }

    // optional .CEconItemPreviewDataBlock iteminfo = 1;

    pub fn clear_iteminfo(&mut self) {
        self.iteminfo.clear();
    }

    pub fn has_iteminfo(&self) -> bool {
        self.iteminfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iteminfo(&mut self, v: CEconItemPreviewDataBlock) {
        self.iteminfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iteminfo(&mut self) -> &mut CEconItemPreviewDataBlock {
        if self.iteminfo.is_none() {
            self.iteminfo.set_default();
        }
        self.iteminfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_iteminfo(&mut self) -> CEconItemPreviewDataBlock {
        self.iteminfo.take().unwrap_or_else(|| CEconItemPreviewDataBlock::new())
    }

    pub fn get_iteminfo(&self) -> &CEconItemPreviewDataBlock {
        self.iteminfo.as_ref().unwrap_or_else(|| CEconItemPreviewDataBlock::default_instance())
    }

    fn get_iteminfo_for_reflect(&self) -> &::protobuf::SingularPtrField<CEconItemPreviewDataBlock> {
        &self.iteminfo
    }

    fn mut_iteminfo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CEconItemPreviewDataBlock> {
        &mut self.iteminfo
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.iteminfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iteminfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iteminfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CEconItemPreviewDataBlock>>(
                    "iteminfo",
                    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse::get_iteminfo_for_reflect,
                    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse::mut_iteminfo_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse>(
                    "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn clear(&mut self) {
        self.clear_iteminfo();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    // message fields
    match_id: ::std::option::Option<u64>,
    defindex: ::std::option::Option<u32>,
    accountids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {}

impl CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    pub fn new() -> CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 defindex = 2;

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    pub fn get_defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    fn get_defindex_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.defindex
    }

    fn mut_defindex_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.defindex
    }

    // repeated uint32 accountids = 3;

    pub fn clear_accountids(&mut self) {
        self.accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountids(&mut self, v: ::std::vec::Vec<u32>) {
        self.accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accountids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.accountids
    }

    // Take field
    pub fn take_accountids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.accountids, ::std::vec::Vec::new())
    }

    pub fn get_accountids(&self) -> &[u32] {
        &self.accountids
    }

    fn get_accountids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.accountids
    }

    fn mut_accountids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.accountids
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defindex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.accountids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.accountids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(2, v)?;
        }
        for v in &self.accountids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn new() -> CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
        CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::get_match_id_for_reflect,
                    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "defindex",
                    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::get_defindex_for_reflect,
                    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::mut_defindex_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountids",
                    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::get_accountids_for_reflect,
                    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::mut_accountids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification>(
                    "CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_defindex();
        self.clear_accountids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {}

impl CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn new() -> CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames>(
                    "CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    // message fields
    accountid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {}

impl CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn new() -> CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser::get_accountid_for_reflect,
                    CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser::mut_accountid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser>(
                    "CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn clear(&mut self) {
        self.clear_accountid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    // message fields
    accountid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {}

impl CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchListRequestRecentUserGames> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchListRequestRecentUserGames,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchListRequestRecentUserGames::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn new() -> CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        CMsgGCCStrike15_v2_MatchListRequestRecentUserGames::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchListRequestRecentUserGames>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgGCCStrike15_v2_MatchListRequestRecentUserGames::get_accountid_for_reflect,
                    CMsgGCCStrike15_v2_MatchListRequestRecentUserGames::mut_accountid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchListRequestRecentUserGames>(
                    "CMsgGCCStrike15_v2_MatchListRequestRecentUserGames",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn clear(&mut self) {
        self.clear_accountid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    // message fields
    eventid: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {}

impl CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchListRequestTournamentGames> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchListRequestTournamentGames,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchListRequestTournamentGames::new)
        }
    }

    // optional int32 eventid = 1;

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    pub fn get_eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }

    fn get_eventid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.eventid
    }

    fn mut_eventid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.eventid
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eventid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventid {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn new() -> CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        CMsgGCCStrike15_v2_MatchListRequestTournamentGames::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchListRequestTournamentGames>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "eventid",
                    CMsgGCCStrike15_v2_MatchListRequestTournamentGames::get_eventid_for_reflect,
                    CMsgGCCStrike15_v2_MatchListRequestTournamentGames::mut_eventid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchListRequestTournamentGames>(
                    "CMsgGCCStrike15_v2_MatchListRequestTournamentGames",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn clear(&mut self) {
        self.clear_eventid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    // message fields
    matchid: ::std::option::Option<u64>,
    outcomeid: ::std::option::Option<u64>,
    token: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {}

impl CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchListRequestFullGameInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchListRequestFullGameInfo,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::new)
        }
    }

    // optional uint64 matchid = 1;

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    pub fn get_matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    fn get_matchid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.matchid
    }

    fn mut_matchid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.matchid
    }

    // optional uint64 outcomeid = 2;

    pub fn clear_outcomeid(&mut self) {
        self.outcomeid = ::std::option::Option::None;
    }

    pub fn has_outcomeid(&self) -> bool {
        self.outcomeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outcomeid(&mut self, v: u64) {
        self.outcomeid = ::std::option::Option::Some(v);
    }

    pub fn get_outcomeid(&self) -> u64 {
        self.outcomeid.unwrap_or(0)
    }

    fn get_outcomeid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.outcomeid
    }

    fn mut_outcomeid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.outcomeid
    }

    // optional uint32 token = 3;

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }

    pub fn get_token(&self) -> u32 {
        self.token.unwrap_or(0)
    }

    fn get_token_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.token
    }

    fn mut_token_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.token
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.matchid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outcomeid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.outcomeid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.matchid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.outcomeid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.token {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn new() -> CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchListRequestFullGameInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "matchid",
                    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::get_matchid_for_reflect,
                    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::mut_matchid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "outcomeid",
                    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::get_outcomeid_for_reflect,
                    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::mut_outcomeid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "token",
                    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::get_token_for_reflect,
                    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::mut_token_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchListRequestFullGameInfo>(
                    "CMsgGCCStrike15_v2_MatchListRequestFullGameInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn clear(&mut self) {
        self.clear_matchid();
        self.clear_outcomeid();
        self.clear_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_MatchInfo {
    // message fields
    matchid: ::std::option::Option<u64>,
    matchtime: ::std::option::Option<u32>,
    watchablematchinfo: ::protobuf::SingularPtrField<WatchableMatchInfo>,
    roundstats_legacy: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>,
    roundstatsall: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDataGCCStrike15_v2_MatchInfo {}

impl CDataGCCStrike15_v2_MatchInfo {
    pub fn new() -> CDataGCCStrike15_v2_MatchInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDataGCCStrike15_v2_MatchInfo {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_MatchInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_MatchInfo,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_MatchInfo::new)
        }
    }

    // optional uint64 matchid = 1;

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    pub fn get_matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    fn get_matchid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.matchid
    }

    fn mut_matchid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.matchid
    }

    // optional uint32 matchtime = 2;

    pub fn clear_matchtime(&mut self) {
        self.matchtime = ::std::option::Option::None;
    }

    pub fn has_matchtime(&self) -> bool {
        self.matchtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchtime(&mut self, v: u32) {
        self.matchtime = ::std::option::Option::Some(v);
    }

    pub fn get_matchtime(&self) -> u32 {
        self.matchtime.unwrap_or(0)
    }

    fn get_matchtime_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.matchtime
    }

    fn mut_matchtime_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.matchtime
    }

    // optional .WatchableMatchInfo watchablematchinfo = 3;

    pub fn clear_watchablematchinfo(&mut self) {
        self.watchablematchinfo.clear();
    }

    pub fn has_watchablematchinfo(&self) -> bool {
        self.watchablematchinfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watchablematchinfo(&mut self, v: WatchableMatchInfo) {
        self.watchablematchinfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_watchablematchinfo(&mut self) -> &mut WatchableMatchInfo {
        if self.watchablematchinfo.is_none() {
            self.watchablematchinfo.set_default();
        }
        self.watchablematchinfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_watchablematchinfo(&mut self) -> WatchableMatchInfo {
        self.watchablematchinfo.take().unwrap_or_else(|| WatchableMatchInfo::new())
    }

    pub fn get_watchablematchinfo(&self) -> &WatchableMatchInfo {
        self.watchablematchinfo.as_ref().unwrap_or_else(|| WatchableMatchInfo::default_instance())
    }

    fn get_watchablematchinfo_for_reflect(&self) -> &::protobuf::SingularPtrField<WatchableMatchInfo> {
        &self.watchablematchinfo
    }

    fn mut_watchablematchinfo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<WatchableMatchInfo> {
        &mut self.watchablematchinfo
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundstats_legacy = 4;

    pub fn clear_roundstats_legacy(&mut self) {
        self.roundstats_legacy.clear();
    }

    pub fn has_roundstats_legacy(&self) -> bool {
        self.roundstats_legacy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roundstats_legacy(&mut self, v: CMsgGCCStrike15_v2_MatchmakingServerRoundStats) {
        self.roundstats_legacy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_roundstats_legacy(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        if self.roundstats_legacy.is_none() {
            self.roundstats_legacy.set_default();
        }
        self.roundstats_legacy.as_mut().unwrap()
    }

    // Take field
    pub fn take_roundstats_legacy(&mut self) -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        self.roundstats_legacy.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats::new())
    }

    pub fn get_roundstats_legacy(&self) -> &CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        self.roundstats_legacy.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats::default_instance())
    }

    fn get_roundstats_legacy_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> {
        &self.roundstats_legacy
    }

    fn mut_roundstats_legacy_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> {
        &mut self.roundstats_legacy
    }

    // repeated .CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundstatsall = 5;

    pub fn clear_roundstatsall(&mut self) {
        self.roundstatsall.clear();
    }

    // Param is passed by value, moved
    pub fn set_roundstatsall(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>) {
        self.roundstatsall = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roundstatsall(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> {
        &mut self.roundstatsall
    }

    // Take field
    pub fn take_roundstatsall(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> {
        ::std::mem::replace(&mut self.roundstatsall, ::protobuf::RepeatedField::new())
    }

    pub fn get_roundstatsall(&self) -> &[CMsgGCCStrike15_v2_MatchmakingServerRoundStats] {
        &self.roundstatsall
    }

    fn get_roundstatsall_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> {
        &self.roundstatsall
    }

    fn mut_roundstatsall_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> {
        &mut self.roundstatsall
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_MatchInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.watchablematchinfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.roundstats_legacy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.roundstatsall {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.matchid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchtime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.watchablematchinfo)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.roundstats_legacy)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.roundstatsall)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchtime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.watchablematchinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.roundstats_legacy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.roundstatsall {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.matchid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.matchtime {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.watchablematchinfo.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.roundstats_legacy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.roundstatsall {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDataGCCStrike15_v2_MatchInfo {
    fn new() -> CDataGCCStrike15_v2_MatchInfo {
        CDataGCCStrike15_v2_MatchInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDataGCCStrike15_v2_MatchInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "matchid",
                    CDataGCCStrike15_v2_MatchInfo::get_matchid_for_reflect,
                    CDataGCCStrike15_v2_MatchInfo::mut_matchid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matchtime",
                    CDataGCCStrike15_v2_MatchInfo::get_matchtime_for_reflect,
                    CDataGCCStrike15_v2_MatchInfo::mut_matchtime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WatchableMatchInfo>>(
                    "watchablematchinfo",
                    CDataGCCStrike15_v2_MatchInfo::get_watchablematchinfo_for_reflect,
                    CDataGCCStrike15_v2_MatchInfo::mut_watchablematchinfo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>>(
                    "roundstats_legacy",
                    CDataGCCStrike15_v2_MatchInfo::get_roundstats_legacy_for_reflect,
                    CDataGCCStrike15_v2_MatchInfo::mut_roundstats_legacy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>>(
                    "roundstatsall",
                    CDataGCCStrike15_v2_MatchInfo::get_roundstatsall_for_reflect,
                    CDataGCCStrike15_v2_MatchInfo::mut_roundstatsall_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_MatchInfo>(
                    "CDataGCCStrike15_v2_MatchInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_MatchInfo {
    fn clear(&mut self) {
        self.clear_matchid();
        self.clear_matchtime();
        self.clear_watchablematchinfo();
        self.clear_roundstats_legacy();
        self.clear_roundstatsall();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_MatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_MatchInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentGroupTeam {
    // message fields
    team_id: ::std::option::Option<i32>,
    score: ::std::option::Option<i32>,
    correctpick: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDataGCCStrike15_v2_TournamentGroupTeam {}

impl CDataGCCStrike15_v2_TournamentGroupTeam {
    pub fn new() -> CDataGCCStrike15_v2_TournamentGroupTeam {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentGroupTeam {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentGroupTeam> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentGroupTeam,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentGroupTeam::new)
        }
    }

    // optional int32 team_id = 1;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.team_id
    }

    // optional int32 score = 2;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> i32 {
        self.score.unwrap_or(0)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.score
    }

    // optional bool correctpick = 3;

    pub fn clear_correctpick(&mut self) {
        self.correctpick = ::std::option::Option::None;
    }

    pub fn has_correctpick(&self) -> bool {
        self.correctpick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correctpick(&mut self, v: bool) {
        self.correctpick = ::std::option::Option::Some(v);
    }

    pub fn get_correctpick(&self) -> bool {
        self.correctpick.unwrap_or(false)
    }

    fn get_correctpick_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.correctpick
    }

    fn mut_correctpick_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.correctpick
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.correctpick = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.correctpick {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.correctpick {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn new() -> CDataGCCStrike15_v2_TournamentGroupTeam {
        CDataGCCStrike15_v2_TournamentGroupTeam::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDataGCCStrike15_v2_TournamentGroupTeam>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id",
                    CDataGCCStrike15_v2_TournamentGroupTeam::get_team_id_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroupTeam::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "score",
                    CDataGCCStrike15_v2_TournamentGroupTeam::get_score_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroupTeam::mut_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "correctpick",
                    CDataGCCStrike15_v2_TournamentGroupTeam::get_correctpick_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroupTeam::mut_correctpick_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentGroupTeam>(
                    "CDataGCCStrike15_v2_TournamentGroupTeam",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn clear(&mut self) {
        self.clear_team_id();
        self.clear_score();
        self.clear_correctpick();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentGroup {
    // message fields
    groupid: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    desc: ::protobuf::SingularField<::std::string::String>,
    picks__deprecated: ::std::option::Option<u32>,
    teams: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroupTeam>,
    stage_ids: ::std::vec::Vec<i32>,
    picklockuntiltime: ::std::option::Option<u32>,
    pickableteams: ::std::option::Option<u32>,
    points_per_pick: ::std::option::Option<u32>,
    picks: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup_Picks>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDataGCCStrike15_v2_TournamentGroup {}

impl CDataGCCStrike15_v2_TournamentGroup {
    pub fn new() -> CDataGCCStrike15_v2_TournamentGroup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentGroup {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentGroup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentGroup,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentGroup::new)
        }
    }

    // optional uint32 groupid = 1;

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: u32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    pub fn get_groupid(&self) -> u32 {
        self.groupid.unwrap_or(0)
    }

    fn get_groupid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.groupid
    }

    fn mut_groupid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.groupid
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string desc = 3;

    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        if self.desc.is_none() {
            self.desc.set_default();
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        self.desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_desc(&self) -> &str {
        match self.desc.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_desc_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.desc
    }

    fn mut_desc_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.desc
    }

    // optional uint32 picks__deprecated = 4;

    pub fn clear_picks__deprecated(&mut self) {
        self.picks__deprecated = ::std::option::Option::None;
    }

    pub fn has_picks__deprecated(&self) -> bool {
        self.picks__deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_picks__deprecated(&mut self, v: u32) {
        self.picks__deprecated = ::std::option::Option::Some(v);
    }

    pub fn get_picks__deprecated(&self) -> u32 {
        self.picks__deprecated.unwrap_or(0)
    }

    fn get_picks__deprecated_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.picks__deprecated
    }

    fn mut_picks__deprecated_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.picks__deprecated
    }

    // repeated .CDataGCCStrike15_v2_TournamentGroupTeam teams = 5;

    pub fn clear_teams(&mut self) {
        self.teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_teams(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroupTeam>) {
        self.teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teams(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroupTeam> {
        &mut self.teams
    }

    // Take field
    pub fn take_teams(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroupTeam> {
        ::std::mem::replace(&mut self.teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_teams(&self) -> &[CDataGCCStrike15_v2_TournamentGroupTeam] {
        &self.teams
    }

    fn get_teams_for_reflect(&self) -> &::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroupTeam> {
        &self.teams
    }

    fn mut_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroupTeam> {
        &mut self.teams
    }

    // repeated int32 stage_ids = 6;

    pub fn clear_stage_ids(&mut self) {
        self.stage_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_stage_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.stage_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stage_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.stage_ids
    }

    // Take field
    pub fn take_stage_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.stage_ids, ::std::vec::Vec::new())
    }

    pub fn get_stage_ids(&self) -> &[i32] {
        &self.stage_ids
    }

    fn get_stage_ids_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.stage_ids
    }

    fn mut_stage_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.stage_ids
    }

    // optional uint32 picklockuntiltime = 7;

    pub fn clear_picklockuntiltime(&mut self) {
        self.picklockuntiltime = ::std::option::Option::None;
    }

    pub fn has_picklockuntiltime(&self) -> bool {
        self.picklockuntiltime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_picklockuntiltime(&mut self, v: u32) {
        self.picklockuntiltime = ::std::option::Option::Some(v);
    }

    pub fn get_picklockuntiltime(&self) -> u32 {
        self.picklockuntiltime.unwrap_or(0)
    }

    fn get_picklockuntiltime_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.picklockuntiltime
    }

    fn mut_picklockuntiltime_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.picklockuntiltime
    }

    // optional uint32 pickableteams = 8;

    pub fn clear_pickableteams(&mut self) {
        self.pickableteams = ::std::option::Option::None;
    }

    pub fn has_pickableteams(&self) -> bool {
        self.pickableteams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pickableteams(&mut self, v: u32) {
        self.pickableteams = ::std::option::Option::Some(v);
    }

    pub fn get_pickableteams(&self) -> u32 {
        self.pickableteams.unwrap_or(0)
    }

    fn get_pickableteams_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pickableteams
    }

    fn mut_pickableteams_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pickableteams
    }

    // optional uint32 points_per_pick = 9;

    pub fn clear_points_per_pick(&mut self) {
        self.points_per_pick = ::std::option::Option::None;
    }

    pub fn has_points_per_pick(&self) -> bool {
        self.points_per_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_per_pick(&mut self, v: u32) {
        self.points_per_pick = ::std::option::Option::Some(v);
    }

    pub fn get_points_per_pick(&self) -> u32 {
        self.points_per_pick.unwrap_or(0)
    }

    fn get_points_per_pick_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points_per_pick
    }

    fn mut_points_per_pick_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points_per_pick
    }

    // repeated .CDataGCCStrike15_v2_TournamentGroup.Picks picks = 10;

    pub fn clear_picks(&mut self) {
        self.picks.clear();
    }

    // Param is passed by value, moved
    pub fn set_picks(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup_Picks>) {
        self.picks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_picks(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup_Picks> {
        &mut self.picks
    }

    // Take field
    pub fn take_picks(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup_Picks> {
        ::std::mem::replace(&mut self.picks, ::protobuf::RepeatedField::new())
    }

    pub fn get_picks(&self) -> &[CDataGCCStrike15_v2_TournamentGroup_Picks] {
        &self.picks
    }

    fn get_picks_for_reflect(&self) -> &::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup_Picks> {
        &self.picks
    }

    fn mut_picks_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup_Picks> {
        &mut self.picks
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.teams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.picks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.groupid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.desc)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.picks__deprecated = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.teams)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.stage_ids)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.picklockuntiltime = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pickableteams = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_per_pick = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.picks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.desc.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.picks__deprecated {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.stage_ids {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.picklockuntiltime {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pickableteams {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_per_pick {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.picks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.groupid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.desc.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.picks__deprecated {
            os.write_uint32(4, v)?;
        }
        for v in &self.teams {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.stage_ids {
            os.write_int32(6, *v)?;
        };
        if let Some(v) = self.picklockuntiltime {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.pickableteams {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.points_per_pick {
            os.write_uint32(9, v)?;
        }
        for v in &self.picks {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDataGCCStrike15_v2_TournamentGroup {
    fn new() -> CDataGCCStrike15_v2_TournamentGroup {
        CDataGCCStrike15_v2_TournamentGroup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDataGCCStrike15_v2_TournamentGroup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "groupid",
                    CDataGCCStrike15_v2_TournamentGroup::get_groupid_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroup::mut_groupid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CDataGCCStrike15_v2_TournamentGroup::get_name_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroup::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "desc",
                    CDataGCCStrike15_v2_TournamentGroup::get_desc_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroup::mut_desc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "picks__deprecated",
                    CDataGCCStrike15_v2_TournamentGroup::get_picks__deprecated_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroup::mut_picks__deprecated_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentGroupTeam>>(
                    "teams",
                    CDataGCCStrike15_v2_TournamentGroup::get_teams_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroup::mut_teams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "stage_ids",
                    CDataGCCStrike15_v2_TournamentGroup::get_stage_ids_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroup::mut_stage_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "picklockuntiltime",
                    CDataGCCStrike15_v2_TournamentGroup::get_picklockuntiltime_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroup::mut_picklockuntiltime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pickableteams",
                    CDataGCCStrike15_v2_TournamentGroup::get_pickableteams_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroup::mut_pickableteams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points_per_pick",
                    CDataGCCStrike15_v2_TournamentGroup::get_points_per_pick_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroup::mut_points_per_pick_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentGroup_Picks>>(
                    "picks",
                    CDataGCCStrike15_v2_TournamentGroup::get_picks_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroup::mut_picks_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentGroup>(
                    "CDataGCCStrike15_v2_TournamentGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentGroup {
    fn clear(&mut self) {
        self.clear_groupid();
        self.clear_name();
        self.clear_desc();
        self.clear_picks__deprecated();
        self.clear_teams();
        self.clear_stage_ids();
        self.clear_picklockuntiltime();
        self.clear_pickableteams();
        self.clear_points_per_pick();
        self.clear_picks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentGroup_Picks {
    // message fields
    pickids: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDataGCCStrike15_v2_TournamentGroup_Picks {}

impl CDataGCCStrike15_v2_TournamentGroup_Picks {
    pub fn new() -> CDataGCCStrike15_v2_TournamentGroup_Picks {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentGroup_Picks {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentGroup_Picks> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentGroup_Picks,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentGroup_Picks::new)
        }
    }

    // repeated int32 pickids = 1;

    pub fn clear_pickids(&mut self) {
        self.pickids.clear();
    }

    // Param is passed by value, moved
    pub fn set_pickids(&mut self, v: ::std::vec::Vec<i32>) {
        self.pickids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pickids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.pickids
    }

    // Take field
    pub fn take_pickids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.pickids, ::std::vec::Vec::new())
    }

    pub fn get_pickids(&self) -> &[i32] {
        &self.pickids
    }

    fn get_pickids_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.pickids
    }

    fn mut_pickids_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.pickids
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentGroup_Picks {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.pickids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pickids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pickids {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDataGCCStrike15_v2_TournamentGroup_Picks {
    fn new() -> CDataGCCStrike15_v2_TournamentGroup_Picks {
        CDataGCCStrike15_v2_TournamentGroup_Picks::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDataGCCStrike15_v2_TournamentGroup_Picks>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pickids",
                    CDataGCCStrike15_v2_TournamentGroup_Picks::get_pickids_for_reflect,
                    CDataGCCStrike15_v2_TournamentGroup_Picks::mut_pickids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentGroup_Picks>(
                    "CDataGCCStrike15_v2_TournamentGroup_Picks",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentGroup_Picks {
    fn clear(&mut self) {
        self.clear_pickids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentGroup_Picks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentGroup_Picks {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentSection {
    // message fields
    sectionid: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    desc: ::protobuf::SingularField<::std::string::String>,
    groups: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDataGCCStrike15_v2_TournamentSection {}

impl CDataGCCStrike15_v2_TournamentSection {
    pub fn new() -> CDataGCCStrike15_v2_TournamentSection {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentSection {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentSection> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentSection,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentSection::new)
        }
    }

    // optional uint32 sectionid = 1;

    pub fn clear_sectionid(&mut self) {
        self.sectionid = ::std::option::Option::None;
    }

    pub fn has_sectionid(&self) -> bool {
        self.sectionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sectionid(&mut self, v: u32) {
        self.sectionid = ::std::option::Option::Some(v);
    }

    pub fn get_sectionid(&self) -> u32 {
        self.sectionid.unwrap_or(0)
    }

    fn get_sectionid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.sectionid
    }

    fn mut_sectionid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.sectionid
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string desc = 3;

    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        if self.desc.is_none() {
            self.desc.set_default();
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        self.desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_desc(&self) -> &str {
        match self.desc.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_desc_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.desc
    }

    fn mut_desc_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.desc
    }

    // repeated .CDataGCCStrike15_v2_TournamentGroup groups = 4;

    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }

    pub fn get_groups(&self) -> &[CDataGCCStrike15_v2_TournamentGroup] {
        &self.groups
    }

    fn get_groups_for_reflect(&self) -> &::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup> {
        &self.groups
    }

    fn mut_groups_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup> {
        &mut self.groups
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentSection {
    fn is_initialized(&self) -> bool {
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sectionid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.desc)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sectionid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.desc.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sectionid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.desc.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.groups {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDataGCCStrike15_v2_TournamentSection {
    fn new() -> CDataGCCStrike15_v2_TournamentSection {
        CDataGCCStrike15_v2_TournamentSection::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDataGCCStrike15_v2_TournamentSection>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sectionid",
                    CDataGCCStrike15_v2_TournamentSection::get_sectionid_for_reflect,
                    CDataGCCStrike15_v2_TournamentSection::mut_sectionid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CDataGCCStrike15_v2_TournamentSection::get_name_for_reflect,
                    CDataGCCStrike15_v2_TournamentSection::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "desc",
                    CDataGCCStrike15_v2_TournamentSection::get_desc_for_reflect,
                    CDataGCCStrike15_v2_TournamentSection::mut_desc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentGroup>>(
                    "groups",
                    CDataGCCStrike15_v2_TournamentSection::get_groups_for_reflect,
                    CDataGCCStrike15_v2_TournamentSection::mut_groups_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentSection>(
                    "CDataGCCStrike15_v2_TournamentSection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentSection {
    fn clear(&mut self) {
        self.clear_sectionid();
        self.clear_name();
        self.clear_desc();
        self.clear_groups();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentSection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentInfo {
    // message fields
    sections: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentSection>,
    tournament_event: ::protobuf::SingularPtrField<TournamentEvent>,
    tournament_teams: ::protobuf::RepeatedField<TournamentTeam>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDataGCCStrike15_v2_TournamentInfo {}

impl CDataGCCStrike15_v2_TournamentInfo {
    pub fn new() -> CDataGCCStrike15_v2_TournamentInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentInfo {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentInfo,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentInfo::new)
        }
    }

    // repeated .CDataGCCStrike15_v2_TournamentSection sections = 1;

    pub fn clear_sections(&mut self) {
        self.sections.clear();
    }

    // Param is passed by value, moved
    pub fn set_sections(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentSection>) {
        self.sections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sections(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentSection> {
        &mut self.sections
    }

    // Take field
    pub fn take_sections(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentSection> {
        ::std::mem::replace(&mut self.sections, ::protobuf::RepeatedField::new())
    }

    pub fn get_sections(&self) -> &[CDataGCCStrike15_v2_TournamentSection] {
        &self.sections
    }

    fn get_sections_for_reflect(&self) -> &::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentSection> {
        &self.sections
    }

    fn mut_sections_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentSection> {
        &mut self.sections
    }

    // optional .TournamentEvent tournament_event = 2;

    pub fn clear_tournament_event(&mut self) {
        self.tournament_event.clear();
    }

    pub fn has_tournament_event(&self) -> bool {
        self.tournament_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_event(&mut self, v: TournamentEvent) {
        self.tournament_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_event(&mut self) -> &mut TournamentEvent {
        if self.tournament_event.is_none() {
            self.tournament_event.set_default();
        }
        self.tournament_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournament_event(&mut self) -> TournamentEvent {
        self.tournament_event.take().unwrap_or_else(|| TournamentEvent::new())
    }

    pub fn get_tournament_event(&self) -> &TournamentEvent {
        self.tournament_event.as_ref().unwrap_or_else(|| TournamentEvent::default_instance())
    }

    fn get_tournament_event_for_reflect(&self) -> &::protobuf::SingularPtrField<TournamentEvent> {
        &self.tournament_event
    }

    fn mut_tournament_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TournamentEvent> {
        &mut self.tournament_event
    }

    // repeated .TournamentTeam tournament_teams = 3;

    pub fn clear_tournament_teams(&mut self) {
        self.tournament_teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_tournament_teams(&mut self, v: ::protobuf::RepeatedField<TournamentTeam>) {
        self.tournament_teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tournament_teams(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.tournament_teams
    }

    // Take field
    pub fn take_tournament_teams(&mut self) -> ::protobuf::RepeatedField<TournamentTeam> {
        ::std::mem::replace(&mut self.tournament_teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_tournament_teams(&self) -> &[TournamentTeam] {
        &self.tournament_teams
    }

    fn get_tournament_teams_for_reflect(&self) -> &::protobuf::RepeatedField<TournamentTeam> {
        &self.tournament_teams
    }

    fn mut_tournament_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.tournament_teams
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.sections {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tournament_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tournament_teams {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sections)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tournament_event)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tournament_teams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.tournament_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tournament_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sections {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.tournament_event.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tournament_teams {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDataGCCStrike15_v2_TournamentInfo {
    fn new() -> CDataGCCStrike15_v2_TournamentInfo {
        CDataGCCStrike15_v2_TournamentInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDataGCCStrike15_v2_TournamentInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentSection>>(
                    "sections",
                    CDataGCCStrike15_v2_TournamentInfo::get_sections_for_reflect,
                    CDataGCCStrike15_v2_TournamentInfo::mut_sections_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentEvent>>(
                    "tournament_event",
                    CDataGCCStrike15_v2_TournamentInfo::get_tournament_event_for_reflect,
                    CDataGCCStrike15_v2_TournamentInfo::mut_tournament_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentTeam>>(
                    "tournament_teams",
                    CDataGCCStrike15_v2_TournamentInfo::get_tournament_teams_for_reflect,
                    CDataGCCStrike15_v2_TournamentInfo::mut_tournament_teams_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentInfo>(
                    "CDataGCCStrike15_v2_TournamentInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentInfo {
    fn clear(&mut self) {
        self.clear_sections();
        self.clear_tournament_event();
        self.clear_tournament_teams();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchList {
    // message fields
    msgrequestid: ::std::option::Option<u32>,
    accountid: ::std::option::Option<u32>,
    servertime: ::std::option::Option<u32>,
    matches: ::protobuf::RepeatedField<CDataGCCStrike15_v2_MatchInfo>,
    streams: ::protobuf::RepeatedField<TournamentTeam>,
    tournamentinfo: ::protobuf::SingularPtrField<CDataGCCStrike15_v2_TournamentInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_MatchList {}

impl CMsgGCCStrike15_v2_MatchList {
    pub fn new() -> CMsgGCCStrike15_v2_MatchList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchList,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchList::new)
        }
    }

    // optional uint32 msgrequestid = 1;

    pub fn clear_msgrequestid(&mut self) {
        self.msgrequestid = ::std::option::Option::None;
    }

    pub fn has_msgrequestid(&self) -> bool {
        self.msgrequestid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgrequestid(&mut self, v: u32) {
        self.msgrequestid = ::std::option::Option::Some(v);
    }

    pub fn get_msgrequestid(&self) -> u32 {
        self.msgrequestid.unwrap_or(0)
    }

    fn get_msgrequestid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.msgrequestid
    }

    fn mut_msgrequestid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.msgrequestid
    }

    // optional uint32 accountid = 2;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }

    // optional uint32 servertime = 3;

    pub fn clear_servertime(&mut self) {
        self.servertime = ::std::option::Option::None;
    }

    pub fn has_servertime(&self) -> bool {
        self.servertime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servertime(&mut self, v: u32) {
        self.servertime = ::std::option::Option::Some(v);
    }

    pub fn get_servertime(&self) -> u32 {
        self.servertime.unwrap_or(0)
    }

    fn get_servertime_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.servertime
    }

    fn mut_servertime_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.servertime
    }

    // repeated .CDataGCCStrike15_v2_MatchInfo matches = 4;

    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_MatchInfo>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_MatchInfo> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_MatchInfo> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }

    pub fn get_matches(&self) -> &[CDataGCCStrike15_v2_MatchInfo] {
        &self.matches
    }

    fn get_matches_for_reflect(&self) -> &::protobuf::RepeatedField<CDataGCCStrike15_v2_MatchInfo> {
        &self.matches
    }

    fn mut_matches_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_MatchInfo> {
        &mut self.matches
    }

    // repeated .TournamentTeam streams = 5;

    pub fn clear_streams(&mut self) {
        self.streams.clear();
    }

    // Param is passed by value, moved
    pub fn set_streams(&mut self, v: ::protobuf::RepeatedField<TournamentTeam>) {
        self.streams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_streams(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.streams
    }

    // Take field
    pub fn take_streams(&mut self) -> ::protobuf::RepeatedField<TournamentTeam> {
        ::std::mem::replace(&mut self.streams, ::protobuf::RepeatedField::new())
    }

    pub fn get_streams(&self) -> &[TournamentTeam] {
        &self.streams
    }

    fn get_streams_for_reflect(&self) -> &::protobuf::RepeatedField<TournamentTeam> {
        &self.streams
    }

    fn mut_streams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.streams
    }

    // optional .CDataGCCStrike15_v2_TournamentInfo tournamentinfo = 6;

    pub fn clear_tournamentinfo(&mut self) {
        self.tournamentinfo.clear();
    }

    pub fn has_tournamentinfo(&self) -> bool {
        self.tournamentinfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournamentinfo(&mut self, v: CDataGCCStrike15_v2_TournamentInfo) {
        self.tournamentinfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournamentinfo(&mut self) -> &mut CDataGCCStrike15_v2_TournamentInfo {
        if self.tournamentinfo.is_none() {
            self.tournamentinfo.set_default();
        }
        self.tournamentinfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournamentinfo(&mut self) -> CDataGCCStrike15_v2_TournamentInfo {
        self.tournamentinfo.take().unwrap_or_else(|| CDataGCCStrike15_v2_TournamentInfo::new())
    }

    pub fn get_tournamentinfo(&self) -> &CDataGCCStrike15_v2_TournamentInfo {
        self.tournamentinfo.as_ref().unwrap_or_else(|| CDataGCCStrike15_v2_TournamentInfo::default_instance())
    }

    fn get_tournamentinfo_for_reflect(&self) -> &::protobuf::SingularPtrField<CDataGCCStrike15_v2_TournamentInfo> {
        &self.tournamentinfo
    }

    fn mut_tournamentinfo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDataGCCStrike15_v2_TournamentInfo> {
        &mut self.tournamentinfo
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchList {
    fn is_initialized(&self) -> bool {
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.streams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tournamentinfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.msgrequestid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.servertime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.streams)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tournamentinfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msgrequestid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.servertime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.tournamentinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msgrequestid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.servertime {
            os.write_uint32(3, v)?;
        }
        for v in &self.matches {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.streams {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.tournamentinfo.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_MatchList {
    fn new() -> CMsgGCCStrike15_v2_MatchList {
        CMsgGCCStrike15_v2_MatchList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_MatchList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "msgrequestid",
                    CMsgGCCStrike15_v2_MatchList::get_msgrequestid_for_reflect,
                    CMsgGCCStrike15_v2_MatchList::mut_msgrequestid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgGCCStrike15_v2_MatchList::get_accountid_for_reflect,
                    CMsgGCCStrike15_v2_MatchList::mut_accountid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "servertime",
                    CMsgGCCStrike15_v2_MatchList::get_servertime_for_reflect,
                    CMsgGCCStrike15_v2_MatchList::mut_servertime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_MatchInfo>>(
                    "matches",
                    CMsgGCCStrike15_v2_MatchList::get_matches_for_reflect,
                    CMsgGCCStrike15_v2_MatchList::mut_matches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentTeam>>(
                    "streams",
                    CMsgGCCStrike15_v2_MatchList::get_streams_for_reflect,
                    CMsgGCCStrike15_v2_MatchList::mut_streams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentInfo>>(
                    "tournamentinfo",
                    CMsgGCCStrike15_v2_MatchList::get_tournamentinfo_for_reflect,
                    CMsgGCCStrike15_v2_MatchList::mut_tournamentinfo_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchList>(
                    "CMsgGCCStrike15_v2_MatchList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchList {
    fn clear(&mut self) {
        self.clear_msgrequestid();
        self.clear_accountid();
        self.clear_servertime();
        self.clear_matches();
        self.clear_streams();
        self.clear_tournamentinfo();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Predictions {
    // message fields
    event_id: ::std::option::Option<u32>,
    group_match_team_picks: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Predictions {}

impl CMsgGCCStrike15_v2_Predictions {
    pub fn new() -> CMsgGCCStrike15_v2_Predictions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Predictions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Predictions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Predictions,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Predictions::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // repeated .CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick group_match_team_picks = 2;

    pub fn clear_group_match_team_picks(&mut self) {
        self.group_match_team_picks.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_match_team_picks(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick>) {
        self.group_match_team_picks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_group_match_team_picks(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick> {
        &mut self.group_match_team_picks
    }

    // Take field
    pub fn take_group_match_team_picks(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick> {
        ::std::mem::replace(&mut self.group_match_team_picks, ::protobuf::RepeatedField::new())
    }

    pub fn get_group_match_team_picks(&self) -> &[CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick] {
        &self.group_match_team_picks
    }

    fn get_group_match_team_picks_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick> {
        &self.group_match_team_picks
    }

    fn mut_group_match_team_picks_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick> {
        &mut self.group_match_team_picks
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Predictions {
    fn is_initialized(&self) -> bool {
        for v in &self.group_match_team_picks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.group_match_team_picks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.group_match_team_picks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.group_match_team_picks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Predictions {
    fn new() -> CMsgGCCStrike15_v2_Predictions {
        CMsgGCCStrike15_v2_Predictions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Predictions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgGCCStrike15_v2_Predictions::get_event_id_for_reflect,
                    CMsgGCCStrike15_v2_Predictions::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick>>(
                    "group_match_team_picks",
                    CMsgGCCStrike15_v2_Predictions::get_group_match_team_picks_for_reflect,
                    CMsgGCCStrike15_v2_Predictions::mut_group_match_team_picks_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Predictions>(
                    "CMsgGCCStrike15_v2_Predictions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Predictions {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_group_match_team_picks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Predictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Predictions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    // message fields
    sectionid: ::std::option::Option<i32>,
    groupid: ::std::option::Option<i32>,
    index: ::std::option::Option<i32>,
    teamid: ::std::option::Option<i32>,
    itemid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {}

impl CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    pub fn new() -> CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::new)
        }
    }

    // optional int32 sectionid = 1;

    pub fn clear_sectionid(&mut self) {
        self.sectionid = ::std::option::Option::None;
    }

    pub fn has_sectionid(&self) -> bool {
        self.sectionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sectionid(&mut self, v: i32) {
        self.sectionid = ::std::option::Option::Some(v);
    }

    pub fn get_sectionid(&self) -> i32 {
        self.sectionid.unwrap_or(0)
    }

    fn get_sectionid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.sectionid
    }

    fn mut_sectionid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.sectionid
    }

    // optional int32 groupid = 2;

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    fn get_groupid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.groupid
    }

    fn mut_groupid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.groupid
    }

    // optional int32 index = 3;

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    fn get_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.index
    }

    fn mut_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.index
    }

    // optional int32 teamid = 4;

    pub fn clear_teamid(&mut self) {
        self.teamid = ::std::option::Option::None;
    }

    pub fn has_teamid(&self) -> bool {
        self.teamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teamid(&mut self, v: i32) {
        self.teamid = ::std::option::Option::Some(v);
    }

    pub fn get_teamid(&self) -> i32 {
        self.teamid.unwrap_or(0)
    }

    fn get_teamid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.teamid
    }

    fn mut_teamid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.teamid
    }

    // optional uint64 itemid = 5;

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    pub fn get_itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }

    fn get_itemid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.itemid
    }

    fn mut_itemid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.itemid
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sectionid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.groupid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.teamid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sectionid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.teamid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sectionid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.groupid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.teamid {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.itemid {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    fn new() -> CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
        CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sectionid",
                    CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::get_sectionid_for_reflect,
                    CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::mut_sectionid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "groupid",
                    CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::get_groupid_for_reflect,
                    CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::mut_groupid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "index",
                    CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::get_index_for_reflect,
                    CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::mut_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "teamid",
                    CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::get_teamid_for_reflect,
                    CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::mut_teamid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "itemid",
                    CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::get_itemid_for_reflect,
                    CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::mut_itemid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick>(
                    "CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    fn clear(&mut self) {
        self.clear_sectionid();
        self.clear_groupid();
        self.clear_index();
        self.clear_teamid();
        self.clear_itemid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Fantasy {
    // message fields
    event_id: ::std::option::Option<u32>,
    teams: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasyTeam>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Fantasy {}

impl CMsgGCCStrike15_v2_Fantasy {
    pub fn new() -> CMsgGCCStrike15_v2_Fantasy {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Fantasy {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Fantasy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Fantasy,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Fantasy::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // repeated .CMsgGCCStrike15_v2_Fantasy.FantasyTeam teams = 2;

    pub fn clear_teams(&mut self) {
        self.teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_teams(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasyTeam>) {
        self.teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teams(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasyTeam> {
        &mut self.teams
    }

    // Take field
    pub fn take_teams(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasyTeam> {
        ::std::mem::replace(&mut self.teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_teams(&self) -> &[CMsgGCCStrike15_v2_Fantasy_FantasyTeam] {
        &self.teams
    }

    fn get_teams_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasyTeam> {
        &self.teams
    }

    fn mut_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasyTeam> {
        &mut self.teams
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Fantasy {
    fn is_initialized(&self) -> bool {
        for v in &self.teams {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.teams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.teams {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Fantasy {
    fn new() -> CMsgGCCStrike15_v2_Fantasy {
        CMsgGCCStrike15_v2_Fantasy::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Fantasy>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgGCCStrike15_v2_Fantasy::get_event_id_for_reflect,
                    CMsgGCCStrike15_v2_Fantasy::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_Fantasy_FantasyTeam>>(
                    "teams",
                    CMsgGCCStrike15_v2_Fantasy::get_teams_for_reflect,
                    CMsgGCCStrike15_v2_Fantasy::mut_teams_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Fantasy>(
                    "CMsgGCCStrike15_v2_Fantasy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Fantasy {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_teams();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Fantasy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Fantasy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    // message fields
    field_type: ::std::option::Option<i32>,
    pick: ::std::option::Option<i32>,
    itemid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Fantasy_FantasySlot {}

impl CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    pub fn new() -> CMsgGCCStrike15_v2_Fantasy_FantasySlot {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Fantasy_FantasySlot {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Fantasy_FantasySlot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Fantasy_FantasySlot,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Fantasy_FantasySlot::new)
        }
    }

    // optional int32 type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.field_type
    }

    // optional int32 pick = 2;

    pub fn clear_pick(&mut self) {
        self.pick = ::std::option::Option::None;
    }

    pub fn has_pick(&self) -> bool {
        self.pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pick(&mut self, v: i32) {
        self.pick = ::std::option::Option::Some(v);
    }

    pub fn get_pick(&self) -> i32 {
        self.pick.unwrap_or(0)
    }

    fn get_pick_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.pick
    }

    fn mut_pick_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.pick
    }

    // optional uint64 itemid = 3;

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    pub fn get_itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }

    fn get_itemid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.itemid
    }

    fn mut_itemid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.itemid
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pick = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pick {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pick {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.itemid {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    fn new() -> CMsgGCCStrike15_v2_Fantasy_FantasySlot {
        CMsgGCCStrike15_v2_Fantasy_FantasySlot::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Fantasy_FantasySlot>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type",
                    CMsgGCCStrike15_v2_Fantasy_FantasySlot::get_field_type_for_reflect,
                    CMsgGCCStrike15_v2_Fantasy_FantasySlot::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pick",
                    CMsgGCCStrike15_v2_Fantasy_FantasySlot::get_pick_for_reflect,
                    CMsgGCCStrike15_v2_Fantasy_FantasySlot::mut_pick_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "itemid",
                    CMsgGCCStrike15_v2_Fantasy_FantasySlot::get_itemid_for_reflect,
                    CMsgGCCStrike15_v2_Fantasy_FantasySlot::mut_itemid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Fantasy_FantasySlot>(
                    "CMsgGCCStrike15_v2_Fantasy_FantasySlot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_pick();
        self.clear_itemid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    // message fields
    sectionid: ::std::option::Option<i32>,
    slots: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasySlot>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Fantasy_FantasyTeam {}

impl CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    pub fn new() -> CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Fantasy_FantasyTeam> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Fantasy_FantasyTeam,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Fantasy_FantasyTeam::new)
        }
    }

    // optional int32 sectionid = 1;

    pub fn clear_sectionid(&mut self) {
        self.sectionid = ::std::option::Option::None;
    }

    pub fn has_sectionid(&self) -> bool {
        self.sectionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sectionid(&mut self, v: i32) {
        self.sectionid = ::std::option::Option::Some(v);
    }

    pub fn get_sectionid(&self) -> i32 {
        self.sectionid.unwrap_or(0)
    }

    fn get_sectionid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.sectionid
    }

    fn mut_sectionid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.sectionid
    }

    // repeated .CMsgGCCStrike15_v2_Fantasy.FantasySlot slots = 2;

    pub fn clear_slots(&mut self) {
        self.slots.clear();
    }

    // Param is passed by value, moved
    pub fn set_slots(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasySlot>) {
        self.slots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_slots(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasySlot> {
        &mut self.slots
    }

    // Take field
    pub fn take_slots(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasySlot> {
        ::std::mem::replace(&mut self.slots, ::protobuf::RepeatedField::new())
    }

    pub fn get_slots(&self) -> &[CMsgGCCStrike15_v2_Fantasy_FantasySlot] {
        &self.slots
    }

    fn get_slots_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasySlot> {
        &self.slots
    }

    fn mut_slots_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasySlot> {
        &mut self.slots
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    fn is_initialized(&self) -> bool {
        for v in &self.slots {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sectionid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.slots)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sectionid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sectionid {
            os.write_int32(1, v)?;
        }
        for v in &self.slots {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    fn new() -> CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
        CMsgGCCStrike15_v2_Fantasy_FantasyTeam::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Fantasy_FantasyTeam>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sectionid",
                    CMsgGCCStrike15_v2_Fantasy_FantasyTeam::get_sectionid_for_reflect,
                    CMsgGCCStrike15_v2_Fantasy_FantasyTeam::mut_sectionid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_Fantasy_FantasySlot>>(
                    "slots",
                    CMsgGCCStrike15_v2_Fantasy_FantasyTeam::get_slots_for_reflect,
                    CMsgGCCStrike15_v2_Fantasy_FantasyTeam::mut_slots_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Fantasy_FantasyTeam>(
                    "CMsgGCCStrike15_v2_Fantasy_FantasyTeam",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    fn clear(&mut self) {
        self.clear_sectionid();
        self.clear_slots();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAttribute_String {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CAttribute_String {}

impl CAttribute_String {
    pub fn new() -> CAttribute_String {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CAttribute_String {
        static mut instance: ::protobuf::lazy::Lazy<CAttribute_String> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CAttribute_String,
        };
        unsafe {
            instance.get(CAttribute_String::new)
        }
    }

    // optional string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for CAttribute_String {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CAttribute_String {
    fn new() -> CAttribute_String {
        CAttribute_String::new()
    }

    fn descriptor_static(_: ::std::option::Option<CAttribute_String>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    CAttribute_String::get_value_for_reflect,
                    CAttribute_String::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CAttribute_String>(
                    "CAttribute_String",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CAttribute_String {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAttribute_String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_String {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCReloadVersions {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCReloadVersions {}

impl CMsgGCToGCReloadVersions {
    pub fn new() -> CMsgGCToGCReloadVersions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCReloadVersions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCReloadVersions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCReloadVersions,
        };
        unsafe {
            instance.get(CMsgGCToGCReloadVersions::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCToGCReloadVersions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCReloadVersions {
    fn new() -> CMsgGCToGCReloadVersions {
        CMsgGCToGCReloadVersions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCReloadVersions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCReloadVersions>(
                    "CMsgGCToGCReloadVersions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCReloadVersions {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCReloadVersions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCReloadVersions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCStrike15Welcome {
    // message fields
    store_item_hash: ::std::option::Option<u32>,
    timeplayedconsecutively: ::std::option::Option<u32>,
    time_first_played: ::std::option::Option<u32>,
    last_time_played: ::std::option::Option<u32>,
    last_ip_address: ::std::option::Option<u32>,
    gscookieid: ::std::option::Option<u64>,
    uniqueid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgCStrike15Welcome {}

impl CMsgCStrike15Welcome {
    pub fn new() -> CMsgCStrike15Welcome {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgCStrike15Welcome {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCStrike15Welcome> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCStrike15Welcome,
        };
        unsafe {
            instance.get(CMsgCStrike15Welcome::new)
        }
    }

    // optional uint32 store_item_hash = 5;

    pub fn clear_store_item_hash(&mut self) {
        self.store_item_hash = ::std::option::Option::None;
    }

    pub fn has_store_item_hash(&self) -> bool {
        self.store_item_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_item_hash(&mut self, v: u32) {
        self.store_item_hash = ::std::option::Option::Some(v);
    }

    pub fn get_store_item_hash(&self) -> u32 {
        self.store_item_hash.unwrap_or(0)
    }

    fn get_store_item_hash_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.store_item_hash
    }

    fn mut_store_item_hash_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.store_item_hash
    }

    // optional uint32 timeplayedconsecutively = 6;

    pub fn clear_timeplayedconsecutively(&mut self) {
        self.timeplayedconsecutively = ::std::option::Option::None;
    }

    pub fn has_timeplayedconsecutively(&self) -> bool {
        self.timeplayedconsecutively.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeplayedconsecutively(&mut self, v: u32) {
        self.timeplayedconsecutively = ::std::option::Option::Some(v);
    }

    pub fn get_timeplayedconsecutively(&self) -> u32 {
        self.timeplayedconsecutively.unwrap_or(0)
    }

    fn get_timeplayedconsecutively_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timeplayedconsecutively
    }

    fn mut_timeplayedconsecutively_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timeplayedconsecutively
    }

    // optional uint32 time_first_played = 10;

    pub fn clear_time_first_played(&mut self) {
        self.time_first_played = ::std::option::Option::None;
    }

    pub fn has_time_first_played(&self) -> bool {
        self.time_first_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_first_played(&mut self, v: u32) {
        self.time_first_played = ::std::option::Option::Some(v);
    }

    pub fn get_time_first_played(&self) -> u32 {
        self.time_first_played.unwrap_or(0)
    }

    fn get_time_first_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_first_played
    }

    fn mut_time_first_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_first_played
    }

    // optional uint32 last_time_played = 12;

    pub fn clear_last_time_played(&mut self) {
        self.last_time_played = ::std::option::Option::None;
    }

    pub fn has_last_time_played(&self) -> bool {
        self.last_time_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_played(&mut self, v: u32) {
        self.last_time_played = ::std::option::Option::Some(v);
    }

    pub fn get_last_time_played(&self) -> u32 {
        self.last_time_played.unwrap_or(0)
    }

    fn get_last_time_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_time_played
    }

    fn mut_last_time_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_time_played
    }

    // optional uint32 last_ip_address = 13;

    pub fn clear_last_ip_address(&mut self) {
        self.last_ip_address = ::std::option::Option::None;
    }

    pub fn has_last_ip_address(&self) -> bool {
        self.last_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ip_address(&mut self, v: u32) {
        self.last_ip_address = ::std::option::Option::Some(v);
    }

    pub fn get_last_ip_address(&self) -> u32 {
        self.last_ip_address.unwrap_or(0)
    }

    fn get_last_ip_address_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_ip_address
    }

    fn mut_last_ip_address_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_ip_address
    }

    // optional uint64 gscookieid = 18;

    pub fn clear_gscookieid(&mut self) {
        self.gscookieid = ::std::option::Option::None;
    }

    pub fn has_gscookieid(&self) -> bool {
        self.gscookieid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gscookieid(&mut self, v: u64) {
        self.gscookieid = ::std::option::Option::Some(v);
    }

    pub fn get_gscookieid(&self) -> u64 {
        self.gscookieid.unwrap_or(0)
    }

    fn get_gscookieid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.gscookieid
    }

    fn mut_gscookieid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.gscookieid
    }

    // optional uint64 uniqueid = 19;

    pub fn clear_uniqueid(&mut self) {
        self.uniqueid = ::std::option::Option::None;
    }

    pub fn has_uniqueid(&self) -> bool {
        self.uniqueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uniqueid(&mut self, v: u64) {
        self.uniqueid = ::std::option::Option::Some(v);
    }

    pub fn get_uniqueid(&self) -> u64 {
        self.uniqueid.unwrap_or(0)
    }

    fn get_uniqueid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.uniqueid
    }

    fn mut_uniqueid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.uniqueid
    }
}

impl ::protobuf::Message for CMsgCStrike15Welcome {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.store_item_hash = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeplayedconsecutively = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_first_played = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_time_played = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_ip_address = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gscookieid = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uniqueid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.store_item_hash {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeplayedconsecutively {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_first_played {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_time_played {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_ip_address {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gscookieid {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.uniqueid {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.store_item_hash {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.timeplayedconsecutively {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.time_first_played {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.last_time_played {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.last_ip_address {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.gscookieid {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.uniqueid {
            os.write_uint64(19, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgCStrike15Welcome {
    fn new() -> CMsgCStrike15Welcome {
        CMsgCStrike15Welcome::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgCStrike15Welcome>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "store_item_hash",
                    CMsgCStrike15Welcome::get_store_item_hash_for_reflect,
                    CMsgCStrike15Welcome::mut_store_item_hash_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timeplayedconsecutively",
                    CMsgCStrike15Welcome::get_timeplayedconsecutively_for_reflect,
                    CMsgCStrike15Welcome::mut_timeplayedconsecutively_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_first_played",
                    CMsgCStrike15Welcome::get_time_first_played_for_reflect,
                    CMsgCStrike15Welcome::mut_time_first_played_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_time_played",
                    CMsgCStrike15Welcome::get_last_time_played_for_reflect,
                    CMsgCStrike15Welcome::mut_last_time_played_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_ip_address",
                    CMsgCStrike15Welcome::get_last_ip_address_for_reflect,
                    CMsgCStrike15Welcome::mut_last_ip_address_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gscookieid",
                    CMsgCStrike15Welcome::get_gscookieid_for_reflect,
                    CMsgCStrike15Welcome::mut_gscookieid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "uniqueid",
                    CMsgCStrike15Welcome::get_uniqueid_for_reflect,
                    CMsgCStrike15Welcome::mut_uniqueid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCStrike15Welcome>(
                    "CMsgCStrike15Welcome",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgCStrike15Welcome {
    fn clear(&mut self) {
        self.clear_store_item_hash();
        self.clear_timeplayedconsecutively();
        self.clear_time_first_played();
        self.clear_last_time_played();
        self.clear_last_ip_address();
        self.clear_gscookieid();
        self.clear_uniqueid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCStrike15Welcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCStrike15Welcome {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    // message fields
    value_name: ::protobuf::SingularField<::std::string::String>,
    value_int: ::std::option::Option<i32>,
    server_addr: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    choked_blocks: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {}

impl CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    pub fn new() -> CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientVarValueNotificationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientVarValueNotificationInfo,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::new)
        }
    }

    // optional string value_name = 1;

    pub fn clear_value_name(&mut self) {
        self.value_name.clear();
    }

    pub fn has_value_name(&self) -> bool {
        self.value_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_name(&mut self, v: ::std::string::String) {
        self.value_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_name(&mut self) -> &mut ::std::string::String {
        if self.value_name.is_none() {
            self.value_name.set_default();
        }
        self.value_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_name(&mut self) -> ::std::string::String {
        self.value_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value_name(&self) -> &str {
        match self.value_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value_name
    }

    fn mut_value_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value_name
    }

    // optional int32 value_int = 2;

    pub fn clear_value_int(&mut self) {
        self.value_int = ::std::option::Option::None;
    }

    pub fn has_value_int(&self) -> bool {
        self.value_int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_int(&mut self, v: i32) {
        self.value_int = ::std::option::Option::Some(v);
    }

    pub fn get_value_int(&self) -> i32 {
        self.value_int.unwrap_or(0)
    }

    fn get_value_int_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.value_int
    }

    fn mut_value_int_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.value_int
    }

    // optional uint32 server_addr = 3;

    pub fn clear_server_addr(&mut self) {
        self.server_addr = ::std::option::Option::None;
    }

    pub fn has_server_addr(&self) -> bool {
        self.server_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_addr(&mut self, v: u32) {
        self.server_addr = ::std::option::Option::Some(v);
    }

    pub fn get_server_addr(&self) -> u32 {
        self.server_addr.unwrap_or(0)
    }

    fn get_server_addr_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_addr
    }

    fn mut_server_addr_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_addr
    }

    // optional uint32 server_port = 4;

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    fn get_server_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_port
    }

    fn mut_server_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_port
    }

    // repeated string choked_blocks = 5;

    pub fn clear_choked_blocks(&mut self) {
        self.choked_blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_choked_blocks(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.choked_blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_choked_blocks(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.choked_blocks
    }

    // Take field
    pub fn take_choked_blocks(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.choked_blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_choked_blocks(&self) -> &[::std::string::String] {
        &self.choked_blocks
    }

    fn get_choked_blocks_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.choked_blocks
    }

    fn mut_choked_blocks_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.choked_blocks
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value_int = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_addr = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.choked_blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value_int {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_addr {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.choked_blocks {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.value_int {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.server_addr {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(4, v)?;
        }
        for v in &self.choked_blocks {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn new() -> CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientVarValueNotificationInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value_name",
                    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::get_value_name_for_reflect,
                    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::mut_value_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value_int",
                    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::get_value_int_for_reflect,
                    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::mut_value_int_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_addr",
                    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::get_server_addr_for_reflect,
                    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::mut_server_addr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_port",
                    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::get_server_port_for_reflect,
                    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::mut_server_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "choked_blocks",
                    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::get_choked_blocks_for_reflect,
                    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::mut_choked_blocks_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientVarValueNotificationInfo>(
                    "CMsgGCCStrike15_v2_ClientVarValueNotificationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn clear(&mut self) {
        self.clear_value_name();
        self.clear_value_int();
        self.clear_server_addr();
        self.clear_server_port();
        self.clear_choked_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    // message fields
    accountid: ::std::option::Option<u32>,
    viewangles: ::std::vec::Vec<u32>,
    field_type: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {}

impl CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    pub fn new() -> CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ServerVarValueNotificationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ServerVarValueNotificationInfo,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }

    // repeated uint32 viewangles = 2;

    pub fn clear_viewangles(&mut self) {
        self.viewangles.clear();
    }

    // Param is passed by value, moved
    pub fn set_viewangles(&mut self, v: ::std::vec::Vec<u32>) {
        self.viewangles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_viewangles(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.viewangles
    }

    // Take field
    pub fn take_viewangles(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.viewangles, ::std::vec::Vec::new())
    }

    pub fn get_viewangles(&self) -> &[u32] {
        &self.viewangles
    }

    fn get_viewangles_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.viewangles
    }

    fn mut_viewangles_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.viewangles
    }

    // optional uint32 type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.field_type
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.viewangles)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.viewangles {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        for v in &self.viewangles {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.field_type {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn new() -> CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ServerVarValueNotificationInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::get_accountid_for_reflect,
                    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::mut_accountid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "viewangles",
                    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::get_viewangles_for_reflect,
                    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::mut_viewangles_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::get_field_type_for_reflect,
                    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::mut_field_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ServerVarValueNotificationInfo>(
                    "CMsgGCCStrike15_v2_ServerVarValueNotificationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn clear(&mut self) {
        self.clear_accountid();
        self.clear_viewangles();
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {}

impl CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    pub fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GiftsLeaderboardRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GiftsLeaderboardRequest,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GiftsLeaderboardRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        CMsgGCCStrike15_v2_GiftsLeaderboardRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_GiftsLeaderboardRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GiftsLeaderboardRequest>(
                    "CMsgGCCStrike15_v2_GiftsLeaderboardRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    // message fields
    servertime: ::std::option::Option<u32>,
    time_period_seconds: ::std::option::Option<u32>,
    total_gifts_given: ::std::option::Option<u32>,
    total_givers: ::std::option::Option<u32>,
    entries: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {}

impl CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    pub fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GiftsLeaderboardResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GiftsLeaderboardResponse,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GiftsLeaderboardResponse::new)
        }
    }

    // optional uint32 servertime = 1;

    pub fn clear_servertime(&mut self) {
        self.servertime = ::std::option::Option::None;
    }

    pub fn has_servertime(&self) -> bool {
        self.servertime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servertime(&mut self, v: u32) {
        self.servertime = ::std::option::Option::Some(v);
    }

    pub fn get_servertime(&self) -> u32 {
        self.servertime.unwrap_or(0)
    }

    fn get_servertime_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.servertime
    }

    fn mut_servertime_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.servertime
    }

    // optional uint32 time_period_seconds = 2;

    pub fn clear_time_period_seconds(&mut self) {
        self.time_period_seconds = ::std::option::Option::None;
    }

    pub fn has_time_period_seconds(&self) -> bool {
        self.time_period_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_period_seconds(&mut self, v: u32) {
        self.time_period_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_time_period_seconds(&self) -> u32 {
        self.time_period_seconds.unwrap_or(0)
    }

    fn get_time_period_seconds_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_period_seconds
    }

    fn mut_time_period_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_period_seconds
    }

    // optional uint32 total_gifts_given = 3;

    pub fn clear_total_gifts_given(&mut self) {
        self.total_gifts_given = ::std::option::Option::None;
    }

    pub fn has_total_gifts_given(&self) -> bool {
        self.total_gifts_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_gifts_given(&mut self, v: u32) {
        self.total_gifts_given = ::std::option::Option::Some(v);
    }

    pub fn get_total_gifts_given(&self) -> u32 {
        self.total_gifts_given.unwrap_or(0)
    }

    fn get_total_gifts_given_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_gifts_given
    }

    fn mut_total_gifts_given_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_gifts_given
    }

    // optional uint32 total_givers = 4;

    pub fn clear_total_givers(&mut self) {
        self.total_givers = ::std::option::Option::None;
    }

    pub fn has_total_givers(&self) -> bool {
        self.total_givers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_givers(&mut self, v: u32) {
        self.total_givers = ::std::option::Option::Some(v);
    }

    pub fn get_total_givers(&self) -> u32 {
        self.total_givers.unwrap_or(0)
    }

    fn get_total_givers_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_givers
    }

    fn mut_total_givers_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_givers
    }

    // repeated .CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry entries = 5;

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_entries(&self) -> &[CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry] {
        &self.entries
    }

    fn get_entries_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry> {
        &self.entries
    }

    fn mut_entries_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry> {
        &mut self.entries
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.servertime = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_period_seconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_gifts_given = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_givers = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.servertime {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_period_seconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_gifts_given {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_givers {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.servertime {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_period_seconds {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.total_gifts_given {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.total_givers {
            os.write_uint32(4, v)?;
        }
        for v in &self.entries {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        CMsgGCCStrike15_v2_GiftsLeaderboardResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_GiftsLeaderboardResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "servertime",
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse::get_servertime_for_reflect,
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse::mut_servertime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_period_seconds",
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse::get_time_period_seconds_for_reflect,
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse::mut_time_period_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_gifts_given",
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse::get_total_gifts_given_for_reflect,
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse::mut_total_gifts_given_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_givers",
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse::get_total_givers_for_reflect,
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse::mut_total_givers_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry>>(
                    "entries",
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse::get_entries_for_reflect,
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse::mut_entries_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GiftsLeaderboardResponse>(
                    "CMsgGCCStrike15_v2_GiftsLeaderboardResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn clear(&mut self) {
        self.clear_servertime();
        self.clear_time_period_seconds();
        self.clear_total_gifts_given();
        self.clear_total_givers();
        self.clear_entries();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    // message fields
    accountid: ::std::option::Option<u32>,
    gifts: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {}

impl CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    pub fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }

    // optional uint32 gifts = 2;

    pub fn clear_gifts(&mut self) {
        self.gifts = ::std::option::Option::None;
    }

    pub fn has_gifts(&self) -> bool {
        self.gifts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifts(&mut self, v: u32) {
        self.gifts = ::std::option::Option::Some(v);
    }

    pub fn get_gifts(&self) -> u32 {
        self.gifts.unwrap_or(0)
    }

    fn get_gifts_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gifts
    }

    fn mut_gifts_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gifts
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gifts = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gifts {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gifts {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
        CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry::get_accountid_for_reflect,
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry::mut_accountid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gifts",
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry::get_gifts_for_reflect,
                    CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry::mut_gifts_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry>(
                    "CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    fn clear(&mut self) {
        self.clear_accountid();
        self.clear_gifts();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    // message fields
    survey_id: ::std::option::Option<u32>,
    vote: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {}

impl CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    pub fn new() -> CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientSubmitSurveyVote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientSubmitSurveyVote,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientSubmitSurveyVote::new)
        }
    }

    // optional uint32 survey_id = 1;

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    pub fn get_survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }

    fn get_survey_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.survey_id
    }

    fn mut_survey_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.survey_id
    }

    // optional uint32 vote = 2;

    pub fn clear_vote(&mut self) {
        self.vote = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: u32) {
        self.vote = ::std::option::Option::Some(v);
    }

    pub fn get_vote(&self) -> u32 {
        self.vote.unwrap_or(0)
    }

    fn get_vote_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.vote
    }

    fn mut_vote_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.vote
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.survey_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vote = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.vote {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn new() -> CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        CMsgGCCStrike15_v2_ClientSubmitSurveyVote::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientSubmitSurveyVote>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "survey_id",
                    CMsgGCCStrike15_v2_ClientSubmitSurveyVote::get_survey_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientSubmitSurveyVote::mut_survey_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vote",
                    CMsgGCCStrike15_v2_ClientSubmitSurveyVote::get_vote_for_reflect,
                    CMsgGCCStrike15_v2_ClientSubmitSurveyVote::mut_vote_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientSubmitSurveyVote>(
                    "CMsgGCCStrike15_v2_ClientSubmitSurveyVote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn clear(&mut self) {
        self.clear_survey_id();
        self.clear_vote();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Server2GCClientValidate {
    // message fields
    accountid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Server2GCClientValidate {}

impl CMsgGCCStrike15_v2_Server2GCClientValidate {
    pub fn new() -> CMsgGCCStrike15_v2_Server2GCClientValidate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Server2GCClientValidate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Server2GCClientValidate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Server2GCClientValidate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Server2GCClientValidate::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn new() -> CMsgGCCStrike15_v2_Server2GCClientValidate {
        CMsgGCCStrike15_v2_Server2GCClientValidate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Server2GCClientValidate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgGCCStrike15_v2_Server2GCClientValidate::get_accountid_for_reflect,
                    CMsgGCCStrike15_v2_Server2GCClientValidate::mut_accountid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Server2GCClientValidate>(
                    "CMsgGCCStrike15_v2_Server2GCClientValidate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn clear(&mut self) {
        self.clear_accountid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    // message fields
    accountid: ::std::option::Option<u32>,
    path: ::protobuf::SingularField<::std::string::String>,
    file: ::protobuf::SingularField<::std::string::String>,
    crc: ::std::option::Option<u32>,
    hash: ::std::option::Option<i32>,
    len: ::std::option::Option<i32>,
    pack_number: ::std::option::Option<i32>,
    pack_file_id: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {}

impl CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    pub fn new() -> CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional string file = 3;

    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    pub fn has_file(&self) -> bool {
        self.file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        if self.file.is_none() {
            self.file.set_default();
        }
        self.file.as_mut().unwrap()
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        self.file.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_file(&self) -> &str {
        match self.file.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_file_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.file
    }

    fn mut_file_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.file
    }

    // optional uint32 crc = 4;

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    pub fn get_crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    fn get_crc_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.crc
    }

    fn mut_crc_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.crc
    }

    // optional int32 hash = 5;

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: i32) {
        self.hash = ::std::option::Option::Some(v);
    }

    pub fn get_hash(&self) -> i32 {
        self.hash.unwrap_or(0)
    }

    fn get_hash_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.hash
    }

    fn mut_hash_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.hash
    }

    // optional int32 len = 6;

    pub fn clear_len(&mut self) {
        self.len = ::std::option::Option::None;
    }

    pub fn has_len(&self) -> bool {
        self.len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: i32) {
        self.len = ::std::option::Option::Some(v);
    }

    pub fn get_len(&self) -> i32 {
        self.len.unwrap_or(0)
    }

    fn get_len_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.len
    }

    fn mut_len_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.len
    }

    // optional int32 pack_number = 7;

    pub fn clear_pack_number(&mut self) {
        self.pack_number = ::std::option::Option::None;
    }

    pub fn has_pack_number(&self) -> bool {
        self.pack_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pack_number(&mut self, v: i32) {
        self.pack_number = ::std::option::Option::Some(v);
    }

    pub fn get_pack_number(&self) -> i32 {
        self.pack_number.unwrap_or(0)
    }

    fn get_pack_number_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.pack_number
    }

    fn mut_pack_number_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.pack_number
    }

    // optional int32 pack_file_id = 8;

    pub fn clear_pack_file_id(&mut self) {
        self.pack_file_id = ::std::option::Option::None;
    }

    pub fn has_pack_file_id(&self) -> bool {
        self.pack_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pack_file_id(&mut self, v: i32) {
        self.pack_file_id = ::std::option::Option::Some(v);
    }

    pub fn get_pack_file_id(&self) -> i32 {
        self.pack_file_id.unwrap_or(0)
    }

    fn get_pack_file_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.pack_file_id
    }

    fn mut_pack_file_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.pack_file_id
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.crc = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hash = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.len = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pack_number = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pack_file_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.file.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.crc {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hash {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.len {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pack_number {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pack_file_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.file.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.crc {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.hash {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.len {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.pack_number {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.pack_file_id {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn new() -> CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
        CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::get_accountid_for_reflect,
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::mut_accountid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::get_path_for_reflect,
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file",
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::get_file_for_reflect,
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::mut_file_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "crc",
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::get_crc_for_reflect,
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::mut_crc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "hash",
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::get_hash_for_reflect,
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::mut_hash_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "len",
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::get_len_for_reflect,
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::mut_len_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pack_number",
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::get_pack_number_for_reflect,
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::mut_pack_number_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pack_file_id",
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::get_pack_file_id_for_reflect,
                    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::mut_pack_file_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure>(
                    "CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn clear(&mut self) {
        self.clear_accountid();
        self.clear_path();
        self.clear_file();
        self.clear_crc();
        self.clear_hash();
        self.clear_len();
        self.clear_pack_number();
        self.clear_pack_file_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    // message fields
    eventid: ::std::option::Option<u32>,
    stageid: ::std::option::Option<u32>,
    game_type: ::std::option::Option<u32>,
    teamids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {}

impl CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GC2ClientTournamentInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GC2ClientTournamentInfo,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GC2ClientTournamentInfo::new)
        }
    }

    // optional uint32 eventid = 1;

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: u32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    pub fn get_eventid(&self) -> u32 {
        self.eventid.unwrap_or(0)
    }

    fn get_eventid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eventid
    }

    fn mut_eventid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eventid
    }

    // optional uint32 stageid = 2;

    pub fn clear_stageid(&mut self) {
        self.stageid = ::std::option::Option::None;
    }

    pub fn has_stageid(&self) -> bool {
        self.stageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stageid(&mut self, v: u32) {
        self.stageid = ::std::option::Option::Some(v);
    }

    pub fn get_stageid(&self) -> u32 {
        self.stageid.unwrap_or(0)
    }

    fn get_stageid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.stageid
    }

    fn mut_stageid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.stageid
    }

    // optional uint32 game_type = 3;

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    fn get_game_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_type
    }

    fn mut_game_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_type
    }

    // repeated uint32 teamids = 4;

    pub fn clear_teamids(&mut self) {
        self.teamids.clear();
    }

    // Param is passed by value, moved
    pub fn set_teamids(&mut self, v: ::std::vec::Vec<u32>) {
        self.teamids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teamids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.teamids
    }

    // Take field
    pub fn take_teamids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.teamids, ::std::vec::Vec::new())
    }

    pub fn get_teamids(&self) -> &[u32] {
        &self.teamids
    }

    fn get_teamids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.teamids
    }

    fn mut_teamids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.teamids
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eventid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stageid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.teamids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stageid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.teamids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stageid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(3, v)?;
        }
        for v in &self.teamids {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn new() -> CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        CMsgGCCStrike15_v2_GC2ClientTournamentInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_GC2ClientTournamentInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eventid",
                    CMsgGCCStrike15_v2_GC2ClientTournamentInfo::get_eventid_for_reflect,
                    CMsgGCCStrike15_v2_GC2ClientTournamentInfo::mut_eventid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stageid",
                    CMsgGCCStrike15_v2_GC2ClientTournamentInfo::get_stageid_for_reflect,
                    CMsgGCCStrike15_v2_GC2ClientTournamentInfo::mut_stageid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    CMsgGCCStrike15_v2_GC2ClientTournamentInfo::get_game_type_for_reflect,
                    CMsgGCCStrike15_v2_GC2ClientTournamentInfo::mut_game_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "teamids",
                    CMsgGCCStrike15_v2_GC2ClientTournamentInfo::get_teamids_for_reflect,
                    CMsgGCCStrike15_v2_GC2ClientTournamentInfo::mut_teamids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GC2ClientTournamentInfo>(
                    "CMsgGCCStrike15_v2_GC2ClientTournamentInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn clear(&mut self) {
        self.clear_eventid();
        self.clear_stageid();
        self.clear_game_type();
        self.clear_teamids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconCoupon {
    // message fields
    entryid: ::std::option::Option<u32>,
    defidx: ::std::option::Option<u32>,
    expiration_date: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSOEconCoupon {}

impl CSOEconCoupon {
    pub fn new() -> CSOEconCoupon {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSOEconCoupon {
        static mut instance: ::protobuf::lazy::Lazy<CSOEconCoupon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSOEconCoupon,
        };
        unsafe {
            instance.get(CSOEconCoupon::new)
        }
    }

    // optional uint32 entryid = 1;

    pub fn clear_entryid(&mut self) {
        self.entryid = ::std::option::Option::None;
    }

    pub fn has_entryid(&self) -> bool {
        self.entryid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryid(&mut self, v: u32) {
        self.entryid = ::std::option::Option::Some(v);
    }

    pub fn get_entryid(&self) -> u32 {
        self.entryid.unwrap_or(0)
    }

    fn get_entryid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.entryid
    }

    fn mut_entryid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.entryid
    }

    // optional uint32 defidx = 2;

    pub fn clear_defidx(&mut self) {
        self.defidx = ::std::option::Option::None;
    }

    pub fn has_defidx(&self) -> bool {
        self.defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defidx(&mut self, v: u32) {
        self.defidx = ::std::option::Option::Some(v);
    }

    pub fn get_defidx(&self) -> u32 {
        self.defidx.unwrap_or(0)
    }

    fn get_defidx_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.defidx
    }

    fn mut_defidx_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.defidx
    }

    // optional fixed32 expiration_date = 3;

    pub fn clear_expiration_date(&mut self) {
        self.expiration_date = ::std::option::Option::None;
    }

    pub fn has_expiration_date(&self) -> bool {
        self.expiration_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_date(&mut self, v: u32) {
        self.expiration_date = ::std::option::Option::Some(v);
    }

    pub fn get_expiration_date(&self) -> u32 {
        self.expiration_date.unwrap_or(0)
    }

    fn get_expiration_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.expiration_date
    }

    fn mut_expiration_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.expiration_date
    }
}

impl ::protobuf::Message for CSOEconCoupon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.entryid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defidx = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.expiration_date = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entryid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defidx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expiration_date {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entryid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.defidx {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_date {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSOEconCoupon {
    fn new() -> CSOEconCoupon {
        CSOEconCoupon::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSOEconCoupon>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "entryid",
                    CSOEconCoupon::get_entryid_for_reflect,
                    CSOEconCoupon::mut_entryid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "defidx",
                    CSOEconCoupon::get_defidx_for_reflect,
                    CSOEconCoupon::mut_defidx_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "expiration_date",
                    CSOEconCoupon::get_expiration_date_for_reflect,
                    CSOEconCoupon::mut_expiration_date_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSOEconCoupon>(
                    "CSOEconCoupon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSOEconCoupon {
    fn clear(&mut self) {
        self.clear_entryid();
        self.clear_defidx();
        self.clear_expiration_date();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconCoupon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconCoupon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOQuestProgress {
    // message fields
    questid: ::std::option::Option<u32>,
    points_remaining: ::std::option::Option<u32>,
    bonus_points: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSOQuestProgress {}

impl CSOQuestProgress {
    pub fn new() -> CSOQuestProgress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSOQuestProgress {
        static mut instance: ::protobuf::lazy::Lazy<CSOQuestProgress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSOQuestProgress,
        };
        unsafe {
            instance.get(CSOQuestProgress::new)
        }
    }

    // optional uint32 questid = 1;

    pub fn clear_questid(&mut self) {
        self.questid = ::std::option::Option::None;
    }

    pub fn has_questid(&self) -> bool {
        self.questid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_questid(&mut self, v: u32) {
        self.questid = ::std::option::Option::Some(v);
    }

    pub fn get_questid(&self) -> u32 {
        self.questid.unwrap_or(0)
    }

    fn get_questid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.questid
    }

    fn mut_questid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.questid
    }

    // optional uint32 points_remaining = 2;

    pub fn clear_points_remaining(&mut self) {
        self.points_remaining = ::std::option::Option::None;
    }

    pub fn has_points_remaining(&self) -> bool {
        self.points_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_remaining(&mut self, v: u32) {
        self.points_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_points_remaining(&self) -> u32 {
        self.points_remaining.unwrap_or(0)
    }

    fn get_points_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points_remaining
    }

    fn mut_points_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points_remaining
    }

    // optional uint32 bonus_points = 3;

    pub fn clear_bonus_points(&mut self) {
        self.bonus_points = ::std::option::Option::None;
    }

    pub fn has_bonus_points(&self) -> bool {
        self.bonus_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_points(&mut self, v: u32) {
        self.bonus_points = ::std::option::Option::Some(v);
    }

    pub fn get_bonus_points(&self) -> u32 {
        self.bonus_points.unwrap_or(0)
    }

    fn get_bonus_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.bonus_points
    }

    fn mut_bonus_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.bonus_points
    }
}

impl ::protobuf::Message for CSOQuestProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.questid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_remaining = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bonus_points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.questid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_remaining {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bonus_points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.questid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.points_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_points {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSOQuestProgress {
    fn new() -> CSOQuestProgress {
        CSOQuestProgress::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSOQuestProgress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "questid",
                    CSOQuestProgress::get_questid_for_reflect,
                    CSOQuestProgress::mut_questid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points_remaining",
                    CSOQuestProgress::get_points_remaining_for_reflect,
                    CSOQuestProgress::mut_points_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bonus_points",
                    CSOQuestProgress::get_bonus_points_for_reflect,
                    CSOQuestProgress::mut_bonus_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSOQuestProgress>(
                    "CSOQuestProgress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSOQuestProgress {
    fn clear(&mut self) {
        self.clear_questid();
        self.clear_points_remaining();
        self.clear_bonus_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOQuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOQuestProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOPersonaDataPublic {
    // message fields
    player_level: ::std::option::Option<i32>,
    commendation: ::protobuf::SingularPtrField<PlayerCommendationInfo>,
    elevated_state: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSOPersonaDataPublic {}

impl CSOPersonaDataPublic {
    pub fn new() -> CSOPersonaDataPublic {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSOPersonaDataPublic {
        static mut instance: ::protobuf::lazy::Lazy<CSOPersonaDataPublic> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSOPersonaDataPublic,
        };
        unsafe {
            instance.get(CSOPersonaDataPublic::new)
        }
    }

    // optional int32 player_level = 1;

    pub fn clear_player_level(&mut self) {
        self.player_level = ::std::option::Option::None;
    }

    pub fn has_player_level(&self) -> bool {
        self.player_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_level(&mut self, v: i32) {
        self.player_level = ::std::option::Option::Some(v);
    }

    pub fn get_player_level(&self) -> i32 {
        self.player_level.unwrap_or(0)
    }

    fn get_player_level_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_level
    }

    fn mut_player_level_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_level
    }

    // optional .PlayerCommendationInfo commendation = 2;

    pub fn clear_commendation(&mut self) {
        self.commendation.clear();
    }

    pub fn has_commendation(&self) -> bool {
        self.commendation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commendation(&mut self, v: PlayerCommendationInfo) {
        self.commendation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commendation(&mut self) -> &mut PlayerCommendationInfo {
        if self.commendation.is_none() {
            self.commendation.set_default();
        }
        self.commendation.as_mut().unwrap()
    }

    // Take field
    pub fn take_commendation(&mut self) -> PlayerCommendationInfo {
        self.commendation.take().unwrap_or_else(|| PlayerCommendationInfo::new())
    }

    pub fn get_commendation(&self) -> &PlayerCommendationInfo {
        self.commendation.as_ref().unwrap_or_else(|| PlayerCommendationInfo::default_instance())
    }

    fn get_commendation_for_reflect(&self) -> &::protobuf::SingularPtrField<PlayerCommendationInfo> {
        &self.commendation
    }

    fn mut_commendation_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PlayerCommendationInfo> {
        &mut self.commendation
    }

    // optional bool elevated_state = 3;

    pub fn clear_elevated_state(&mut self) {
        self.elevated_state = ::std::option::Option::None;
    }

    pub fn has_elevated_state(&self) -> bool {
        self.elevated_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevated_state(&mut self, v: bool) {
        self.elevated_state = ::std::option::Option::Some(v);
    }

    pub fn get_elevated_state(&self) -> bool {
        self.elevated_state.unwrap_or(false)
    }

    fn get_elevated_state_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.elevated_state
    }

    fn mut_elevated_state_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.elevated_state
    }
}

impl ::protobuf::Message for CSOPersonaDataPublic {
    fn is_initialized(&self) -> bool {
        for v in &self.commendation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commendation)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.elevated_state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.elevated_state {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_level {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.commendation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.elevated_state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSOPersonaDataPublic {
    fn new() -> CSOPersonaDataPublic {
        CSOPersonaDataPublic::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSOPersonaDataPublic>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_level",
                    CSOPersonaDataPublic::get_player_level_for_reflect,
                    CSOPersonaDataPublic::mut_player_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerCommendationInfo>>(
                    "commendation",
                    CSOPersonaDataPublic::get_commendation_for_reflect,
                    CSOPersonaDataPublic::mut_commendation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "elevated_state",
                    CSOPersonaDataPublic::get_elevated_state_for_reflect,
                    CSOPersonaDataPublic::mut_elevated_state_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSOPersonaDataPublic>(
                    "CSOPersonaDataPublic",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSOPersonaDataPublic {
    fn clear(&mut self) {
        self.clear_player_level();
        self.clear_commendation();
        self.clear_elevated_state();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOPersonaDataPublic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOPersonaDataPublic {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GlobalGame_Subscribe {
    // message fields
    ticket: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGC_GlobalGame_Subscribe {}

impl CMsgGC_GlobalGame_Subscribe {
    pub fn new() -> CMsgGC_GlobalGame_Subscribe {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGC_GlobalGame_Subscribe {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGC_GlobalGame_Subscribe> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGC_GlobalGame_Subscribe,
        };
        unsafe {
            instance.get(CMsgGC_GlobalGame_Subscribe::new)
        }
    }

    // optional uint64 ticket = 1;

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }

    pub fn get_ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }

    fn get_ticket_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ticket
    }

    fn mut_ticket_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ticket
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Subscribe {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ticket = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGC_GlobalGame_Subscribe {
    fn new() -> CMsgGC_GlobalGame_Subscribe {
        CMsgGC_GlobalGame_Subscribe::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGC_GlobalGame_Subscribe>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ticket",
                    CMsgGC_GlobalGame_Subscribe::get_ticket_for_reflect,
                    CMsgGC_GlobalGame_Subscribe::mut_ticket_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGC_GlobalGame_Subscribe>(
                    "CMsgGC_GlobalGame_Subscribe",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGC_GlobalGame_Subscribe {
    fn clear(&mut self) {
        self.clear_ticket();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GlobalGame_Subscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Subscribe {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GlobalGame_Unsubscribe {
    // message fields
    timeleft: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGC_GlobalGame_Unsubscribe {}

impl CMsgGC_GlobalGame_Unsubscribe {
    pub fn new() -> CMsgGC_GlobalGame_Unsubscribe {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGC_GlobalGame_Unsubscribe {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGC_GlobalGame_Unsubscribe> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGC_GlobalGame_Unsubscribe,
        };
        unsafe {
            instance.get(CMsgGC_GlobalGame_Unsubscribe::new)
        }
    }

    // optional int32 timeleft = 1;

    pub fn clear_timeleft(&mut self) {
        self.timeleft = ::std::option::Option::None;
    }

    pub fn has_timeleft(&self) -> bool {
        self.timeleft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeleft(&mut self, v: i32) {
        self.timeleft = ::std::option::Option::Some(v);
    }

    pub fn get_timeleft(&self) -> i32 {
        self.timeleft.unwrap_or(0)
    }

    fn get_timeleft_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.timeleft
    }

    fn mut_timeleft_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.timeleft
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Unsubscribe {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timeleft = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeleft {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeleft {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGC_GlobalGame_Unsubscribe {
    fn new() -> CMsgGC_GlobalGame_Unsubscribe {
        CMsgGC_GlobalGame_Unsubscribe::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGC_GlobalGame_Unsubscribe>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "timeleft",
                    CMsgGC_GlobalGame_Unsubscribe::get_timeleft_for_reflect,
                    CMsgGC_GlobalGame_Unsubscribe::mut_timeleft_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGC_GlobalGame_Unsubscribe>(
                    "CMsgGC_GlobalGame_Unsubscribe",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGC_GlobalGame_Unsubscribe {
    fn clear(&mut self) {
        self.clear_timeleft();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GlobalGame_Unsubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Unsubscribe {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GlobalGame_Play {
    // message fields
    ticket: ::std::option::Option<u64>,
    gametimems: ::std::option::Option<u32>,
    msperpoint: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGC_GlobalGame_Play {}

impl CMsgGC_GlobalGame_Play {
    pub fn new() -> CMsgGC_GlobalGame_Play {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGC_GlobalGame_Play {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGC_GlobalGame_Play> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGC_GlobalGame_Play,
        };
        unsafe {
            instance.get(CMsgGC_GlobalGame_Play::new)
        }
    }

    // optional uint64 ticket = 1;

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }

    pub fn get_ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }

    fn get_ticket_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ticket
    }

    fn mut_ticket_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ticket
    }

    // optional uint32 gametimems = 2;

    pub fn clear_gametimems(&mut self) {
        self.gametimems = ::std::option::Option::None;
    }

    pub fn has_gametimems(&self) -> bool {
        self.gametimems.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gametimems(&mut self, v: u32) {
        self.gametimems = ::std::option::Option::Some(v);
    }

    pub fn get_gametimems(&self) -> u32 {
        self.gametimems.unwrap_or(0)
    }

    fn get_gametimems_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gametimems
    }

    fn mut_gametimems_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gametimems
    }

    // optional uint32 msperpoint = 3;

    pub fn clear_msperpoint(&mut self) {
        self.msperpoint = ::std::option::Option::None;
    }

    pub fn has_msperpoint(&self) -> bool {
        self.msperpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msperpoint(&mut self, v: u32) {
        self.msperpoint = ::std::option::Option::Some(v);
    }

    pub fn get_msperpoint(&self) -> u32 {
        self.msperpoint.unwrap_or(0)
    }

    fn get_msperpoint_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.msperpoint
    }

    fn mut_msperpoint_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.msperpoint
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Play {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ticket = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gametimems = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.msperpoint = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gametimems {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.msperpoint {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.gametimems {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.msperpoint {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGC_GlobalGame_Play {
    fn new() -> CMsgGC_GlobalGame_Play {
        CMsgGC_GlobalGame_Play::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGC_GlobalGame_Play>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ticket",
                    CMsgGC_GlobalGame_Play::get_ticket_for_reflect,
                    CMsgGC_GlobalGame_Play::mut_ticket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gametimems",
                    CMsgGC_GlobalGame_Play::get_gametimems_for_reflect,
                    CMsgGC_GlobalGame_Play::mut_gametimems_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "msperpoint",
                    CMsgGC_GlobalGame_Play::get_msperpoint_for_reflect,
                    CMsgGC_GlobalGame_Play::mut_msperpoint_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGC_GlobalGame_Play>(
                    "CMsgGC_GlobalGame_Play",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGC_GlobalGame_Play {
    fn clear(&mut self) {
        self.clear_ticket();
        self.clear_gametimems();
        self.clear_msperpoint();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GlobalGame_Play {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Play {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_AcknowledgePenalty {
    // message fields
    acknowledged: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_AcknowledgePenalty {}

impl CMsgGCCStrike15_v2_AcknowledgePenalty {
    pub fn new() -> CMsgGCCStrike15_v2_AcknowledgePenalty {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_AcknowledgePenalty {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_AcknowledgePenalty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_AcknowledgePenalty,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_AcknowledgePenalty::new)
        }
    }

    // optional int32 acknowledged = 1;

    pub fn clear_acknowledged(&mut self) {
        self.acknowledged = ::std::option::Option::None;
    }

    pub fn has_acknowledged(&self) -> bool {
        self.acknowledged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acknowledged(&mut self, v: i32) {
        self.acknowledged = ::std::option::Option::Some(v);
    }

    pub fn get_acknowledged(&self) -> i32 {
        self.acknowledged.unwrap_or(0)
    }

    fn get_acknowledged_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.acknowledged
    }

    fn mut_acknowledged_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.acknowledged
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.acknowledged = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.acknowledged {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.acknowledged {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn new() -> CMsgGCCStrike15_v2_AcknowledgePenalty {
        CMsgGCCStrike15_v2_AcknowledgePenalty::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_AcknowledgePenalty>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "acknowledged",
                    CMsgGCCStrike15_v2_AcknowledgePenalty::get_acknowledged_for_reflect,
                    CMsgGCCStrike15_v2_AcknowledgePenalty::mut_acknowledged_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_AcknowledgePenalty>(
                    "CMsgGCCStrike15_v2_AcknowledgePenalty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn clear(&mut self) {
        self.clear_acknowledged();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {}

impl CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn new() -> CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin>(
                    "CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    // message fields
    ticket: ::std::option::Option<u64>,
    os: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_Client2GCStreamUnlock {}

impl CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Client2GCStreamUnlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Client2GCStreamUnlock,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Client2GCStreamUnlock::new)
        }
    }

    // optional uint64 ticket = 1;

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }

    pub fn get_ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }

    fn get_ticket_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ticket
    }

    fn mut_ticket_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ticket
    }

    // optional int32 os = 2;

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: i32) {
        self.os = ::std::option::Option::Some(v);
    }

    pub fn get_os(&self) -> i32 {
        self.os.unwrap_or(0)
    }

    fn get_os_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.os
    }

    fn mut_os_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.os
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ticket = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.os = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.os {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.os {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn new() -> CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        CMsgGCCStrike15_v2_Client2GCStreamUnlock::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_Client2GCStreamUnlock>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ticket",
                    CMsgGCCStrike15_v2_Client2GCStreamUnlock::get_ticket_for_reflect,
                    CMsgGCCStrike15_v2_Client2GCStreamUnlock::mut_ticket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "os",
                    CMsgGCCStrike15_v2_Client2GCStreamUnlock::get_os_for_reflect,
                    CMsgGCCStrike15_v2_Client2GCStreamUnlock::mut_os_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Client2GCStreamUnlock>(
                    "CMsgGCCStrike15_v2_Client2GCStreamUnlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn clear(&mut self) {
        self.clear_ticket();
        self.clear_os();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    // message fields
    stage: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientToGCRequestElevate {}

impl CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    pub fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientToGCRequestElevate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientToGCRequestElevate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientToGCRequestElevate::new)
        }
    }

    // optional uint32 stage = 1;

    pub fn clear_stage(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_stage(&self) -> bool {
        self.stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: u32) {
        self.stage = ::std::option::Option::Some(v);
    }

    pub fn get_stage(&self) -> u32 {
        self.stage.unwrap_or(0)
    }

    fn get_stage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.stage
    }

    fn mut_stage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.stage
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stage = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stage {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stage {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        CMsgGCCStrike15_v2_ClientToGCRequestElevate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientToGCRequestElevate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stage",
                    CMsgGCCStrike15_v2_ClientToGCRequestElevate::get_stage_for_reflect,
                    CMsgGCCStrike15_v2_ClientToGCRequestElevate::mut_stage_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientToGCRequestElevate>(
                    "CMsgGCCStrike15_v2_ClientToGCRequestElevate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn clear(&mut self) {
        self.clear_stage();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientToGCChat {
    // message fields
    match_id: ::std::option::Option<u64>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_ClientToGCChat {}

impl CMsgGCCStrike15_v2_ClientToGCChat {
    pub fn new() -> CMsgGCCStrike15_v2_ClientToGCChat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientToGCChat {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientToGCChat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientToGCChat,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientToGCChat::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional string text = 2;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_text_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.text
    }

    fn mut_text_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.text
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientToGCChat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_ClientToGCChat {
    fn new() -> CMsgGCCStrike15_v2_ClientToGCChat {
        CMsgGCCStrike15_v2_ClientToGCChat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_ClientToGCChat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCCStrike15_v2_ClientToGCChat::get_match_id_for_reflect,
                    CMsgGCCStrike15_v2_ClientToGCChat::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    CMsgGCCStrike15_v2_ClientToGCChat::get_text_for_reflect,
                    CMsgGCCStrike15_v2_ClientToGCChat::mut_text_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientToGCChat>(
                    "CMsgGCCStrike15_v2_ClientToGCChat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientToGCChat {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientToGCChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientToGCChat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GCToClientChat {
    // message fields
    account_id: ::std::option::Option<u32>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCStrike15_v2_GCToClientChat {}

impl CMsgGCCStrike15_v2_GCToClientChat {
    pub fn new() -> CMsgGCCStrike15_v2_GCToClientChat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCStrike15_v2_GCToClientChat {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GCToClientChat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GCToClientChat,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GCToClientChat::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional string text = 2;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_text_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.text
    }

    fn mut_text_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.text
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GCToClientChat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCStrike15_v2_GCToClientChat {
    fn new() -> CMsgGCCStrike15_v2_GCToClientChat {
        CMsgGCCStrike15_v2_GCToClientChat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCStrike15_v2_GCToClientChat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCStrike15_v2_GCToClientChat::get_account_id_for_reflect,
                    CMsgGCCStrike15_v2_GCToClientChat::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    CMsgGCCStrike15_v2_GCToClientChat::get_text_for_reflect,
                    CMsgGCCStrike15_v2_GCToClientChat::mut_text_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GCToClientChat>(
                    "CMsgGCCStrike15_v2_GCToClientChat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GCToClientChat {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GCToClientChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GCToClientChat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ECsgoGCMsg {
    k_EMsgGCCStrike15_v2_Base = 9100,
    k_EMsgGCCStrike15_v2_MatchmakingStart = 9101,
    k_EMsgGCCStrike15_v2_MatchmakingStop = 9102,
    k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing = 9103,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = 9104,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = 9105,
    k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse = 9106,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = 9107,
    k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats = 9108,
    k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello = 9109,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello = 9110,
    k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd = 9111,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = 9112,
    k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick = 9113,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = 9114,
    k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats = 9115,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = 9116,
    k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = 9117,
    k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty = 9118,
    k_EMsgGCCStrike15_v2_ClientReportPlayer = 9119,
    k_EMsgGCCStrike15_v2_ClientReportServer = 9120,
    k_EMsgGCCStrike15_v2_ClientCommendPlayer = 9121,
    k_EMsgGCCStrike15_v2_ClientReportResponse = 9122,
    k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery = 9123,
    k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse = 9124,
    k_EMsgGCCStrike15_v2_WatchInfoUsers = 9126,
    k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile = 9127,
    k_EMsgGCCStrike15_v2_PlayersProfile = 9128,
    k_EMsgGCCStrike15_v2_SetMyMedalsInfo = 9129,
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = 9131,
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = 9132,
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = 9133,
    k_EMsgGCCStrike15_v2_GC2ClientTextMsg = 9134,
    k_EMsgGCCStrike15_v2_Client2GCTextMsg = 9135,
    k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops = 9136,
    k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification = 9137,
    k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2 = 9138,
    k_EMsgGCCStrike15_v2_MatchList = 9139,
    k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = 9140,
    k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames = 9141,
    k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate = 9142,
    k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo = 9144,
    k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = 9145,
    k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames = 9146,
    k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo = 9147,
    k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest = 9148,
    k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse = 9149,
    k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo = 9150,
    k_EMsgGCToGCReloadVersions = 9151,
    k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote = 9152,
    k_EMsgGCCStrike15_v2_Server2GCClientValidate = 9153,
    k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = 9154,
    k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = 9155,
    k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = 9156,
    k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = 9157,
    k_EMsgGCCStrike15_v2_AccountPrivacySettings = 9158,
    k_EMsgGCCStrike15_v2_SetMyActivityInfo = 9159,
    k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions = 9160,
    k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions = 9161,
    k_EMsgGCCStrike15_v2_DraftSummary = 9162,
    k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData = 9163,
    k_EMsgGCCStrike15_v2_ClientRequestJoinServerData = 9164,
    k_EMsgGCCStrike15_v2_ClientRequestNewMission = 9165,
    k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded = 9166,
    k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo = 9167,
    k_EMsgGC_GlobalGame_Subscribe = 9168,
    k_EMsgGC_GlobalGame_Unsubscribe = 9169,
    k_EMsgGC_GlobalGame_Play = 9170,
    k_EMsgGCCStrike15_v2_AcknowledgePenalty = 9171,
    k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = 9172,
    k_EMsgGCCStrike15_v2_GC2ClientGlobalStats = 9173,
    k_EMsgGCCStrike15_v2_Client2GCStreamUnlock = 9174,
    k_EMsgGCCStrike15_v2_FantasyRequestClientData = 9175,
    k_EMsgGCCStrike15_v2_FantasyUpdateClientData = 9176,
    k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket = 9177,
    k_EMsgGCCStrike15_v2_ClientToGCRequestTicket = 9178,
    k_EMsgGCCStrike15_v2_ClientToGCRequestElevate = 9179,
    k_EMsgGCCStrike15_v2_GlobalChat = 9180,
    k_EMsgGCCStrike15_v2_GlobalChat_Subscribe = 9181,
    k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe = 9182,
}

impl ::protobuf::ProtobufEnum for ECsgoGCMsg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECsgoGCMsg> {
        match value {
            9100 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base),
            9101 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStart),
            9102 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStop),
            9103 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing),
            9104 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate),
            9105 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve),
            9106 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse),
            9107 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve),
            9108 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats),
            9109 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello),
            9110 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello),
            9111 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd),
            9112 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon),
            9113 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick),
            9114 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm),
            9115 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats),
            9116 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate),
            9117 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate),
            9118 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty),
            9119 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportPlayer),
            9120 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportServer),
            9121 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayer),
            9122 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportResponse),
            9123 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery),
            9124 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse),
            9126 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_WatchInfoUsers),
            9127 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile),
            9128 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayersProfile),
            9129 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyMedalsInfo),
            9131 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate),
            9132 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment),
            9133 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus),
            9134 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTextMsg),
            9135 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCTextMsg),
            9136 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops),
            9137 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification),
            9138 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2),
            9139 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchList),
            9140 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames),
            9141 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames),
            9142 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate),
            9144 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo),
            9145 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification),
            9146 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames),
            9147 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo),
            9148 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest),
            9149 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse),
            9150 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo),
            9151 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCToGCReloadVersions),
            9152 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote),
            9153 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCClientValidate),
            9154 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser),
            9155 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure),
            9156 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest),
            9157 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse),
            9158 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_AccountPrivacySettings),
            9159 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyActivityInfo),
            9160 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions),
            9161 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions),
            9162 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_DraftSummary),
            9163 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData),
            9164 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinServerData),
            9165 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestNewMission),
            9166 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded),
            9167 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo),
            9168 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Subscribe),
            9169 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Unsubscribe),
            9170 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Play),
            9171 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_AcknowledgePenalty),
            9172 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin),
            9173 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientGlobalStats),
            9174 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCStreamUnlock),
            9175 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyRequestClientData),
            9176 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyUpdateClientData),
            9177 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket),
            9178 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestTicket),
            9179 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestElevate),
            9180 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat),
            9181 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Subscribe),
            9182 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ECsgoGCMsg] = &[
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStart,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStop,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportPlayer,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportServer,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayer,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportResponse,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_WatchInfoUsers,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayersProfile,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyMedalsInfo,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTextMsg,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCTextMsg,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchList,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo,
            ECsgoGCMsg::k_EMsgGCToGCReloadVersions,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCClientValidate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_AccountPrivacySettings,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyActivityInfo,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_DraftSummary,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinServerData,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestNewMission,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Subscribe,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Unsubscribe,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Play,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_AcknowledgePenalty,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientGlobalStats,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCStreamUnlock,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyRequestClientData,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyUpdateClientData,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestTicket,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestElevate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Subscribe,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<ECsgoGCMsg>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ECsgoGCMsg", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ECsgoGCMsg {
}

impl ::protobuf::reflect::ProtobufValue for ECsgoGCMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1acstrike15_gcmessages.proto\x1a\x13steammessages.proto\"\x8b\x01\n\
    \x0eGameServerPing\x12#\n\rgameserver_id\x18\x01\x20\x01(\x04R\x0cgamese\
    rverId\x12\x12\n\x04ping\x18\x02\x20\x01(\x05R\x04ping\x12\x0e\n\x02ip\
    \x18\x03\x20\x01(\rR\x02ip\x12\x12\n\x04port\x18\x04\x20\x01(\rR\x04port\
    \x12\x1c\n\tinstances\x18\x05\x20\x01(\rR\tinstances\"\x8b\x01\n\x17Deta\
    iledSearchStatistic\x12\x1b\n\tgame_type\x18\x01\x20\x01(\rR\x08gameType\
    \x12&\n\x0fsearch_time_avg\x18\x02\x20\x01(\rR\rsearchTimeAvg\x12+\n\x11\
    players_searching\x18\x04\x20\x01(\rR\x10playersSearching\"\xfd\x01\n\
    \x10TournamentPlayer\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountI\
    d\x12\x1f\n\x0bplayer_nick\x18\x02\x20\x01(\tR\nplayerNick\x12\x1f\n\x0b\
    player_name\x18\x03\x20\x01(\tR\nplayerName\x12\x1d\n\nplayer_dob\x18\
    \x04\x20\x01(\rR\tplayerDob\x12\x1f\n\x0bplayer_flag\x18\x05\x20\x01(\tR\
    \nplayerFlag\x12'\n\x0fplayer_location\x18\x06\x20\x01(\tR\x0eplayerLoca\
    tion\x12\x1f\n\x0bplayer_desc\x18\x07\x20\x01(\tR\nplayerDesc\"\xab\x01\
    \n\x0eTournamentTeam\x12\x17\n\x07team_id\x18\x01\x20\x01(\x05R\x06teamI\
    d\x12\x19\n\x08team_tag\x18\x02\x20\x01(\tR\x07teamTag\x12\x1b\n\tteam_f\
    lag\x18\x03\x20\x01(\tR\x08teamFlag\x12\x1b\n\tteam_name\x18\x04\x20\x01\
    (\tR\x08teamName\x12+\n\x07players\x18\x05\x20\x03(\x0b2\x11.TournamentP\
    layerR\x07players\"\xd7\x02\n\x0fTournamentEvent\x12\x19\n\x08event_id\
    \x18\x01\x20\x01(\x05R\x07eventId\x12\x1b\n\tevent_tag\x18\x02\x20\x01(\
    \tR\x08eventTag\x12\x1d\n\nevent_name\x18\x03\x20\x01(\tR\teventName\x12\
    (\n\x10event_time_start\x18\x04\x20\x01(\rR\x0eeventTimeStart\x12$\n\x0e\
    event_time_end\x18\x05\x20\x01(\rR\x0ceventTimeEnd\x12!\n\x0cevent_publi\
    c\x18\x06\x20\x01(\x05R\x0beventPublic\x12$\n\x0eevent_stage_id\x18\x07\
    \x20\x01(\x05R\x0ceventStageId\x12(\n\x10event_stage_name\x18\x08\x20\
    \x01(\tR\x0eeventStageName\x12*\n\x11active_section_id\x18\t\x20\x01(\rR\
    \x0factiveSectionId\"\xf7\x04\n\x10GlobalStatistics\x12%\n\x0eplayers_on\
    line\x18\x01\x20\x01(\rR\rplayersOnline\x12%\n\x0eservers_online\x18\x02\
    \x20\x01(\rR\rserversOnline\x12+\n\x11players_searching\x18\x03\x20\x01(\
    \rR\x10playersSearching\x12+\n\x11servers_available\x18\x04\x20\x01(\rR\
    \x10serversAvailable\x12'\n\x0fongoing_matches\x18\x05\x20\x01(\rR\x0eon\
    goingMatches\x12&\n\x0fsearch_time_avg\x18\x06\x20\x01(\rR\rsearchTimeAv\
    g\x12E\n\x11search_statistics\x18\x07\x20\x03(\x0b2\x18.DetailedSearchSt\
    atisticR\x10searchStatistics\x12\"\n\rmain_post_url\x18\x08\x20\x01(\tR\
    \x0bmainPostUrl\x124\n\x16required_appid_version\x18\t\x20\x01(\rR\x14re\
    quiredAppidVersion\x12-\n\x12pricesheet_version\x18\n\x20\x01(\rR\x11pri\
    cesheetVersion\x124\n\x16twitch_streams_version\x18\x0b\x20\x01(\rR\x14t\
    witchStreamsVersion\x12:\n\x19active_tournament_eventid\x18\x0c\x20\x01(\
    \rR\x17activeTournamentEventid\x12(\n\x10active_survey_id\x18\r\x20\x01(\
    \rR\x0eactiveSurveyId\"K\n\x1fOperationalStatisticDescription\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05idkey\x18\x02\x20\x01(\
    \rR\x05idkey\"K\n\x1bOperationalStatisticElement\x12\x14\n\x05idkey\x18\
    \x01\x20\x01(\rR\x05idkey\x12\x16\n\x06values\x18\x02\x20\x03(\x05R\x06v\
    alues\"\x91\x01\n\x1bOperationalStatisticsPacket\x12\x1a\n\x08packetid\
    \x18\x01\x20\x01(\x05R\x08packetid\x12\x20\n\x0bmstimestamp\x18\x02\x20\
    \x01(\x05R\x0bmstimestamp\x124\n\x06values\x18\x03\x20\x03(\x0b2\x1c.Ope\
    rationalStatisticElementR\x06values\"\x80\x01\n\x11PlayerRankingInfo\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x17\n\x07rank_id\
    \x18\x02\x20\x01(\rR\x06rankId\x12\x12\n\x04wins\x18\x03\x20\x01(\rR\x04\
    wins\x12\x1f\n\x0brank_change\x18\x04\x20\x01(\x02R\nrankChange\"}\n\x16\
    PlayerCommendationInfo\x12!\n\x0ccmd_friendly\x18\x01\x20\x01(\rR\x0bcmd\
    Friendly\x12!\n\x0ccmd_teaching\x18\x02\x20\x01(\rR\x0bcmdTeaching\x12\
    \x1d\n\ncmd_leader\x18\x04\x20\x01(\rR\tcmdLeader\"\xac\x02\n\x10PlayerM\
    edalsInfo\x12\x1d\n\nmedal_team\x18\x01\x20\x01(\rR\tmedalTeam\x12!\n\
    \x0cmedal_combat\x18\x02\x20\x01(\rR\x0bmedalCombat\x12!\n\x0cmedal_weap\
    on\x18\x03\x20\x01(\rR\x0bmedalWeapon\x12!\n\x0cmedal_global\x18\x04\x20\
    \x01(\rR\x0bmedalGlobal\x12\x1d\n\nmedal_arms\x18\x05\x20\x01(\rR\tmedal\
    Arms\x120\n\x14display_items_defidx\x18\x07\x20\x03(\rR\x12displayItemsD\
    efidx\x12?\n\x1cfeatured_display_item_defidx\x18\x08\x20\x01(\rR\x19feat\
    uredDisplayItemDefidx\"S\n\x0fAccountActivity\x12\x1a\n\x08activity\x18\
    \x01\x20\x01(\rR\x08activity\x12\x12\n\x04mode\x18\x02\x20\x01(\rR\x04mo\
    de\x12\x10\n\x03map\x18\x03\x20\x01(\rR\x03map\"\x91\x01\n\x14Tournament\
    MatchSetup\x12\x19\n\x08event_id\x18\x01\x20\x01(\x05R\x07eventId\x12\
    \x1c\n\nteam_id_ct\x18\x02\x20\x01(\x05R\x08teamIdCt\x12\x1a\n\tteam_id_\
    t\x18\x03\x20\x01(\x05R\x07teamIdT\x12$\n\x0eevent_stage_id\x18\x04\x20\
    \x01(\x05R\x0ceventStageId\"\xb9\x05\n\x0eServerHltvInfo\x12\x1e\n\x0btv\
    _udp_port\x18\x01\x20\x01(\rR\ttvUdpPort\x12\x20\n\x0ctv_watch_key\x18\
    \x02\x20\x01(\x04R\ntvWatchKey\x12\x19\n\x08tv_slots\x18\x03\x20\x01(\rR\
    \x07tvSlots\x12\x1d\n\ntv_clients\x18\x04\x20\x01(\rR\ttvClients\x12\x1d\
    \n\ntv_proxies\x18\x05\x20\x01(\rR\ttvProxies\x12\x17\n\x07tv_time\x18\
    \x06\x20\x01(\rR\x06tvTime\x12\x1b\n\tgame_type\x18\x08\x20\x01(\rR\x08g\
    ameType\x12#\n\rgame_mapgroup\x18\t\x20\x01(\tR\x0cgameMapgroup\x12\x19\
    \n\x08game_map\x18\n\x20\x01(\tR\x07gameMap\x12*\n\x11tv_master_steamid\
    \x18\x0b\x20\x01(\x04R\x0ftvMasterSteamid\x12$\n\x0etv_local_slots\x18\
    \x0c\x20\x01(\rR\x0ctvLocalSlots\x12(\n\x10tv_local_clients\x18\r\x20\
    \x01(\rR\x0etvLocalClients\x12(\n\x10tv_local_proxies\x18\x0e\x20\x01(\r\
    R\x0etvLocalProxies\x12$\n\x0etv_relay_slots\x18\x0f\x20\x01(\rR\x0ctvRe\
    laySlots\x12(\n\x10tv_relay_clients\x18\x10\x20\x01(\rR\x0etvRelayClient\
    s\x12(\n\x10tv_relay_proxies\x18\x11\x20\x01(\rR\x0etvRelayProxies\x12(\
    \n\x10tv_relay_address\x18\x12\x20\x01(\rR\x0etvRelayAddress\x12\"\n\rtv\
    _relay_port\x18\x13\x20\x01(\rR\x0btvRelayPort\x12(\n\x10tv_relay_steami\
    d\x18\x14\x20\x01(\x04R\x0etvRelaySteamid\"q\n\rIpAddressMask\x12\x0c\n\
    \x01a\x18\x01\x20\x01(\rR\x01a\x12\x0c\n\x01b\x18\x02\x20\x01(\rR\x01b\
    \x12\x0c\n\x01c\x18\x03\x20\x01(\rR\x01c\x12\x0c\n\x01d\x18\x04\x20\x01(\
    \rR\x01d\x12\x12\n\x04bits\x18\x05\x20\x01(\rR\x04bits\x12\x14\n\x05toke\
    n\x18\x06\x20\x01(\rR\x05token\"N\n\x0eXpProgressData\x12\x1b\n\txp_poin\
    ts\x18\x01\x20\x01(\rR\x08xpPoints\x12\x1f\n\x0bxp_category\x18\x02\x20\
    \x01(\x05R\nxpCategory\"\x8b\x01\n\x13MatchEndItemUpdates\x12\x17\n\x07i\
    tem_id\x18\x01\x20\x01(\x04R\x06itemId\x12(\n\x10item_attr_defidx\x18\
    \x02\x20\x01(\rR\x0eitemAttrDefidx\x121\n\x15item_attr_delta_value\x18\
    \x03\x20\x01(\rR\x12itemAttrDeltaValue\"\xea\x02\n\x14ScoreLeaderboardDa\
    ta\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\x12\x14\n\x05s\
    core\x18\x02\x20\x01(\rR\x05score\x12L\n\x0eaccountentries\x18\x03\x20\
    \x03(\x0b2$.ScoreLeaderboardData.AccountEntriesR\x0eaccountentries\x12?\
    \n\x0cmatchentries\x18\x05\x20\x03(\x0b2\x1b.ScoreLeaderboardData.EntryR\
    \x0cmatchentries\x1a+\n\x05Entry\x12\x10\n\x03tag\x18\x01\x20\x01(\rR\
    \x03tag\x12\x10\n\x03val\x18\x02\x20\x01(\rR\x03val\x1ae\n\x0eAccountEnt\
    ries\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x125\n\x07entri\
    es\x18\x02\x20\x03(\x0b2\x1b.ScoreLeaderboardData.EntryR\x07entries\"\
    \xe3\x03\n\x0fPlayerQuestData\x12,\n\x12quester_account_id\x18\x01\x20\
    \x01(\rR\x10questerAccountId\x12F\n\x0fquest_item_data\x18\x02\x20\x03(\
    \x0b2\x1e.PlayerQuestData.QuestItemDataR\rquestItemData\x129\n\x10xp_pro\
    gress_data\x18\x03\x20\x03(\x0b2\x0f.XpProgressDataR\x0expProgressData\
    \x12\x1f\n\x0btime_played\x18\x04\x20\x01(\rR\ntimePlayed\x12\x20\n\x0cm\
    m_game_mode\x18\x05\x20\x01(\rR\nmmGameMode\x127\n\x0citem_updates\x18\
    \x06\x20\x03(\x0b2\x14.MatchEndItemUpdatesR\x0bitemUpdates\x1a\xa2\x01\n\
    \rQuestItemData\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\
    \x12;\n\x1aquest_normal_points_earned\x18\x02\x20\x01(\x05R\x17questNorm\
    alPointsEarned\x129\n\x19quest_bonus_points_earned\x18\x03\x20\x01(\x05R\
    \x16questBonusPointsEarned\"\xde\x01\n\x1cCMsgGC_ServerQuestUpdateData\
    \x12<\n\x11player_quest_data\x18\x01\x20\x03(\x0b2\x10.PlayerQuestDataR\
    \x0fplayerQuestData\x12\x1f\n\x0bbinary_data\x18\x02\x20\x01(\x0cR\nbina\
    ryData\x12\x20\n\x0cmm_game_mode\x18\x03\x20\x01(\rR\nmmGameMode\x12=\n\
    \x0emissionlbsdata\x18\x04\x20\x01(\x0b2\x15.ScoreLeaderboardDataR\x0emi\
    ssionlbsdata\"\xc4\x01\n0CMsgGCCStrike15_v2_MatchmakingGCOperationalStat\
    s\x12\x1a\n\x08packetid\x18\x01\x20\x01(\x05R\x08packetid\x12<\n\x08name\
    keys\x18\x02\x20\x03(\x0b2\x20.OperationalStatisticDescriptionR\x08namek\
    eys\x126\n\x07packets\x18\x03\x20\x03(\x0b2\x1c.OperationalStatisticsPac\
    ketR\x07packets\"x\n.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\x12\
    \x14\n\x05token\x18\x01\x20\x01(\rR\x05token\x12\x14\n\x05stamp\x18\x02\
    \x20\x01(\rR\x05stamp\x12\x1a\n\x08exchange\x18\x03\x20\x01(\x04R\x08exc\
    hange\"\x9b\x01\n-CMsgGCCStrike15_v2_GC2ServerReservationUpdate\x124\n\
    \x16viewers_external_total\x18\x01\x20\x01(\rR\x14viewersExternalTotal\
    \x124\n\x16viewers_external_steam\x18\x02\x20\x01(\rR\x14viewersExternal\
    Steam\"\xed\x01\n#CMsgGCCStrike15_v2_MatchmakingStart\x12\x1f\n\x0baccou\
    nt_ids\x18\x01\x20\x03(\rR\naccountIds\x12\x1b\n\tgame_type\x18\x02\x20\
    \x01(\rR\x08gameType\x12\x1f\n\x0bticket_data\x18\x03\x20\x01(\tR\nticke\
    tData\x12%\n\x0eclient_version\x18\x04\x20\x01(\rR\rclientVersion\x12@\n\
    \x10tournament_match\x18\x05\x20\x01(\x0b2\x15.TournamentMatchSetupR\x0f\
    tournamentMatch\">\n\"CMsgGCCStrike15_v2_MatchmakingStop\x12\x18\n\x07ab\
    andon\x18\x01\x20\x01(\x05R\x07abandon\"\xb0\x01\n/CMsgGCCStrike15_v2_Ma\
    tchmakingClient2ServerPing\x129\n\x0fgameserverpings\x18\x01\x20\x03(\
    \x0b2\x0f.GameServerPingR\x0fgameserverpings\x12!\n\x0coffset_index\x18\
    \x02\x20\x01(\x05R\x0boffsetIndex\x12\x1f\n\x0bfinal_batch\x18\x03\x20\
    \x01(\x05R\nfinalBatch\"\xb3\x07\n-CMsgGCCStrike15_v2_MatchmakingGC2Clie\
    ntUpdate\x12\x20\n\x0bmatchmaking\x18\x01\x20\x01(\x05R\x0bmatchmaking\
    \x12=\n\x1bwaiting_account_id_sessions\x18\x02\x20\x03(\rR\x18waitingAcc\
    ountIdSessions\x12\x14\n\x05error\x18\x03\x20\x01(\tR\x05error\x12G\n\
    \x20ongoingmatch_account_id_sessions\x18\x06\x20\x03(\rR\x1dongoingmatch\
    AccountIdSessions\x124\n\x0cglobal_stats\x18\x07\x20\x01(\x0b2\x11.Globa\
    lStatisticsR\x0bglobalStats\x12?\n\x1cfailping_account_id_sessions\x18\
    \x08\x20\x03(\rR\x19failpingAccountIdSessions\x12=\n\x1bpenalty_account_\
    id_sessions\x18\t\x20\x03(\rR\x18penaltyAccountIdSessions\x12A\n\x1dfail\
    ready_account_id_sessions\x18\n\x20\x03(\rR\x1afailreadyAccountIdSession\
    s\x12A\n\x1dvacbanned_account_id_sessions\x18\x0b\x20\x03(\rR\x1avacbann\
    edAccountIdSessions\x12B\n\x15server_ipaddress_mask\x18\x0c\x20\x01(\x0b\
    2\x0e.IpAddressMaskR\x13serverIpaddressMask\x12I\n\x05notes\x18\r\x20\
    \x03(\x0b23.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.NoteR\x05notes\
    \x12H\n!penalty_account_id_sessions_green\x18\x0e\x20\x03(\rR\x1dpenalty\
    AccountIdSessionsGreen\x12=\n\x1ainsufficientlevel_sessions\x18\x0f\x20\
    \x03(\rR\x19insufficientlevelSessions\x1an\n\x04Note\x12\x12\n\x04type\
    \x18\x01\x20\x01(\x05R\x04type\x12\x1b\n\tregion_id\x18\x02\x20\x01(\x05\
    R\x08regionId\x12\x19\n\x08region_r\x18\x03\x20\x01(\x02R\x07regionR\x12\
    \x1a\n\x08distance\x18\x04\x20\x01(\x02R\x08distance\"\xd7\x03\n(CDataGC\
    CStrike15_v2_TournamentMatchDraft\x12\x19\n\x08event_id\x18\x01\x20\x01(\
    \x05R\x07eventId\x12$\n\x0eevent_stage_id\x18\x02\x20\x01(\x05R\x0cevent\
    StageId\x12\x1a\n\tteam_id_0\x18\x03\x20\x01(\x05R\x07teamId0\x12\x1a\n\
    \tteam_id_1\x18\x04\x20\x01(\x05R\x07teamId1\x12\x1d\n\nmaps_count\x18\
    \x05\x20\x01(\x05R\tmapsCount\x12!\n\x0cmaps_current\x18\x06\x20\x01(\
    \x05R\x0bmapsCurrent\x12\"\n\rteam_id_start\x18\x07\x20\x01(\x05R\x0btea\
    mIdStart\x12\"\n\rteam_id_veto1\x18\x08\x20\x01(\x05R\x0bteamIdVeto1\x12\
    \"\n\rteam_id_pickn\x18\t\x20\x01(\x05R\x0bteamIdPickn\x12G\n\x06drafts\
    \x18\n\x20\x03(\x0b2/.CDataGCCStrike15_v2_TournamentMatchDraft.EntryR\
    \x06drafts\x1a;\n\x05Entry\x12\x14\n\x05mapid\x18\x01\x20\x01(\x05R\x05m\
    apid\x12\x1c\n\nteam_id_ct\x18\x02\x20\x01(\x05R\x08teamIdCt\"\xbb\x02\n\
    \x11CPreMatchInfoData\x12'\n\x0fpredictions_pct\x18\x01\x20\x01(\x05R\
    \x0epredictionsPct\x12?\n\x05draft\x18\x04\x20\x01(\x0b2).CDataGCCStrike\
    15_v2_TournamentMatchDraftR\x05draft\x122\n\x05stats\x18\x05\x20\x03(\
    \x0b2\x1c.CPreMatchInfoData.TeamStatsR\x05stats\x1a\x87\x01\n\tTeamStats\
    \x12*\n\x11match_info_idxtxt\x18\x01\x20\x01(\x05R\x0fmatchInfoIdxtxt\
    \x12$\n\x0ematch_info_txt\x18\x02\x20\x01(\tR\x0cmatchInfoTxt\x12(\n\x10\
    match_info_teams\x18\x03\x20\x03(\tR\x0ematchInfoTeams\"\xce\x05\n.CMsgG\
    CCStrike15_v2_MatchmakingGC2ServerReserve\x12\x1f\n\x0baccount_ids\x18\
    \x01\x20\x03(\rR\naccountIds\x12\x1b\n\tgame_type\x18\x02\x20\x01(\rR\
    \x08gameType\x12\x19\n\x08match_id\x18\x03\x20\x01(\x04R\x07matchId\x12%\
    \n\x0eserver_version\x18\x04\x20\x01(\rR\rserverVersion\x12.\n\x08rankin\
    gs\x18\x05\x20\x03(\x0b2\x12.PlayerRankingInfoR\x08rankings\x12%\n\x0een\
    cryption_key\x18\x06\x20\x01(\x04R\rencryptionKey\x12,\n\x12encryption_k\
    ey_pub\x18\x07\x20\x01(\x04R\x10encryptionKeyPub\x12\x1b\n\tparty_ids\
    \x18\x08\x20\x03(\rR\x08partyIds\x12,\n\twhitelist\x18\t\x20\x03(\x0b2\
    \x0e.IpAddressMaskR\twhitelist\x12*\n\x11tv_master_steamid\x18\n\x20\x01\
    (\x04R\x0ftvMasterSteamid\x12;\n\x10tournament_event\x18\x0b\x20\x01(\
    \x0b2\x10.TournamentEventR\x0ftournamentEvent\x12:\n\x10tournament_teams\
    \x18\x0c\x20\x03(\x0b2\x0f.TournamentTeamR\x0ftournamentTeams\x12C\n\x1e\
    tournament_casters_account_ids\x18\r\x20\x03(\rR\x1btournamentCastersAcc\
    ountIds\x12(\n\x10tv_relay_steamid\x18\x0e\x20\x01(\x04R\x0etvRelaySteam\
    id\x128\n\x0epre_match_data\x18\x0f\x20\x01(\x0b2\x12.CPreMatchInfoDataR\
    \x0cpreMatchData\"\xa9\x05\n7CMsgGCCStrike15_v2_MatchmakingServerReserva\
    tionResponse\x12$\n\rreservationid\x18\x01\x20\x01(\x04R\rreservationid\
    \x12Q\n\x0breservation\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matchma\
    kingGC2ServerReserveR\x0breservation\x12\x10\n\x03map\x18\x03\x20\x01(\t\
    R\x03map\x12.\n\x13gc_reservation_sent\x18\x04\x20\x01(\x04R\x11gcReserv\
    ationSent\x12%\n\x0eserver_version\x18\x05\x20\x01(\rR\rserverVersion\
    \x12(\n\x07tv_info\x18\x06\x20\x01(\x0b2\x0f.ServerHltvInfoR\x06tvInfo\
    \x124\n\x16reward_player_accounts\x18\x07\x20\x03(\rR\x14rewardPlayerAcc\
    ounts\x120\n\x14idle_player_accounts\x18\x08\x20\x03(\rR\x12idlePlayerAc\
    counts\x126\n\x18reward_item_attr_def_idx\x18\t\x20\x01(\rR\x14rewardIte\
    mAttrDefIdx\x123\n\x16reward_item_attr_value\x18\n\x20\x01(\rR\x13reward\
    ItemAttrValue\x12<\n\x1breward_item_attr_reward_idx\x18\x0b\x20\x01(\rR\
    \x17rewardItemAttrRewardIdx\x12(\n\x10reward_drop_list\x18\x0c\x20\x01(\
    \rR\x0erewardDropList\x12%\n\x0etournament_tag\x18\r\x20\x01(\tR\rtourna\
    mentTag\"\xfe\x01\n.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\x12\
    \x1a\n\x08serverid\x18\x01\x20\x01(\x04R\x08serverid\x12$\n\rreservation\
    id\x18\x04\x20\x01(\x04R\rreservationid\x12Q\n\x0breservation\x18\x05\
    \x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserveR\x0breser\
    vation\x12\x10\n\x03map\x18\x06\x20\x01(\tR\x03map\x12%\n\x0eserver_addr\
    ess\x18\x07\x20\x01(\tR\rserverAddress\"\xbb\x08\n.CMsgGCCStrike15_v2_Ma\
    tchmakingServerRoundStats\x12$\n\rreservationid\x18\x01\x20\x01(\x04R\rr\
    eservationid\x12Q\n\x0breservation\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike1\
    5_v2_MatchmakingGC2ServerReserveR\x0breservation\x12\x10\n\x03map\x18\
    \x03\x20\x01(\tR\x03map\x12\x14\n\x05round\x18\x04\x20\x01(\x05R\x05roun\
    d\x12\x14\n\x05kills\x18\x05\x20\x03(\x05R\x05kills\x12\x18\n\x07assists\
    \x18\x06\x20\x03(\x05R\x07assists\x12\x16\n\x06deaths\x18\x07\x20\x03(\
    \x05R\x06deaths\x12\x16\n\x06scores\x18\x08\x20\x03(\x05R\x06scores\x12\
    \x14\n\x05pings\x18\t\x20\x03(\x05R\x05pings\x12!\n\x0cround_result\x18\
    \n\x20\x01(\x05R\x0broundResult\x12!\n\x0cmatch_result\x18\x0b\x20\x01(\
    \x05R\x0bmatchResult\x12\x1f\n\x0bteam_scores\x18\x0c\x20\x03(\x05R\ntea\
    mScores\x12I\n\x07confirm\x18\r\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matchm\
    akingGC2ServerConfirmR\x07confirm\x12+\n\x11reservation_stage\x18\x0e\
    \x20\x01(\x05R\x10reservationStage\x12%\n\x0ematch_duration\x18\x0f\x20\
    \x01(\x05R\rmatchDuration\x12\x1f\n\x0benemy_kills\x18\x10\x20\x03(\x05R\
    \nenemyKills\x12'\n\x0fenemy_headshots\x18\x11\x20\x03(\x05R\x0eenemyHea\
    dshots\x12\x1b\n\tenemy_3ks\x18\x12\x20\x03(\x05R\x08enemy3ks\x12\x1b\n\
    \tenemy_4ks\x18\x13\x20\x03(\x05R\x08enemy4ks\x12\x1b\n\tenemy_5ks\x18\
    \x14\x20\x03(\x05R\x08enemy5ks\x12\x12\n\x04mvps\x18\x15\x20\x03(\x05R\
    \x04mvps\x12)\n\x10spectators_count\x18\x16\x20\x01(\rR\x0fspectatorsCou\
    nt\x12.\n\x13spectators_count_tv\x18\x17\x20\x01(\rR\x11spectatorsCountT\
    v\x120\n\x14spectators_count_lnk\x18\x18\x20\x01(\rR\x12spectatorsCountL\
    nk\x12&\n\x0fenemy_kills_agg\x18\x19\x20\x03(\x05R\renemyKillsAgg\x12U\n\
    \tdrop_info\x18\x1a\x20\x01(\x0b28.CMsgGCCStrike15_v2_MatchmakingServerR\
    oundStats.DropInfoR\x08dropInfo\x1a+\n\x08DropInfo\x12\x1f\n\x0baccount_\
    mvp\x18\x01\x20\x01(\rR\naccountMvp\"\xc5\x03\n,CMsgGCCStrike15_v2_Match\
    makingServerMatchEnd\x12E\n\x05stats\x18\x01\x20\x01(\x0b2/.CMsgGCCStrik\
    e15_v2_MatchmakingServerRoundStatsR\x05stats\x12I\n\x07confirm\x18\x03\
    \x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirmR\x07confi\
    rm\x12\x18\n\x07rematch\x18\x04\x20\x01(\x04R\x07rematch\x12!\n\x0crepla\
    y_token\x18\x05\x20\x01(\rR\x0breplayToken\x12*\n\x11replay_cluster_id\
    \x18\x06\x20\x01(\rR\x0freplayClusterId\x12#\n\raborted_match\x18\x07\
    \x20\x01(\x08R\x0cabortedMatch\x12N\n\x14match_end_quest_data\x18\x08\
    \x20\x01(\x0b2\x1d.CMsgGC_ServerQuestUpdateDataR\x11matchEndQuestData\
    \x12%\n\x0eserver_version\x18\t\x20\x01(\rR\rserverVersion\".\n,CMsgGCCS\
    trike15_v2_MatchmakingClient2GCHello\"\xaa\x07\n,CMsgGCCStrike15_v2_Matc\
    hmakingGC2ClientHello\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccount\
    Id\x12S\n\x0congoingmatch\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matc\
    hmakingGC2ClientReserveR\x0congoingmatch\x124\n\x0cglobal_stats\x18\x03\
    \x20\x01(\x0b2\x11.GlobalStatisticsR\x0bglobalStats\x12'\n\x0fpenalty_se\
    conds\x18\x04\x20\x01(\rR\x0epenaltySeconds\x12%\n\x0epenalty_reason\x18\
    \x05\x20\x01(\rR\rpenaltyReason\x12\x1d\n\nvac_banned\x18\x06\x20\x01(\
    \x05R\tvacBanned\x12,\n\x07ranking\x18\x07\x20\x01(\x0b2\x12.PlayerRanki\
    ngInfoR\x07ranking\x12;\n\x0ccommendation\x18\x08\x20\x01(\x0b2\x17.Play\
    erCommendationInfoR\x0ccommendation\x12)\n\x06medals\x18\t\x20\x01(\x0b2\
    \x11.PlayerMedalsInfoR\x06medals\x12:\n\x10my_current_event\x18\n\x20\
    \x01(\x0b2\x10.TournamentEventR\x0emyCurrentEvent\x12D\n\x16my_current_e\
    vent_teams\x18\x0b\x20\x03(\x0b2\x0f.TournamentTeamR\x13myCurrentEventTe\
    ams\x127\n\x0fmy_current_team\x18\x0c\x20\x01(\x0b2\x0f.TournamentTeamR\
    \rmyCurrentTeam\x12G\n\x17my_current_event_stages\x18\r\x20\x03(\x0b2\
    \x10.TournamentEventR\x14myCurrentEventStages\x12\x1f\n\x0bsurvey_vote\
    \x18\x0e\x20\x01(\rR\nsurveyVote\x12,\n\x08activity\x18\x0f\x20\x01(\x0b\
    2\x10.AccountActivityR\x08activity\x12!\n\x0cplayer_level\x18\x11\x20\
    \x01(\x05R\x0bplayerLevel\x12\"\n\rplayer_cur_xp\x18\x12\x20\x01(\x05R\
    \x0bplayerCurXp\x121\n\x15player_xp_bonus_flags\x18\x13\x20\x01(\x05R\
    \x12playerXpBonusFlags\"\xce\x01\n)CMsgGCCStrike15_v2_AccountPrivacySett\
    ings\x12N\n\x08settings\x18\x01\x20\x03(\x0b22.CMsgGCCStrike15_v2_Accoun\
    tPrivacySettings.SettingR\x08settings\x1aQ\n\x07Setting\x12!\n\x0csettin\
    g_type\x18\x01\x20\x01(\rR\x0bsettingType\x12#\n\rsetting_value\x18\x02\
    \x20\x01(\rR\x0csettingValue\"\xf9\x01\n.CMsgGCCStrike15_v2_MatchmakingG\
    C2ClientAbandon\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    X\n\x0fabandoned_match\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matchma\
    kingGC2ClientReserveR\x0eabandonedMatch\x12'\n\x0fpenalty_seconds\x18\
    \x03\x20\x01(\rR\x0epenaltySeconds\x12%\n\x0epenalty_reason\x18\x04\x20\
    \x01(\rR\rpenaltyReason\"\xb7\x01\n+CMsgGCCStrike15_v2_MatchmakingServer\
    2GCKick\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12Q\n\x0br\
    eservation\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2Serve\
    rReserveR\x0breservation\x12\x16\n\x06reason\x18\x03\x20\x01(\rR\x06reas\
    on\"~\n1CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\x12.\n\x08rank\
    ings\x18\x01\x20\x03(\x0b2\x12.PlayerRankingInfoR\x08rankings\x12\x19\n\
    \x08match_id\x18\x02\x20\x01(\x04R\x07matchId\"Y\n3CMsgGCCStrike15_v2_Ma\
    tchmakingOperator2GCBlogUpdate\x12\"\n\rmain_post_url\x18\x01\x20\x01(\t\
    R\x0bmainPostUrl\"\x86\x01\n3CMsgGCCStrike15_v2_ServerNotificationForUse\
    rPenalty\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x16\n\
    \x06reason\x18\x02\x20\x01(\rR\x06reason\x12\x18\n\x07seconds\x18\x03\
    \x20\x01(\rR\x07seconds\"\xb7\x02\n%CMsgGCCStrike15_v2_ClientReportPlaye\
    r\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1d\n\nrpt_ai\
    mbot\x18\x02\x20\x01(\rR\trptAimbot\x12!\n\x0crpt_wallhack\x18\x03\x20\
    \x01(\rR\x0brptWallhack\x12#\n\rrpt_speedhack\x18\x04\x20\x01(\rR\x0crpt\
    Speedhack\x12!\n\x0crpt_teamharm\x18\x05\x20\x01(\rR\x0brptTeamharm\x12#\
    \n\rrpt_textabuse\x18\x06\x20\x01(\rR\x0crptTextabuse\x12%\n\x0erpt_voic\
    eabuse\x18\x07\x20\x01(\rR\rrptVoiceabuse\x12\x19\n\x08match_id\x18\x08\
    \x20\x01(\x04R\x07matchId\"\xb7\x01\n&CMsgGCCStrike15_v2_ClientCommendPl\
    ayer\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x19\n\x08m\
    atch_id\x18\x08\x20\x01(\x04R\x07matchId\x12;\n\x0ccommendation\x18\t\
    \x20\x01(\x0b2\x17.PlayerCommendationInfoR\x0ccommendation\x12\x16\n\x06\
    tokens\x18\n\x20\x01(\rR\x06tokens\"\x8d\x02\n%CMsgGCCStrike15_v2_Client\
    ReportServer\x12!\n\x0crpt_poorperf\x18\x01\x20\x01(\rR\x0brptPoorperf\
    \x12+\n\x11rpt_abusivemodels\x18\x02\x20\x01(\rR\x10rptAbusivemodels\x12\
    \x1f\n\x0brpt_badmotd\x18\x03\x20\x01(\rR\nrptBadmotd\x12)\n\x10rpt_list\
    ingabuse\x18\x04\x20\x01(\rR\x0frptListingabuse\x12-\n\x12rpt_inventorya\
    buse\x18\x05\x20\x01(\rR\x11rptInventoryabuse\x12\x19\n\x08match_id\x18\
    \x08\x20\x01(\x04R\x07matchId\"\xf4\x01\n'CMsgGCCStrike15_v2_ClientRepor\
    tResponse\x12'\n\x0fconfirmation_id\x18\x01\x20\x01(\x04R\x0econfirmatio\
    nId\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12\x1b\n\tserv\
    er_ip\x18\x03\x20\x01(\rR\x08serverIp\x12#\n\rresponse_type\x18\x04\x20\
    \x01(\rR\x0cresponseType\x12'\n\x0fresponse_result\x18\x05\x20\x01(\rR\
    \x0eresponseResult\x12\x16\n\x06tokens\x18\x06\x20\x01(\rR\x06tokens\"\
    \xa8\x01\n0CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\x12\x1d\n\nr\
    equest_id\x18\x01\x20\x01(\rR\trequestId\x12\x1f\n\x0baccount_ids\x18\
    \x02\x20\x03(\rR\naccountIds\x12\x1a\n\x08serverid\x18\x03\x20\x01(\x04R\
    \x08serverid\x12\x18\n\x07matchid\x18\x04\x20\x01(\x04R\x07matchid\"\xd3\
    \x03\n\x12WatchableMatchInfo\x12\x1b\n\tserver_ip\x18\x01\x20\x01(\rR\
    \x08serverIp\x12\x17\n\x07tv_port\x18\x02\x20\x01(\rR\x06tvPort\x12#\n\r\
    tv_spectators\x18\x03\x20\x01(\rR\x0ctvSpectators\x12\x17\n\x07tv_time\
    \x18\x04\x20\x01(\rR\x06tvTime\x12*\n\x11tv_watch_password\x18\x05\x20\
    \x01(\x0cR\x0ftvWatchPassword\x12,\n\x12cl_decryptdata_key\x18\x06\x20\
    \x01(\x04R\x10clDecryptdataKey\x123\n\x16cl_decryptdata_key_pub\x18\x07\
    \x20\x01(\x04R\x13clDecryptdataKeyPub\x12\x1b\n\tgame_type\x18\x08\x20\
    \x01(\rR\x08gameType\x12#\n\rgame_mapgroup\x18\t\x20\x01(\tR\x0cgameMapg\
    roup\x12\x19\n\x08game_map\x18\n\x20\x01(\tR\x07gameMap\x12\x1b\n\tserve\
    r_id\x18\x0b\x20\x01(\x04R\x08serverId\x12\x19\n\x08match_id\x18\x0c\x20\
    \x01(\x04R\x07matchId\x12%\n\x0ereservation_id\x18\r\x20\x01(\x04R\rrese\
    rvationId\"\x82\x02\n.CMsgGCCStrike15_v2_ClientRequestJoinFriendData\x12\
    \x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x1d\n\naccount_id\
    \x18\x02\x20\x01(\rR\taccountId\x12\x1d\n\njoin_token\x18\x03\x20\x01(\r\
    R\tjoinToken\x12\x19\n\x08join_ipp\x18\x04\x20\x01(\rR\x07joinIpp\x12A\n\
    \x03res\x18\x05\x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ClientRe\
    serveR\x03res\x12\x1a\n\x08errormsg\x18\x06\x20\x01(\tR\x08errormsg\"\
    \x86\x02\n.CMsgGCCStrike15_v2_ClientRequestJoinServerData\x12\x18\n\x07v\
    ersion\x18\x01\x20\x01(\rR\x07version\x12\x1d\n\naccount_id\x18\x02\x20\
    \x01(\rR\taccountId\x12\x1a\n\x08serverid\x18\x03\x20\x01(\x04R\x08serve\
    rid\x12\x1b\n\tserver_ip\x18\x04\x20\x01(\rR\x08serverIp\x12\x1f\n\x0bse\
    rver_port\x18\x05\x20\x01(\rR\nserverPort\x12A\n\x03res\x18\x06\x20\x01(\
    \x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserveR\x03res\"l\n*CMsgG\
    CCstrike15_v2_ClientRequestNewMission\x12\x1d\n\nmission_id\x18\x02\x20\
    \x01(\rR\tmissionId\x12\x1f\n\x0bcampaign_id\x18\x03\x20\x01(\rR\ncampai\
    gnId\"\xf5\x01\n,CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\x129\n\x10\
    xp_progress_data\x18\x01\x20\x03(\x0b2\x0f.XpProgressDataR\x0expProgress\
    Data\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12\x1d\n\ncur\
    rent_xp\x18\x03\x20\x01(\rR\tcurrentXp\x12#\n\rcurrent_level\x18\x04\x20\
    \x01(\rR\x0ccurrentLevel\x12'\n\x0fupgraded_defidx\x18\x05\x20\x01(\rR\
    \x0eupgradedDefidx\"\xd7\x01\n!CMsgGCCStrike15_v2_WatchInfoUsers\x12\x1d\
    \n\nrequest_id\x18\x01\x20\x01(\rR\trequestId\x12\x1f\n\x0baccount_ids\
    \x18\x02\x20\x03(\rR\naccountIds\x12G\n\x15watchable_match_infos\x18\x03\
    \x20\x03(\x0b2\x13.WatchableMatchInfoR\x13watchableMatchInfos\x12)\n\x10\
    extended_timeout\x18\x05\x20\x01(\rR\x0fextendedTimeout\"\xe0\x01\n.CMsg\
    GCCStrike15_v2_ClientRequestPlayersProfile\x123\n\x16request_id__depreca\
    ted\x18\x01\x20\x01(\rR\x13requestIdDeprecated\x125\n\x17account_ids__de\
    precated\x18\x02\x20\x03(\rR\x14accountIdsDeprecated\x12\x1d\n\naccount_\
    id\x18\x03\x20\x01(\rR\taccountId\x12#\n\rrequest_level\x18\x04\x20\x01(\
    \rR\x0crequestLevel\"\x9c\x01\n!CMsgGCCStrike15_v2_PlayersProfile\x12\
    \x1d\n\nrequest_id\x18\x01\x20\x01(\rR\trequestId\x12X\n\x10account_prof\
    iles\x18\x02\x20\x03(\x0b2-.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\
    R\x0faccountProfiles\"\xa6\x02\n,CMsgGCCStrike15_v2_PlayerOverwatchCaseU\
    pdate\x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\x06caseid\x12\x1c\n\tsus\
    pectid\x18\x03\x20\x01(\rR\tsuspectid\x12\x1e\n\nfractionid\x18\x04\x20\
    \x01(\rR\nfractionid\x12\x1d\n\nrpt_aimbot\x18\x05\x20\x01(\rR\trptAimbo\
    t\x12!\n\x0crpt_wallhack\x18\x06\x20\x01(\rR\x0brptWallhack\x12#\n\rrpt_\
    speedhack\x18\x07\x20\x01(\rR\x0crptSpeedhack\x12!\n\x0crpt_teamharm\x18\
    \x08\x20\x01(\rR\x0brptTeamharm\x12\x16\n\x06reason\x18\t\x20\x01(\rR\
    \x06reason\"\x90\x03\n0CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\
    \x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\x06caseid\x12\x18\n\x07caseur\
    l\x18\x02\x20\x01(\tR\x07caseurl\x12\x18\n\x07verdict\x18\x03\x20\x01(\r\
    R\x07verdict\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\rR\ttimestamp\x12(\n\
    \x0fthrottleseconds\x18\x05\x20\x01(\rR\x0fthrottleseconds\x12\x1c\n\tsu\
    spectid\x18\x06\x20\x01(\rR\tsuspectid\x12\x1e\n\nfractionid\x18\x07\x20\
    \x01(\rR\nfractionid\x12\x1c\n\tnumrounds\x18\x08\x20\x01(\rR\tnumrounds\
    \x12&\n\x0efractionrounds\x18\t\x20\x01(\rR\x0efractionrounds\x12,\n\x11\
    streakconvictions\x18\n\x20\x01(\x05R\x11streakconvictions\x12\x16\n\x06\
    reason\x18\x0b\x20\x01(\rR\x06reason\"b\n,CMsgGCCStrike15_v2_PlayerOverw\
    atchCaseStatus\x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\x06caseid\x12\
    \x1a\n\x08statusid\x18\x02\x20\x01(\rR\x08statusid\"V\n\x1eCClientHeader\
    OverwatchEvidence\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\
    \x12\x16\n\x06caseid\x18\x02\x20\x01(\x04R\x06caseid\"c\n#CMsgGCCStrike1\
    5_v2_GC2ClientTextMsg\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\
    \n\x04type\x18\x02\x20\x01(\rR\x04type\x12\x18\n\x07payload\x18\x03\x20\
    \x01(\x0cR\x07payload\"I\n#CMsgGCCStrike15_v2_Client2GCTextMsg\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04args\x18\x02\x20\x03(\x0cR\
    \x04args\"\xd5\x01\n)CMsgGCCStrike15_v2_MatchEndRunRewardDrops\x12X\n\ns\
    erverinfo\x18\x03\x20\x01(\x0b28.CMsgGCCStrike15_v2_MatchmakingServerRes\
    ervationResponseR\nserverinfo\x12N\n\x14match_end_quest_data\x18\x04\x20\
    \x01(\x0b2\x1d.CMsgGC_ServerQuestUpdateDataR\x11matchEndQuestData\"\xa8\
    \x05\n\x19CEconItemPreviewDataBlock\x12\x1c\n\taccountid\x18\x01\x20\x01\
    (\rR\taccountid\x12\x16\n\x06itemid\x18\x02\x20\x01(\x04R\x06itemid\x12\
    \x1a\n\x08defindex\x18\x03\x20\x01(\rR\x08defindex\x12\x1e\n\npaintindex\
    \x18\x04\x20\x01(\rR\npaintindex\x12\x16\n\x06rarity\x18\x05\x20\x01(\rR\
    \x06rarity\x12\x18\n\x07quality\x18\x06\x20\x01(\rR\x07quality\x12\x1c\n\
    \tpaintwear\x18\x07\x20\x01(\rR\tpaintwear\x12\x1c\n\tpaintseed\x18\x08\
    \x20\x01(\rR\tpaintseed\x12.\n\x12killeaterscoretype\x18\t\x20\x01(\rR\
    \x12killeaterscoretype\x12&\n\x0ekilleatervalue\x18\n\x20\x01(\rR\x0ekil\
    leatervalue\x12\x1e\n\ncustomname\x18\x0b\x20\x01(\tR\ncustomname\x12>\n\
    \x08stickers\x18\x0c\x20\x03(\x0b2\".CEconItemPreviewDataBlock.StickerR\
    \x08stickers\x12\x1c\n\tinventory\x18\r\x20\x01(\rR\tinventory\x12\x16\n\
    \x06origin\x18\x0e\x20\x01(\rR\x06origin\x12\x18\n\x07questid\x18\x0f\
    \x20\x01(\rR\x07questid\x12\x1e\n\ndropreason\x18\x10\x20\x01(\rR\ndropr\
    eason\x1a\x82\x01\n\x07Sticker\x12\x12\n\x04slot\x18\x01\x20\x01(\rR\x04\
    slot\x12\x1d\n\nsticker_id\x18\x02\x20\x01(\rR\tstickerId\x12\x12\n\x04w\
    ear\x18\x03\x20\x01(\x02R\x04wear\x12\x14\n\x05scale\x18\x04\x20\x01(\
    \x02R\x05scale\x12\x1a\n\x08rotation\x18\x05\x20\x01(\x02R\x08rotation\"\
    l\n2CMsgGCCStrike15_v2_MatchEndRewardDropsNotification\x126\n\x08iteminf\
    o\x18\x06\x20\x01(\x0b2\x1a.CEconItemPreviewDataBlockR\x08iteminfo\"N\n\
    \x14CMsgItemAcknowledged\x126\n\x08iteminfo\x18\x01\x20\x01(\x0b2\x1a.CE\
    conItemPreviewDataBlockR\x08iteminfo\"\x9d\x01\n7CMsgGCCStrike15_v2_Clie\
    nt2GCEconPreviewDataBlockRequest\x12\x17\n\x07param_s\x18\x01\x20\x01(\
    \x04R\x06paramS\x12\x17\n\x07param_a\x18\x02\x20\x01(\x04R\x06paramA\x12\
    \x17\n\x07param_d\x18\x03\x20\x01(\x04R\x06paramD\x12\x17\n\x07param_m\
    \x18\x04\x20\x01(\x04R\x06paramM\"r\n8CMsgGCCStrike15_v2_Client2GCEconPr\
    eviewDataBlockResponse\x126\n\x08iteminfo\x18\x01\x20\x01(\x0b2\x1a.CEco\
    nItemPreviewDataBlockR\x08iteminfo\"\x92\x01\n9CMsgGCCStrike15_v2_Tourna\
    mentMatchRewardDropsNotification\x12\x19\n\x08match_id\x18\x01\x20\x01(\
    \x04R\x07matchId\x12\x1a\n\x08defindex\x18\x02\x20\x01(\rR\x08defindex\
    \x12\x1e\n\naccountids\x18\x03\x20\x03(\rR\naccountids\"5\n3CMsgGCCStrik\
    e15_v2_MatchListRequestCurrentLiveGames\"R\n2CMsgGCCStrike15_v2_MatchLis\
    tRequestLiveGameForUser\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccoun\
    tid\"R\n2CMsgGCCStrike15_v2_MatchListRequestRecentUserGames\x12\x1c\n\ta\
    ccountid\x18\x01\x20\x01(\rR\taccountid\"N\n2CMsgGCCStrike15_v2_MatchLis\
    tRequestTournamentGames\x12\x18\n\x07eventid\x18\x01\x20\x01(\x05R\x07ev\
    entid\"\x7f\n/CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\x12\x18\n\
    \x07matchid\x18\x01\x20\x01(\x04R\x07matchid\x12\x1c\n\toutcomeid\x18\
    \x02\x20\x01(\x04R\toutcomeid\x12\x14\n\x05token\x18\x03\x20\x01(\rR\x05\
    token\"\xd1\x02\n\x1dCDataGCCStrike15_v2_MatchInfo\x12\x18\n\x07matchid\
    \x18\x01\x20\x01(\x04R\x07matchid\x12\x1c\n\tmatchtime\x18\x02\x20\x01(\
    \rR\tmatchtime\x12C\n\x12watchablematchinfo\x18\x03\x20\x01(\x0b2\x13.Wa\
    tchableMatchInfoR\x12watchablematchinfo\x12\\\n\x11roundstats_legacy\x18\
    \x04\x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingServerRoundStatsR\x10r\
    oundstatsLegacy\x12U\n\rroundstatsall\x18\x05\x20\x03(\x0b2/.CMsgGCCStri\
    ke15_v2_MatchmakingServerRoundStatsR\rroundstatsall\"z\n'CDataGCCStrike1\
    5_v2_TournamentGroupTeam\x12\x17\n\x07team_id\x18\x01\x20\x01(\x05R\x06t\
    eamId\x12\x14\n\x05score\x18\x02\x20\x01(\x05R\x05score\x12\x20\n\x0bcor\
    rectpick\x18\x03\x20\x01(\x08R\x0bcorrectpick\"\xd1\x03\n#CDataGCCStrike\
    15_v2_TournamentGroup\x12\x18\n\x07groupid\x18\x01\x20\x01(\rR\x07groupi\
    d\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04desc\x18\
    \x03\x20\x01(\tR\x04desc\x12*\n\x11picks__deprecated\x18\x04\x20\x01(\rR\
    \x0fpicksDeprecated\x12>\n\x05teams\x18\x05\x20\x03(\x0b2(.CDataGCCStrik\
    e15_v2_TournamentGroupTeamR\x05teams\x12\x1b\n\tstage_ids\x18\x06\x20\
    \x03(\x05R\x08stageIds\x12,\n\x11picklockuntiltime\x18\x07\x20\x01(\rR\
    \x11picklockuntiltime\x12$\n\rpickableteams\x18\x08\x20\x01(\rR\rpickabl\
    eteams\x12&\n\x0fpoints_per_pick\x18\t\x20\x01(\rR\rpointsPerPick\x12@\n\
    \x05picks\x18\n\x20\x03(\x0b2*.CDataGCCStrike15_v2_TournamentGroup.Picks\
    R\x05picks\x1a!\n\x05Picks\x12\x18\n\x07pickids\x18\x01\x20\x03(\x05R\
    \x07pickids\"\xab\x01\n%CDataGCCStrike15_v2_TournamentSection\x12\x1c\n\
    \tsectionid\x18\x01\x20\x01(\rR\tsectionid\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x12\n\x04desc\x18\x03\x20\x01(\tR\x04desc\x12<\n\
    \x06groups\x18\x04\x20\x03(\x0b2$.CDataGCCStrike15_v2_TournamentGroupR\
    \x06groups\"\xe1\x01\n\"CDataGCCStrike15_v2_TournamentInfo\x12B\n\x08sec\
    tions\x18\x01\x20\x03(\x0b2&.CDataGCCStrike15_v2_TournamentSectionR\x08s\
    ections\x12;\n\x10tournament_event\x18\x02\x20\x01(\x0b2\x10.TournamentE\
    ventR\x0ftournamentEvent\x12:\n\x10tournament_teams\x18\x03\x20\x03(\x0b\
    2\x0f.TournamentTeamR\x0ftournamentTeams\"\xb2\x02\n\x1cCMsgGCCStrike15_\
    v2_MatchList\x12\"\n\x0cmsgrequestid\x18\x01\x20\x01(\rR\x0cmsgrequestid\
    \x12\x1c\n\taccountid\x18\x02\x20\x01(\rR\taccountid\x12\x1e\n\nserverti\
    me\x18\x03\x20\x01(\rR\nservertime\x128\n\x07matches\x18\x04\x20\x03(\
    \x0b2\x1e.CDataGCCStrike15_v2_MatchInfoR\x07matches\x12)\n\x07streams\
    \x18\x05\x20\x03(\x0b2\x0f.TournamentTeamR\x07streams\x12K\n\x0etourname\
    ntinfo\x18\x06\x20\x01(\x0b2#.CDataGCCStrike15_v2_TournamentInfoR\x0etou\
    rnamentinfo\"\xb9\x02\n\x1eCMsgGCCStrike15_v2_Predictions\x12\x19\n\x08e\
    vent_id\x18\x01\x20\x01(\rR\x07eventId\x12g\n\x16group_match_team_picks\
    \x18\x02\x20\x03(\x0b22.CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPic\
    kR\x13groupMatchTeamPicks\x1a\x92\x01\n\x12GroupMatchTeamPick\x12\x1c\n\
    \tsectionid\x18\x01\x20\x01(\x05R\tsectionid\x12\x18\n\x07groupid\x18\
    \x02\x20\x01(\x05R\x07groupid\x12\x14\n\x05index\x18\x03\x20\x01(\x05R\
    \x05index\x12\x16\n\x06teamid\x18\x04\x20\x01(\x05R\x06teamid\x12\x16\n\
    \x06itemid\x18\x05\x20\x01(\x04R\x06itemid\"\xb1\x02\n\x1aCMsgGCCStrike1\
    5_v2_Fantasy\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12=\n\
    \x05teams\x18\x02\x20\x03(\x0b2'.CMsgGCCStrike15_v2_Fantasy.FantasyTeamR\
    \x05teams\x1aM\n\x0bFantasySlot\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\
    \x04type\x12\x12\n\x04pick\x18\x02\x20\x01(\x05R\x04pick\x12\x16\n\x06it\
    emid\x18\x03\x20\x01(\x04R\x06itemid\x1aj\n\x0bFantasyTeam\x12\x1c\n\tse\
    ctionid\x18\x01\x20\x01(\x05R\tsectionid\x12=\n\x05slots\x18\x02\x20\x03\
    (\x0b2'.CMsgGCCStrike15_v2_Fantasy.FantasySlotR\x05slots\")\n\x11CAttrib\
    ute_String\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\"\x1a\n\x18CM\
    sgGCToGCReloadVersions\"\xb2\x02\n\x14CMsgCStrike15Welcome\x12&\n\x0fsto\
    re_item_hash\x18\x05\x20\x01(\rR\rstoreItemHash\x128\n\x17timeplayedcons\
    ecutively\x18\x06\x20\x01(\rR\x17timeplayedconsecutively\x12*\n\x11time_\
    first_played\x18\n\x20\x01(\rR\x0ftimeFirstPlayed\x12(\n\x10last_time_pl\
    ayed\x18\x0c\x20\x01(\rR\x0elastTimePlayed\x12&\n\x0flast_ip_address\x18\
    \r\x20\x01(\rR\rlastIpAddress\x12\x1e\n\ngscookieid\x18\x12\x20\x01(\x04\
    R\ngscookieid\x12\x1a\n\x08uniqueid\x18\x13\x20\x01(\x04R\x08uniqueid\"\
    \xd6\x01\n1CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\x12\x1d\n\n\
    value_name\x18\x01\x20\x01(\tR\tvalueName\x12\x1b\n\tvalue_int\x18\x02\
    \x20\x01(\x05R\x08valueInt\x12\x1f\n\x0bserver_addr\x18\x03\x20\x01(\rR\
    \nserverAddr\x12\x1f\n\x0bserver_port\x18\x04\x20\x01(\rR\nserverPort\
    \x12#\n\rchoked_blocks\x18\x05\x20\x03(\tR\x0cchokedBlocks\"\x85\x01\n1C\
    MsgGCCStrike15_v2_ServerVarValueNotificationInfo\x12\x1c\n\taccountid\
    \x18\x01\x20\x01(\rR\taccountid\x12\x1e\n\nviewangles\x18\x02\x20\x03(\r\
    R\nviewangles\x12\x12\n\x04type\x18\x03\x20\x01(\rR\x04type\",\n*CMsgGCC\
    Strike15_v2_GiftsLeaderboardRequest\"\xf5\x02\n+CMsgGCCStrike15_v2_Gifts\
    LeaderboardResponse\x12\x1e\n\nservertime\x18\x01\x20\x01(\rR\nservertim\
    e\x12.\n\x13time_period_seconds\x18\x02\x20\x01(\rR\x11timePeriodSeconds\
    \x12*\n\x11total_gifts_given\x18\x03\x20\x01(\rR\x0ftotalGiftsGiven\x12!\
    \n\x0ctotal_givers\x18\x04\x20\x01(\rR\x0btotalGivers\x12[\n\x07entries\
    \x18\x05\x20\x03(\x0b2A.CMsgGCCStrike15_v2_GiftsLeaderboardResponse.Gift\
    LeaderboardEntryR\x07entries\x1aJ\n\x14GiftLeaderboardEntry\x12\x1c\n\ta\
    ccountid\x18\x01\x20\x01(\rR\taccountid\x12\x14\n\x05gifts\x18\x02\x20\
    \x01(\rR\x05gifts\"\\\n)CMsgGCCStrike15_v2_ClientSubmitSurveyVote\x12\
    \x1b\n\tsurvey_id\x18\x01\x20\x01(\rR\x08surveyId\x12\x12\n\x04vote\x18\
    \x02\x20\x01(\rR\x04vote\"J\n*CMsgGCCStrike15_v2_Server2GCClientValidate\
    \x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\"\xfa\x01\n7CMsgGCC\
    Strike15_v2_Server2GCPureServerValidationFailure\x12\x1c\n\taccountid\
    \x18\x01\x20\x01(\rR\taccountid\x12\x12\n\x04path\x18\x02\x20\x01(\tR\
    \x04path\x12\x12\n\x04file\x18\x03\x20\x01(\tR\x04file\x12\x10\n\x03crc\
    \x18\x04\x20\x01(\rR\x03crc\x12\x12\n\x04hash\x18\x05\x20\x01(\x05R\x04h\
    ash\x12\x10\n\x03len\x18\x06\x20\x01(\x05R\x03len\x12\x1f\n\x0bpack_numb\
    er\x18\x07\x20\x01(\x05R\npackNumber\x12\x20\n\x0cpack_file_id\x18\x08\
    \x20\x01(\x05R\npackFileId\"\x97\x01\n*CMsgGCCStrike15_v2_GC2ClientTourn\
    amentInfo\x12\x18\n\x07eventid\x18\x01\x20\x01(\rR\x07eventid\x12\x18\n\
    \x07stageid\x18\x02\x20\x01(\rR\x07stageid\x12\x1b\n\tgame_type\x18\x03\
    \x20\x01(\rR\x08gameType\x12\x18\n\x07teamids\x18\x04\x20\x03(\rR\x07tea\
    mids\"p\n\rCSOEconCoupon\x12\x1e\n\x07entryid\x18\x01\x20\x01(\rR\x07ent\
    ryidB\x04\x80\xa6\x1d\x01\x12\x16\n\x06defidx\x18\x02\x20\x01(\rR\x06def\
    idx\x12'\n\x0fexpiration_date\x18\x03\x20\x01(\x07R\x0eexpirationDate\"\
    \x80\x01\n\x10CSOQuestProgress\x12\x1e\n\x07questid\x18\x01\x20\x01(\rR\
    \x07questidB\x04\x80\xa6\x1d\x01\x12)\n\x10points_remaining\x18\x02\x20\
    \x01(\rR\x0fpointsRemaining\x12!\n\x0cbonus_points\x18\x03\x20\x01(\rR\
    \x0bbonusPoints\"\x9d\x01\n\x14CSOPersonaDataPublic\x12!\n\x0cplayer_lev\
    el\x18\x01\x20\x01(\x05R\x0bplayerLevel\x12;\n\x0ccommendation\x18\x02\
    \x20\x01(\x0b2\x17.PlayerCommendationInfoR\x0ccommendation\x12%\n\x0eele\
    vated_state\x18\x03\x20\x01(\x08R\relevatedState\"5\n\x1bCMsgGC_GlobalGa\
    me_Subscribe\x12\x16\n\x06ticket\x18\x01\x20\x01(\x04R\x06ticket\";\n\
    \x1dCMsgGC_GlobalGame_Unsubscribe\x12\x1a\n\x08timeleft\x18\x01\x20\x01(\
    \x05R\x08timeleft\"p\n\x16CMsgGC_GlobalGame_Play\x12\x16\n\x06ticket\x18\
    \x01\x20\x01(\x04R\x06ticket\x12\x1e\n\ngametimems\x18\x02\x20\x01(\rR\n\
    gametimems\x12\x1e\n\nmsperpoint\x18\x03\x20\x01(\rR\nmsperpoint\"K\n%CM\
    sgGCCStrike15_v2_AcknowledgePenalty\x12\"\n\x0cacknowledged\x18\x01\x20\
    \x01(\x05R\x0cacknowledged\"1\n/CMsgGCCStrike15_v2_Client2GCRequestPrest\
    igeCoin\"R\n(CMsgGCCStrike15_v2_Client2GCStreamUnlock\x12\x16\n\x06ticke\
    t\x18\x01\x20\x01(\x04R\x06ticket\x12\x0e\n\x02os\x18\x02\x20\x01(\x05R\
    \x02os\"C\n+CMsgGCCStrike15_v2_ClientToGCRequestElevate\x12\x14\n\x05sta\
    ge\x18\x01\x20\x01(\rR\x05stage\"R\n!CMsgGCCStrike15_v2_ClientToGCChat\
    \x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x12\n\x04tex\
    t\x18\x02\x20\x01(\tR\x04text\"V\n!CMsgGCCStrike15_v2_GCToClientChat\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x12\n\x04text\x18\
    \x02\x20\x01(\tR\x04text*\xb9\x20\n\nECsgoGCMsg\x12\x1e\n\x19k_EMsgGCCSt\
    rike15_v2_Base\x10\x8cG\x12*\n%k_EMsgGCCStrike15_v2_MatchmakingStart\x10\
    \x8dG\x12)\n$k_EMsgGCCStrike15_v2_MatchmakingStop\x10\x8eG\x126\n1k_EMsg\
    GCCStrike15_v2_MatchmakingClient2ServerPing\x10\x8fG\x124\n/k_EMsgGCCStr\
    ike15_v2_MatchmakingGC2ClientUpdate\x10\x90G\x125\n0k_EMsgGCCStrike15_v2\
    _MatchmakingGC2ServerReserve\x10\x91G\x12>\n9k_EMsgGCCStrike15_v2_Matchm\
    akingServerReservationResponse\x10\x92G\x125\n0k_EMsgGCCStrike15_v2_Matc\
    hmakingGC2ClientReserve\x10\x93G\x125\n0k_EMsgGCCStrike15_v2_Matchmaking\
    ServerRoundStats\x10\x94G\x123\n.k_EMsgGCCStrike15_v2_MatchmakingClient2\
    GCHello\x10\x95G\x123\n.k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello\
    \x10\x96G\x123\n.k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd\x10\x97G\
    \x125\n0k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\x10\x98G\x122\n\
    -k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick\x10\x99G\x125\n0k_EMsgGCC\
    Strike15_v2_MatchmakingGC2ServerConfirm\x10\x9aG\x127\n2k_EMsgGCCStrike1\
    5_v2_MatchmakingGCOperationalStats\x10\x9bG\x128\n3k_EMsgGCCStrike15_v2_\
    MatchmakingGC2ServerRankUpdate\x10\x9cG\x12:\n5k_EMsgGCCStrike15_v2_Matc\
    hmakingOperator2GCBlogUpdate\x10\x9dG\x12:\n5k_EMsgGCCStrike15_v2_Server\
    NotificationForUserPenalty\x10\x9eG\x12,\n'k_EMsgGCCStrike15_v2_ClientRe\
    portPlayer\x10\x9fG\x12,\n'k_EMsgGCCStrike15_v2_ClientReportServer\x10\
    \xa0G\x12-\n(k_EMsgGCCStrike15_v2_ClientCommendPlayer\x10\xa1G\x12.\n)k_\
    EMsgGCCStrike15_v2_ClientReportResponse\x10\xa2G\x122\n-k_EMsgGCCStrike1\
    5_v2_ClientCommendPlayerQuery\x10\xa3G\x12:\n5k_EMsgGCCStrike15_v2_Clien\
    tCommendPlayerQueryResponse\x10\xa4G\x12(\n#k_EMsgGCCStrike15_v2_WatchIn\
    foUsers\x10\xa6G\x125\n0k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile\
    \x10\xa7G\x12(\n#k_EMsgGCCStrike15_v2_PlayersProfile\x10\xa8G\x12)\n$k_E\
    MsgGCCStrike15_v2_SetMyMedalsInfo\x10\xa9G\x123\n.k_EMsgGCCStrike15_v2_P\
    layerOverwatchCaseUpdate\x10\xabG\x127\n2k_EMsgGCCStrike15_v2_PlayerOver\
    watchCaseAssignment\x10\xacG\x123\n.k_EMsgGCCStrike15_v2_PlayerOverwatch\
    CaseStatus\x10\xadG\x12*\n%k_EMsgGCCStrike15_v2_GC2ClientTextMsg\x10\xae\
    G\x12*\n%k_EMsgGCCStrike15_v2_Client2GCTextMsg\x10\xafG\x120\n+k_EMsgGCC\
    Strike15_v2_MatchEndRunRewardDrops\x10\xb0G\x129\n4k_EMsgGCCStrike15_v2_\
    MatchEndRewardDropsNotification\x10\xb1G\x128\n3k_EMsgGCCStrike15_v2_Cli\
    entRequestWatchInfoFriends2\x10\xb2G\x12#\n\x1ek_EMsgGCCStrike15_v2_Matc\
    hList\x10\xb3G\x12:\n5k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGa\
    mes\x10\xb4G\x129\n4k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames\
    \x10\xb5G\x124\n/k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate\x10\xb6\
    G\x128\n3k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo\x10\xb8G\
    \x12@\n;k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\x10\
    \xb9G\x129\n4k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames\x10\
    \xbaG\x126\n1k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo\x10\xbbG\
    \x121\n,k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest\x10\xbcG\x122\n-k_E\
    MsgGCCStrike15_v2_GiftsLeaderboardResponse\x10\xbdG\x128\n3k_EMsgGCCStri\
    ke15_v2_ServerVarValueNotificationInfo\x10\xbeG\x12\x1f\n\x1ak_EMsgGCToG\
    CReloadVersions\x10\xbfG\x120\n+k_EMsgGCCStrike15_v2_ClientSubmitSurveyV\
    ote\x10\xc0G\x121\n,k_EMsgGCCStrike15_v2_Server2GCClientValidate\x10\xc1\
    G\x129\n4k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\x10\xc2G\
    \x12>\n9k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\x10\
    \xc3G\x12>\n9k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\
    \x10\xc4G\x12?\n:k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRespo\
    nse\x10\xc5G\x120\n+k_EMsgGCCStrike15_v2_AccountPrivacySettings\x10\xc6G\
    \x12+\n&k_EMsgGCCStrike15_v2_SetMyActivityInfo\x10\xc7G\x12?\n:k_EMsgGCC\
    Strike15_v2_MatchListRequestTournamentPredictions\x10\xc8G\x12>\n9k_EMsg\
    GCCStrike15_v2_MatchListUploadTournamentPredictions\x10\xc9G\x12&\n!k_EM\
    sgGCCStrike15_v2_DraftSummary\x10\xcaG\x125\n0k_EMsgGCCStrike15_v2_Clien\
    tRequestJoinFriendData\x10\xcbG\x125\n0k_EMsgGCCStrike15_v2_ClientReques\
    tJoinServerData\x10\xccG\x121\n,k_EMsgGCCStrike15_v2_ClientRequestNewMis\
    sion\x10\xcdG\x123\n.k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded\x10\
    \xceG\x121\n,k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo\x10\xcfG\x12\"\
    \n\x1dk_EMsgGC_GlobalGame_Subscribe\x10\xd0G\x12$\n\x1fk_EMsgGC_GlobalGa\
    me_Unsubscribe\x10\xd1G\x12\x1d\n\x18k_EMsgGC_GlobalGame_Play\x10\xd2G\
    \x12,\n'k_EMsgGCCStrike15_v2_AcknowledgePenalty\x10\xd3G\x126\n1k_EMsgGC\
    CStrike15_v2_Client2GCRequestPrestigeCoin\x10\xd4G\x12.\n)k_EMsgGCCStrik\
    e15_v2_GC2ClientGlobalStats\x10\xd5G\x12/\n*k_EMsgGCCStrike15_v2_Client2\
    GCStreamUnlock\x10\xd6G\x122\n-k_EMsgGCCStrike15_v2_FantasyRequestClient\
    Data\x10\xd7G\x121\n,k_EMsgGCCStrike15_v2_FantasyUpdateClientData\x10\
    \xd8G\x127\n2k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket\x10\xd9G\
    \x121\n,k_EMsgGCCStrike15_v2_ClientToGCRequestTicket\x10\xdaG\x122\n-k_E\
    MsgGCCStrike15_v2_ClientToGCRequestElevate\x10\xdbG\x12$\n\x1fk_EMsgGCCS\
    trike15_v2_GlobalChat\x10\xdcG\x12.\n)k_EMsgGCCStrike15_v2_GlobalChat_Su\
    bscribe\x10\xddG\x120\n+k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe\x10\
    \xdeGB\x05H\x01\x80\x01\0J\xde\xe3\x02\n\x07\x12\x05\0\0\xc1\x07\x01\n\t\
    \n\x02\x03\0\x12\x03\0\x07\x1c\n\x08\n\x01\x08\x12\x03\x02\0\x1c\n\x0b\n\
    \x04\x08\xe7\x07\0\x12\x03\x02\0\x1c\n\x0c\n\x05\x08\xe7\x07\0\x02\x12\
    \x03\x02\x07\x13\n\r\n\x06\x08\xe7\x07\0\x02\0\x12\x03\x02\x07\x13\n\x0e\
    \n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\x02\x07\x13\n\x0c\n\x05\x08\xe7\
    \x07\0\x03\x12\x03\x02\x16\x1b\n\x08\n\x01\x08\x12\x03\x03\0#\n\x0b\n\
    \x04\x08\xe7\x07\x01\x12\x03\x03\0#\n\x0c\n\x05\x08\xe7\x07\x01\x02\x12\
    \x03\x03\x07\x1a\n\r\n\x06\x08\xe7\x07\x01\x02\0\x12\x03\x03\x07\x1a\n\
    \x0e\n\x07\x08\xe7\x07\x01\x02\0\x01\x12\x03\x03\x07\x1a\n\x0c\n\x05\x08\
    \xe7\x07\x01\x03\x12\x03\x03\x1d\"\n\n\n\x02\x05\0\x12\x04\x05\0V\x01\n\
    \n\n\x03\x05\0\x01\x12\x03\x05\x05\x0f\n\x0b\n\x04\x05\0\x02\0\x12\x03\
    \x06\x08)\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x06\x08!\n\x0c\n\x05\x05\0\
    \x02\0\x02\x12\x03\x06$(\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x07\x085\n\
    \x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x07\x08-\n\x0c\n\x05\x05\0\x02\x01\
    \x02\x12\x03\x0704\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x08\x084\n\x0c\n\
    \x05\x05\0\x02\x02\x01\x12\x03\x08\x08,\n\x0c\n\x05\x05\0\x02\x02\x02\
    \x12\x03\x08/3\n\x0b\n\x04\x05\0\x02\x03\x12\x03\t\x08A\n\x0c\n\x05\x05\
    \0\x02\x03\x01\x12\x03\t\x089\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\t<@\
    \n\x0b\n\x04\x05\0\x02\x04\x12\x03\n\x08?\n\x0c\n\x05\x05\0\x02\x04\x01\
    \x12\x03\n\x087\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\n:>\n\x0b\n\x04\
    \x05\0\x02\x05\x12\x03\x0b\x08@\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\
    \x0b\x088\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x0b;?\n\x0b\n\x04\x05\0\
    \x02\x06\x12\x03\x0c\x08I\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x0c\x08A\
    \n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x0cDH\n\x0b\n\x04\x05\0\x02\x07\
    \x12\x03\r\x08@\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\r\x088\n\x0c\n\x05\
    \x05\0\x02\x07\x02\x12\x03\r;?\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x0e\x08\
    @\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\x0e\x088\n\x0c\n\x05\x05\0\x02\
    \x08\x02\x12\x03\x0e;?\n\x0b\n\x04\x05\0\x02\t\x12\x03\x0f\x08>\n\x0c\n\
    \x05\x05\0\x02\t\x01\x12\x03\x0f\x086\n\x0c\n\x05\x05\0\x02\t\x02\x12\
    \x03\x0f9=\n\x0b\n\x04\x05\0\x02\n\x12\x03\x10\x08>\n\x0c\n\x05\x05\0\
    \x02\n\x01\x12\x03\x10\x086\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x109=\n\
    \x0b\n\x04\x05\0\x02\x0b\x12\x03\x11\x08>\n\x0c\n\x05\x05\0\x02\x0b\x01\
    \x12\x03\x11\x086\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x119=\n\x0b\n\
    \x04\x05\0\x02\x0c\x12\x03\x12\x08@\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\
    \x03\x12\x088\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\x12;?\n\x0b\n\x04\
    \x05\0\x02\r\x12\x03\x13\x08=\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x13\
    \x085\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\x138<\n\x0b\n\x04\x05\0\x02\
    \x0e\x12\x03\x14\x08@\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\x03\x14\x088\n\
    \x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\x14;?\n\x0b\n\x04\x05\0\x02\x0f\x12\
    \x03\x15\x08B\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\x03\x15\x08:\n\x0c\n\x05\
    \x05\0\x02\x0f\x02\x12\x03\x15=A\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x16\
    \x08C\n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03\x16\x08;\n\x0c\n\x05\x05\0\
    \x02\x10\x02\x12\x03\x16>B\n\x0b\n\x04\x05\0\x02\x11\x12\x03\x17\x08E\n\
    \x0c\n\x05\x05\0\x02\x11\x01\x12\x03\x17\x08=\n\x0c\n\x05\x05\0\x02\x11\
    \x02\x12\x03\x17@D\n\x0b\n\x04\x05\0\x02\x12\x12\x03\x18\x08E\n\x0c\n\
    \x05\x05\0\x02\x12\x01\x12\x03\x18\x08=\n\x0c\n\x05\x05\0\x02\x12\x02\
    \x12\x03\x18@D\n\x0b\n\x04\x05\0\x02\x13\x12\x03\x19\x087\n\x0c\n\x05\
    \x05\0\x02\x13\x01\x12\x03\x19\x08/\n\x0c\n\x05\x05\0\x02\x13\x02\x12\
    \x03\x1926\n\x0b\n\x04\x05\0\x02\x14\x12\x03\x1a\x087\n\x0c\n\x05\x05\0\
    \x02\x14\x01\x12\x03\x1a\x08/\n\x0c\n\x05\x05\0\x02\x14\x02\x12\x03\x1a2\
    6\n\x0b\n\x04\x05\0\x02\x15\x12\x03\x1b\x088\n\x0c\n\x05\x05\0\x02\x15\
    \x01\x12\x03\x1b\x080\n\x0c\n\x05\x05\0\x02\x15\x02\x12\x03\x1b37\n\x0b\
    \n\x04\x05\0\x02\x16\x12\x03\x1c\x089\n\x0c\n\x05\x05\0\x02\x16\x01\x12\
    \x03\x1c\x081\n\x0c\n\x05\x05\0\x02\x16\x02\x12\x03\x1c48\n\x0b\n\x04\
    \x05\0\x02\x17\x12\x03\x1d\x08=\n\x0c\n\x05\x05\0\x02\x17\x01\x12\x03\
    \x1d\x085\n\x0c\n\x05\x05\0\x02\x17\x02\x12\x03\x1d8<\n\x0b\n\x04\x05\0\
    \x02\x18\x12\x03\x1e\x08E\n\x0c\n\x05\x05\0\x02\x18\x01\x12\x03\x1e\x08=\
    \n\x0c\n\x05\x05\0\x02\x18\x02\x12\x03\x1e@D\n\x0b\n\x04\x05\0\x02\x19\
    \x12\x03\x1f\x083\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03\x1f\x08+\n\x0c\n\
    \x05\x05\0\x02\x19\x02\x12\x03\x1f.2\n\x0b\n\x04\x05\0\x02\x1a\x12\x03\
    \x20\x08@\n\x0c\n\x05\x05\0\x02\x1a\x01\x12\x03\x20\x088\n\x0c\n\x05\x05\
    \0\x02\x1a\x02\x12\x03\x20;?\n\x0b\n\x04\x05\0\x02\x1b\x12\x03!\x083\n\
    \x0c\n\x05\x05\0\x02\x1b\x01\x12\x03!\x08+\n\x0c\n\x05\x05\0\x02\x1b\x02\
    \x12\x03!.2\n\x0b\n\x04\x05\0\x02\x1c\x12\x03\"\x084\n\x0c\n\x05\x05\0\
    \x02\x1c\x01\x12\x03\"\x08,\n\x0c\n\x05\x05\0\x02\x1c\x02\x12\x03\"/3\n\
    \x0b\n\x04\x05\0\x02\x1d\x12\x03#\x08>\n\x0c\n\x05\x05\0\x02\x1d\x01\x12\
    \x03#\x086\n\x0c\n\x05\x05\0\x02\x1d\x02\x12\x03#9=\n\x0b\n\x04\x05\0\
    \x02\x1e\x12\x03$\x08B\n\x0c\n\x05\x05\0\x02\x1e\x01\x12\x03$\x08:\n\x0c\
    \n\x05\x05\0\x02\x1e\x02\x12\x03$=A\n\x0b\n\x04\x05\0\x02\x1f\x12\x03%\
    \x08>\n\x0c\n\x05\x05\0\x02\x1f\x01\x12\x03%\x086\n\x0c\n\x05\x05\0\x02\
    \x1f\x02\x12\x03%9=\n\x0b\n\x04\x05\0\x02\x20\x12\x03&\x085\n\x0c\n\x05\
    \x05\0\x02\x20\x01\x12\x03&\x08-\n\x0c\n\x05\x05\0\x02\x20\x02\x12\x03&0\
    4\n\x0b\n\x04\x05\0\x02!\x12\x03'\x085\n\x0c\n\x05\x05\0\x02!\x01\x12\
    \x03'\x08-\n\x0c\n\x05\x05\0\x02!\x02\x12\x03'04\n\x0b\n\x04\x05\0\x02\"\
    \x12\x03(\x08;\n\x0c\n\x05\x05\0\x02\"\x01\x12\x03(\x083\n\x0c\n\x05\x05\
    \0\x02\"\x02\x12\x03(6:\n\x0b\n\x04\x05\0\x02#\x12\x03)\x08D\n\x0c\n\x05\
    \x05\0\x02#\x01\x12\x03)\x08<\n\x0c\n\x05\x05\0\x02#\x02\x12\x03)?C\n\
    \x0b\n\x04\x05\0\x02$\x12\x03*\x08C\n\x0c\n\x05\x05\0\x02$\x01\x12\x03*\
    \x08;\n\x0c\n\x05\x05\0\x02$\x02\x12\x03*>B\n\x0b\n\x04\x05\0\x02%\x12\
    \x03+\x08.\n\x0c\n\x05\x05\0\x02%\x01\x12\x03+\x08&\n\x0c\n\x05\x05\0\
    \x02%\x02\x12\x03+)-\n\x0b\n\x04\x05\0\x02&\x12\x03,\x08E\n\x0c\n\x05\
    \x05\0\x02&\x01\x12\x03,\x08=\n\x0c\n\x05\x05\0\x02&\x02\x12\x03,@D\n\
    \x0b\n\x04\x05\0\x02'\x12\x03-\x08D\n\x0c\n\x05\x05\0\x02'\x01\x12\x03-\
    \x08<\n\x0c\n\x05\x05\0\x02'\x02\x12\x03-?C\n\x0b\n\x04\x05\0\x02(\x12\
    \x03.\x08?\n\x0c\n\x05\x05\0\x02(\x01\x12\x03.\x087\n\x0c\n\x05\x05\0\
    \x02(\x02\x12\x03.:>\n\x0b\n\x04\x05\0\x02)\x12\x03/\x08C\n\x0c\n\x05\
    \x05\0\x02)\x01\x12\x03/\x08;\n\x0c\n\x05\x05\0\x02)\x02\x12\x03/>B\n\
    \x0b\n\x04\x05\0\x02*\x12\x030\x08K\n\x0c\n\x05\x05\0\x02*\x01\x12\x030\
    \x08C\n\x0c\n\x05\x05\0\x02*\x02\x12\x030FJ\n\x0b\n\x04\x05\0\x02+\x12\
    \x031\x08D\n\x0c\n\x05\x05\0\x02+\x01\x12\x031\x08<\n\x0c\n\x05\x05\0\
    \x02+\x02\x12\x031?C\n\x0b\n\x04\x05\0\x02,\x12\x032\x08A\n\x0c\n\x05\
    \x05\0\x02,\x01\x12\x032\x089\n\x0c\n\x05\x05\0\x02,\x02\x12\x032<@\n\
    \x0b\n\x04\x05\0\x02-\x12\x033\x08<\n\x0c\n\x05\x05\0\x02-\x01\x12\x033\
    \x084\n\x0c\n\x05\x05\0\x02-\x02\x12\x0337;\n\x0b\n\x04\x05\0\x02.\x12\
    \x034\x08=\n\x0c\n\x05\x05\0\x02.\x01\x12\x034\x085\n\x0c\n\x05\x05\0\
    \x02.\x02\x12\x0348<\n\x0b\n\x04\x05\0\x02/\x12\x035\x08C\n\x0c\n\x05\
    \x05\0\x02/\x01\x12\x035\x08;\n\x0c\n\x05\x05\0\x02/\x02\x12\x035>B\n\
    \x0b\n\x04\x05\0\x020\x12\x036\x08*\n\x0c\n\x05\x05\0\x020\x01\x12\x036\
    \x08\"\n\x0c\n\x05\x05\0\x020\x02\x12\x036%)\n\x0b\n\x04\x05\0\x021\x12\
    \x037\x08;\n\x0c\n\x05\x05\0\x021\x01\x12\x037\x083\n\x0c\n\x05\x05\0\
    \x021\x02\x12\x0376:\n\x0b\n\x04\x05\0\x022\x12\x038\x08<\n\x0c\n\x05\
    \x05\0\x022\x01\x12\x038\x084\n\x0c\n\x05\x05\0\x022\x02\x12\x0387;\n\
    \x0b\n\x04\x05\0\x023\x12\x039\x08D\n\x0c\n\x05\x05\0\x023\x01\x12\x039\
    \x08<\n\x0c\n\x05\x05\0\x023\x02\x12\x039?C\n\x0b\n\x04\x05\0\x024\x12\
    \x03:\x08I\n\x0c\n\x05\x05\0\x024\x01\x12\x03:\x08A\n\x0c\n\x05\x05\0\
    \x024\x02\x12\x03:DH\n\x0b\n\x04\x05\0\x025\x12\x03;\x08I\n\x0c\n\x05\
    \x05\0\x025\x01\x12\x03;\x08A\n\x0c\n\x05\x05\0\x025\x02\x12\x03;DH\n\
    \x0b\n\x04\x05\0\x026\x12\x03<\x08J\n\x0c\n\x05\x05\0\x026\x01\x12\x03<\
    \x08B\n\x0c\n\x05\x05\0\x026\x02\x12\x03<EI\n\x0b\n\x04\x05\0\x027\x12\
    \x03=\x08;\n\x0c\n\x05\x05\0\x027\x01\x12\x03=\x083\n\x0c\n\x05\x05\0\
    \x027\x02\x12\x03=6:\n\x0b\n\x04\x05\0\x028\x12\x03>\x086\n\x0c\n\x05\
    \x05\0\x028\x01\x12\x03>\x08.\n\x0c\n\x05\x05\0\x028\x02\x12\x03>15\n\
    \x0b\n\x04\x05\0\x029\x12\x03?\x08J\n\x0c\n\x05\x05\0\x029\x01\x12\x03?\
    \x08B\n\x0c\n\x05\x05\0\x029\x02\x12\x03?EI\n\x0b\n\x04\x05\0\x02:\x12\
    \x03@\x08I\n\x0c\n\x05\x05\0\x02:\x01\x12\x03@\x08A\n\x0c\n\x05\x05\0\
    \x02:\x02\x12\x03@DH\n\x0b\n\x04\x05\0\x02;\x12\x03A\x081\n\x0c\n\x05\
    \x05\0\x02;\x01\x12\x03A\x08)\n\x0c\n\x05\x05\0\x02;\x02\x12\x03A,0\n\
    \x0b\n\x04\x05\0\x02<\x12\x03B\x08@\n\x0c\n\x05\x05\0\x02<\x01\x12\x03B\
    \x088\n\x0c\n\x05\x05\0\x02<\x02\x12\x03B;?\n\x0b\n\x04\x05\0\x02=\x12\
    \x03C\x08@\n\x0c\n\x05\x05\0\x02=\x01\x12\x03C\x088\n\x0c\n\x05\x05\0\
    \x02=\x02\x12\x03C;?\n\x0b\n\x04\x05\0\x02>\x12\x03D\x08<\n\x0c\n\x05\
    \x05\0\x02>\x01\x12\x03D\x084\n\x0c\n\x05\x05\0\x02>\x02\x12\x03D7;\n\
    \x0b\n\x04\x05\0\x02?\x12\x03E\x08>\n\x0c\n\x05\x05\0\x02?\x01\x12\x03E\
    \x086\n\x0c\n\x05\x05\0\x02?\x02\x12\x03E9=\n\x0b\n\x04\x05\0\x02@\x12\
    \x03F\x08<\n\x0c\n\x05\x05\0\x02@\x01\x12\x03F\x084\n\x0c\n\x05\x05\0\
    \x02@\x02\x12\x03F7;\n\x0b\n\x04\x05\0\x02A\x12\x03G\x08-\n\x0c\n\x05\
    \x05\0\x02A\x01\x12\x03G\x08%\n\x0c\n\x05\x05\0\x02A\x02\x12\x03G(,\n\
    \x0b\n\x04\x05\0\x02B\x12\x03H\x08/\n\x0c\n\x05\x05\0\x02B\x01\x12\x03H\
    \x08'\n\x0c\n\x05\x05\0\x02B\x02\x12\x03H*.\n\x0b\n\x04\x05\0\x02C\x12\
    \x03I\x08(\n\x0c\n\x05\x05\0\x02C\x01\x12\x03I\x08\x20\n\x0c\n\x05\x05\0\
    \x02C\x02\x12\x03I#'\n\x0b\n\x04\x05\0\x02D\x12\x03J\x087\n\x0c\n\x05\
    \x05\0\x02D\x01\x12\x03J\x08/\n\x0c\n\x05\x05\0\x02D\x02\x12\x03J26\n\
    \x0b\n\x04\x05\0\x02E\x12\x03K\x08A\n\x0c\n\x05\x05\0\x02E\x01\x12\x03K\
    \x089\n\x0c\n\x05\x05\0\x02E\x02\x12\x03K<@\n\x0b\n\x04\x05\0\x02F\x12\
    \x03L\x089\n\x0c\n\x05\x05\0\x02F\x01\x12\x03L\x081\n\x0c\n\x05\x05\0\
    \x02F\x02\x12\x03L48\n\x0b\n\x04\x05\0\x02G\x12\x03M\x08:\n\x0c\n\x05\
    \x05\0\x02G\x01\x12\x03M\x082\n\x0c\n\x05\x05\0\x02G\x02\x12\x03M59\n\
    \x0b\n\x04\x05\0\x02H\x12\x03N\x08=\n\x0c\n\x05\x05\0\x02H\x01\x12\x03N\
    \x085\n\x0c\n\x05\x05\0\x02H\x02\x12\x03N8<\n\x0b\n\x04\x05\0\x02I\x12\
    \x03O\x08<\n\x0c\n\x05\x05\0\x02I\x01\x12\x03O\x084\n\x0c\n\x05\x05\0\
    \x02I\x02\x12\x03O7;\n\x0b\n\x04\x05\0\x02J\x12\x03P\x08B\n\x0c\n\x05\
    \x05\0\x02J\x01\x12\x03P\x08:\n\x0c\n\x05\x05\0\x02J\x02\x12\x03P=A\n\
    \x0b\n\x04\x05\0\x02K\x12\x03Q\x08<\n\x0c\n\x05\x05\0\x02K\x01\x12\x03Q\
    \x084\n\x0c\n\x05\x05\0\x02K\x02\x12\x03Q7;\n\x0b\n\x04\x05\0\x02L\x12\
    \x03R\x08=\n\x0c\n\x05\x05\0\x02L\x01\x12\x03R\x085\n\x0c\n\x05\x05\0\
    \x02L\x02\x12\x03R8<\n\x0b\n\x04\x05\0\x02M\x12\x03S\x08/\n\x0c\n\x05\
    \x05\0\x02M\x01\x12\x03S\x08'\n\x0c\n\x05\x05\0\x02M\x02\x12\x03S*.\n\
    \x0b\n\x04\x05\0\x02N\x12\x03T\x089\n\x0c\n\x05\x05\0\x02N\x01\x12\x03T\
    \x081\n\x0c\n\x05\x05\0\x02N\x02\x12\x03T48\n\x0b\n\x04\x05\0\x02O\x12\
    \x03U\x08;\n\x0c\n\x05\x05\0\x02O\x01\x12\x03U\x083\n\x0c\n\x05\x05\0\
    \x02O\x02\x12\x03U6:\n\n\n\x02\x04\0\x12\x04X\0^\x01\n\n\n\x03\x04\0\x01\
    \x12\x03X\x08\x16\n\x0b\n\x04\x04\0\x02\0\x12\x03Y\x08*\n\x0c\n\x05\x04\
    \0\x02\0\x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03Y\x11\
    \x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03Y\x18%\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03Y()\n\x0b\n\x04\x04\0\x02\x01\x12\x03Z\x08\x20\n\x0c\n\x05\
    \x04\0\x02\x01\x04\x12\x03Z\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03Z\x11\x16\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03Z\x17\x1b\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03Z\x1e\x1f\n\x0b\n\x04\x04\0\x02\x02\x12\x03[\
    \x08\x1f\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\
    \0\x02\x02\x05\x12\x03[\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03[\
    \x18\x1a\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03[\x1d\x1e\n\x0b\n\x04\x04\
    \0\x02\x03\x12\x03\\\x08!\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\\\x08\
    \x10\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\\\x11\x17\n\x0c\n\x05\x04\0\
    \x02\x03\x01\x12\x03\\\x18\x1c\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\\\
    \x1f\x20\n\x0b\n\x04\x04\0\x02\x04\x12\x03]\x08&\n\x0c\n\x05\x04\0\x02\
    \x04\x04\x12\x03]\x08\x10\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03]\x11\x17\
    \n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03]\x18!\n\x0c\n\x05\x04\0\x02\x04\
    \x03\x12\x03]$%\n\n\n\x02\x04\x01\x12\x04`\0d\x01\n\n\n\x03\x04\x01\x01\
    \x12\x03`\x08\x1f\n\x0b\n\x04\x04\x01\x02\0\x12\x03a\x08&\n\x0c\n\x05\
    \x04\x01\x02\0\x04\x12\x03a\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\
    \x03a\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03a\x18!\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03a$%\n\x0b\n\x04\x04\x01\x02\x01\x12\x03b\x08,\
    \n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03b\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x01\x05\x12\x03b\x11\x17\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03b\
    \x18'\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03b*+\n\x0b\n\x04\x04\x01\x02\
    \x02\x12\x03c\x08.\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03c\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x02\x05\x12\x03c\x11\x17\n\x0c\n\x05\x04\x01\x02\
    \x02\x01\x12\x03c\x18)\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03c,-\n\n\n\
    \x02\x04\x02\x12\x04f\0n\x01\n\n\n\x03\x04\x02\x01\x12\x03f\x08\x18\n\
    \x0b\n\x04\x04\x02\x02\0\x12\x03g\x08'\n\x0c\n\x05\x04\x02\x02\0\x04\x12\
    \x03g\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03g\x11\x17\n\x0c\n\x05\
    \x04\x02\x02\0\x01\x12\x03g\x18\"\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03g\
    %&\n\x0b\n\x04\x04\x02\x02\x01\x12\x03h\x08(\n\x0c\n\x05\x04\x02\x02\x01\
    \x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03h\x11\x17\n\
    \x0c\n\x05\x04\x02\x02\x01\x01\x12\x03h\x18#\n\x0c\n\x05\x04\x02\x02\x01\
    \x03\x12\x03h&'\n\x0b\n\x04\x04\x02\x02\x02\x12\x03i\x08(\n\x0c\n\x05\
    \x04\x02\x02\x02\x04\x12\x03i\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\
    \x12\x03i\x11\x17\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03i\x18#\n\x0c\n\
    \x05\x04\x02\x02\x02\x03\x12\x03i&'\n\x0b\n\x04\x04\x02\x02\x03\x12\x03j\
    \x08'\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\
    \x02\x02\x03\x05\x12\x03j\x11\x17\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\
    \x03j\x18\"\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03j%&\n\x0b\n\x04\x04\
    \x02\x02\x04\x12\x03k\x08(\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03k\x08\
    \x10\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03k\x11\x17\n\x0c\n\x05\x04\
    \x02\x02\x04\x01\x12\x03k\x18#\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03k&\
    '\n\x0b\n\x04\x04\x02\x02\x05\x12\x03l\x08,\n\x0c\n\x05\x04\x02\x02\x05\
    \x04\x12\x03l\x08\x10\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03l\x11\x17\n\
    \x0c\n\x05\x04\x02\x02\x05\x01\x12\x03l\x18'\n\x0c\n\x05\x04\x02\x02\x05\
    \x03\x12\x03l*+\n\x0b\n\x04\x04\x02\x02\x06\x12\x03m\x08(\n\x0c\n\x05\
    \x04\x02\x02\x06\x04\x12\x03m\x08\x10\n\x0c\n\x05\x04\x02\x02\x06\x05\
    \x12\x03m\x11\x17\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03m\x18#\n\x0c\n\
    \x05\x04\x02\x02\x06\x03\x12\x03m&'\n\n\n\x02\x04\x03\x12\x04p\0v\x01\n\
    \n\n\x03\x04\x03\x01\x12\x03p\x08\x16\n\x0b\n\x04\x04\x03\x02\0\x12\x03q\
    \x08#\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03q\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\0\x05\x12\x03q\x11\x16\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03q\x17\
    \x1e\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03q!\"\n\x0b\n\x04\x04\x03\x02\
    \x01\x12\x03r\x08%\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03r\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\x01\x05\x12\x03r\x11\x17\n\x0c\n\x05\x04\x03\x02\
    \x01\x01\x12\x03r\x18\x20\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03r#$\n\
    \x0b\n\x04\x04\x03\x02\x02\x12\x03s\x08&\n\x0c\n\x05\x04\x03\x02\x02\x04\
    \x12\x03s\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03s\x11\x17\n\x0c\
    \n\x05\x04\x03\x02\x02\x01\x12\x03s\x18!\n\x0c\n\x05\x04\x03\x02\x02\x03\
    \x12\x03s$%\n\x0b\n\x04\x04\x03\x02\x03\x12\x03t\x08&\n\x0c\n\x05\x04\
    \x03\x02\x03\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\
    \x03t\x11\x17\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03t\x18!\n\x0c\n\x05\
    \x04\x03\x02\x03\x03\x12\x03t$%\n\x0b\n\x04\x04\x03\x02\x04\x12\x03u\x08\
    /\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x03u\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\x04\x06\x12\x03u\x11\"\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03u#*\n\
    \x0c\n\x05\x04\x03\x02\x04\x03\x12\x03u-.\n\x0b\n\x02\x04\x04\x12\x05x\0\
    \x82\x01\x01\n\n\n\x03\x04\x04\x01\x12\x03x\x08\x17\n\x0b\n\x04\x04\x04\
    \x02\0\x12\x03y\x08$\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03y\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\0\x05\x12\x03y\x11\x16\n\x0c\n\x05\x04\x04\x02\0\
    \x01\x12\x03y\x17\x1f\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03y\"#\n\x0b\n\
    \x04\x04\x04\x02\x01\x12\x03z\x08&\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\
    \x03z\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03z\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\x01\x01\x12\x03z\x18!\n\x0c\n\x05\x04\x04\x02\x01\x03\
    \x12\x03z$%\n\x0b\n\x04\x04\x04\x02\x02\x12\x03{\x08'\n\x0c\n\x05\x04\
    \x04\x02\x02\x04\x12\x03{\x08\x10\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\
    \x03{\x11\x17\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03{\x18\"\n\x0c\n\x05\
    \x04\x04\x02\x02\x03\x12\x03{%&\n\x0b\n\x04\x04\x04\x02\x03\x12\x03|\x08\
    -\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03|\x08\x10\n\x0c\n\x05\x04\x04\
    \x02\x03\x05\x12\x03|\x11\x17\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03|\
    \x18(\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03|+,\n\x0b\n\x04\x04\x04\x02\
    \x04\x12\x03}\x08+\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03}\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\x04\x05\x12\x03}\x11\x17\n\x0c\n\x05\x04\x04\x02\
    \x04\x01\x12\x03}\x18&\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03})*\n\x0b\
    \n\x04\x04\x04\x02\x05\x12\x03~\x08(\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\
    \x03~\x08\x10\n\x0c\n\x05\x04\x04\x02\x05\x05\x12\x03~\x11\x16\n\x0c\n\
    \x05\x04\x04\x02\x05\x01\x12\x03~\x17#\n\x0c\n\x05\x04\x04\x02\x05\x03\
    \x12\x03~&'\n\x0b\n\x04\x04\x04\x02\x06\x12\x03\x7f\x08*\n\x0c\n\x05\x04\
    \x04\x02\x06\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\x04\x04\x02\x06\x05\x12\
    \x03\x7f\x11\x16\n\x0c\n\x05\x04\x04\x02\x06\x01\x12\x03\x7f\x17%\n\x0c\
    \n\x05\x04\x04\x02\x06\x03\x12\x03\x7f()\n\x0c\n\x04\x04\x04\x02\x07\x12\
    \x04\x80\x01\x08-\n\r\n\x05\x04\x04\x02\x07\x04\x12\x04\x80\x01\x08\x10\
    \n\r\n\x05\x04\x04\x02\x07\x05\x12\x04\x80\x01\x11\x17\n\r\n\x05\x04\x04\
    \x02\x07\x01\x12\x04\x80\x01\x18(\n\r\n\x05\x04\x04\x02\x07\x03\x12\x04\
    \x80\x01+,\n\x0c\n\x04\x04\x04\x02\x08\x12\x04\x81\x01\x08.\n\r\n\x05\
    \x04\x04\x02\x08\x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\x04\x04\x02\x08\
    \x05\x12\x04\x81\x01\x11\x17\n\r\n\x05\x04\x04\x02\x08\x01\x12\x04\x81\
    \x01\x18)\n\r\n\x05\x04\x04\x02\x08\x03\x12\x04\x81\x01,-\n\x0c\n\x02\
    \x04\x05\x12\x06\x84\x01\0\x92\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\
    \x84\x01\x08\x18\n\x0c\n\x04\x04\x05\x02\0\x12\x04\x85\x01\x08+\n\r\n\
    \x05\x04\x05\x02\0\x04\x12\x04\x85\x01\x08\x10\n\r\n\x05\x04\x05\x02\0\
    \x05\x12\x04\x85\x01\x11\x17\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x85\x01\
    \x18&\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x85\x01)*\n\x0c\n\x04\x04\x05\
    \x02\x01\x12\x04\x86\x01\x08+\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\x86\
    \x01\x08\x10\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\x86\x01\x11\x17\n\r\n\
    \x05\x04\x05\x02\x01\x01\x12\x04\x86\x01\x18&\n\r\n\x05\x04\x05\x02\x01\
    \x03\x12\x04\x86\x01)*\n\x0c\n\x04\x04\x05\x02\x02\x12\x04\x87\x01\x08.\
    \n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\x87\x01\x08\x10\n\r\n\x05\x04\x05\
    \x02\x02\x05\x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\x05\x02\x02\x01\x12\
    \x04\x87\x01\x18)\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\x87\x01,-\n\x0c\
    \n\x04\x04\x05\x02\x03\x12\x04\x88\x01\x08.\n\r\n\x05\x04\x05\x02\x03\
    \x04\x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\x05\x02\x03\x05\x12\x04\x88\
    \x01\x11\x17\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\x88\x01\x18)\n\r\n\
    \x05\x04\x05\x02\x03\x03\x12\x04\x88\x01,-\n\x0c\n\x04\x04\x05\x02\x04\
    \x12\x04\x89\x01\x08,\n\r\n\x05\x04\x05\x02\x04\x04\x12\x04\x89\x01\x08\
    \x10\n\r\n\x05\x04\x05\x02\x04\x05\x12\x04\x89\x01\x11\x17\n\r\n\x05\x04\
    \x05\x02\x04\x01\x12\x04\x89\x01\x18'\n\r\n\x05\x04\x05\x02\x04\x03\x12\
    \x04\x89\x01*+\n\x0c\n\x04\x04\x05\x02\x05\x12\x04\x8a\x01\x08,\n\r\n\
    \x05\x04\x05\x02\x05\x04\x12\x04\x8a\x01\x08\x10\n\r\n\x05\x04\x05\x02\
    \x05\x05\x12\x04\x8a\x01\x11\x17\n\r\n\x05\x04\x05\x02\x05\x01\x12\x04\
    \x8a\x01\x18'\n\r\n\x05\x04\x05\x02\x05\x03\x12\x04\x8a\x01*+\n\x0c\n\
    \x04\x04\x05\x02\x06\x12\x04\x8b\x01\x08@\n\r\n\x05\x04\x05\x02\x06\x04\
    \x12\x04\x8b\x01\x08\x10\n\r\n\x05\x04\x05\x02\x06\x06\x12\x04\x8b\x01\
    \x11)\n\r\n\x05\x04\x05\x02\x06\x01\x12\x04\x8b\x01*;\n\r\n\x05\x04\x05\
    \x02\x06\x03\x12\x04\x8b\x01>?\n\x0c\n\x04\x04\x05\x02\x07\x12\x04\x8c\
    \x01\x08*\n\r\n\x05\x04\x05\x02\x07\x04\x12\x04\x8c\x01\x08\x10\n\r\n\
    \x05\x04\x05\x02\x07\x05\x12\x04\x8c\x01\x11\x17\n\r\n\x05\x04\x05\x02\
    \x07\x01\x12\x04\x8c\x01\x18%\n\r\n\x05\x04\x05\x02\x07\x03\x12\x04\x8c\
    \x01()\n\x0c\n\x04\x04\x05\x02\x08\x12\x04\x8d\x01\x083\n\r\n\x05\x04\
    \x05\x02\x08\x04\x12\x04\x8d\x01\x08\x10\n\r\n\x05\x04\x05\x02\x08\x05\
    \x12\x04\x8d\x01\x11\x17\n\r\n\x05\x04\x05\x02\x08\x01\x12\x04\x8d\x01\
    \x18.\n\r\n\x05\x04\x05\x02\x08\x03\x12\x04\x8d\x0112\n\x0c\n\x04\x04\
    \x05\x02\t\x12\x04\x8e\x01\x080\n\r\n\x05\x04\x05\x02\t\x04\x12\x04\x8e\
    \x01\x08\x10\n\r\n\x05\x04\x05\x02\t\x05\x12\x04\x8e\x01\x11\x17\n\r\n\
    \x05\x04\x05\x02\t\x01\x12\x04\x8e\x01\x18*\n\r\n\x05\x04\x05\x02\t\x03\
    \x12\x04\x8e\x01-/\n\x0c\n\x04\x04\x05\x02\n\x12\x04\x8f\x01\x084\n\r\n\
    \x05\x04\x05\x02\n\x04\x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\x05\x02\n\
    \x05\x12\x04\x8f\x01\x11\x17\n\r\n\x05\x04\x05\x02\n\x01\x12\x04\x8f\x01\
    \x18.\n\r\n\x05\x04\x05\x02\n\x03\x12\x04\x8f\x0113\n\x0c\n\x04\x04\x05\
    \x02\x0b\x12\x04\x90\x01\x087\n\r\n\x05\x04\x05\x02\x0b\x04\x12\x04\x90\
    \x01\x08\x10\n\r\n\x05\x04\x05\x02\x0b\x05\x12\x04\x90\x01\x11\x17\n\r\n\
    \x05\x04\x05\x02\x0b\x01\x12\x04\x90\x01\x181\n\r\n\x05\x04\x05\x02\x0b\
    \x03\x12\x04\x90\x0146\n\x0c\n\x04\x04\x05\x02\x0c\x12\x04\x91\x01\x08.\
    \n\r\n\x05\x04\x05\x02\x0c\x04\x12\x04\x91\x01\x08\x10\n\r\n\x05\x04\x05\
    \x02\x0c\x05\x12\x04\x91\x01\x11\x17\n\r\n\x05\x04\x05\x02\x0c\x01\x12\
    \x04\x91\x01\x18(\n\r\n\x05\x04\x05\x02\x0c\x03\x12\x04\x91\x01+-\n\x0c\
    \n\x02\x04\x06\x12\x06\x94\x01\0\x97\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\
    \x04\x94\x01\x08'\n\x0c\n\x04\x04\x06\x02\0\x12\x04\x95\x01\x08!\n\r\n\
    \x05\x04\x06\x02\0\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\
    \x05\x12\x04\x95\x01\x11\x17\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x95\x01\
    \x18\x1c\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x95\x01\x1f\x20\n\x0c\n\x04\
    \x04\x06\x02\x01\x12\x04\x96\x01\x08\"\n\r\n\x05\x04\x06\x02\x01\x04\x12\
    \x04\x96\x01\x08\x10\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\x96\x01\x11\
    \x17\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\x96\x01\x18\x1d\n\r\n\x05\x04\
    \x06\x02\x01\x03\x12\x04\x96\x01\x20!\n\x0c\n\x02\x04\x07\x12\x06\x99\
    \x01\0\x9c\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\x99\x01\x08#\n\x0c\n\
    \x04\x04\x07\x02\0\x12\x04\x9a\x01\x08\"\n\r\n\x05\x04\x07\x02\0\x04\x12\
    \x04\x9a\x01\x08\x10\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\x9a\x01\x11\x17\
    \n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x9a\x01\x18\x1d\n\r\n\x05\x04\x07\
    \x02\0\x03\x12\x04\x9a\x01\x20!\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\x9b\
    \x01\x08\"\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\x9b\x01\x08\x10\n\r\n\
    \x05\x04\x07\x02\x01\x05\x12\x04\x9b\x01\x11\x16\n\r\n\x05\x04\x07\x02\
    \x01\x01\x12\x04\x9b\x01\x17\x1d\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\
    \x9b\x01\x20!\n\x0c\n\x02\x04\x08\x12\x06\x9e\x01\0\xa2\x01\x01\n\x0b\n\
    \x03\x04\x08\x01\x12\x04\x9e\x01\x08#\n\x0c\n\x04\x04\x08\x02\0\x12\x04\
    \x9f\x01\x08$\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x9f\x01\x08\x10\n\r\n\
    \x05\x04\x08\x02\0\x05\x12\x04\x9f\x01\x11\x16\n\r\n\x05\x04\x08\x02\0\
    \x01\x12\x04\x9f\x01\x17\x1f\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x9f\x01\
    \"#\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xa0\x01\x08'\n\r\n\x05\x04\x08\
    \x02\x01\x04\x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\x08\x02\x01\x05\x12\
    \x04\xa0\x01\x11\x16\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xa0\x01\x17\"\
    \n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xa0\x01%&\n\x0c\n\x04\x04\x08\x02\
    \x02\x12\x04\xa1\x01\x089\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xa1\x01\
    \x08\x10\n\r\n\x05\x04\x08\x02\x02\x06\x12\x04\xa1\x01\x11-\n\r\n\x05\
    \x04\x08\x02\x02\x01\x12\x04\xa1\x01.4\n\r\n\x05\x04\x08\x02\x02\x03\x12\
    \x04\xa1\x0178\n\x0c\n\x02\x04\t\x12\x06\xa4\x01\0\xa9\x01\x01\n\x0b\n\
    \x03\x04\t\x01\x12\x04\xa4\x01\x08\x19\n\x0c\n\x04\x04\t\x02\0\x12\x04\
    \xa5\x01\x08'\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xa5\x01\x08\x10\n\r\n\
    \x05\x04\t\x02\0\x05\x12\x04\xa5\x01\x11\x17\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\xa5\x01\x18\"\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xa5\x01%&\n\x0c\
    \n\x04\x04\t\x02\x01\x12\x04\xa6\x01\x08$\n\r\n\x05\x04\t\x02\x01\x04\
    \x12\x04\xa6\x01\x08\x10\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xa6\x01\x11\
    \x17\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xa6\x01\x18\x1f\n\r\n\x05\x04\t\
    \x02\x01\x03\x12\x04\xa6\x01\"#\n\x0c\n\x04\x04\t\x02\x02\x12\x04\xa7\
    \x01\x08!\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\
    \x04\t\x02\x02\x05\x12\x04\xa7\x01\x11\x17\n\r\n\x05\x04\t\x02\x02\x01\
    \x12\x04\xa7\x01\x18\x1c\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xa7\x01\x1f\
    \x20\n\x0c\n\x04\x04\t\x02\x03\x12\x04\xa8\x01\x08'\n\r\n\x05\x04\t\x02\
    \x03\x04\x12\x04\xa8\x01\x08\x10\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\xa8\
    \x01\x11\x16\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xa8\x01\x17\"\n\r\n\x05\
    \x04\t\x02\x03\x03\x12\x04\xa8\x01%&\n\x0c\n\x02\x04\n\x12\x06\xab\x01\0\
    \xaf\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xab\x01\x08\x1e\n\x0c\n\x04\
    \x04\n\x02\0\x12\x04\xac\x01\x08)\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xac\
    \x01\x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xac\x01\x11\x17\n\r\n\x05\
    \x04\n\x02\0\x01\x12\x04\xac\x01\x18$\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \xac\x01'(\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xad\x01\x08)\n\r\n\x05\x04\
    \n\x02\x01\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\n\x02\x01\x05\x12\
    \x04\xad\x01\x11\x17\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xad\x01\x18$\n\
    \r\n\x05\x04\n\x02\x01\x03\x12\x04\xad\x01'(\n\x0c\n\x04\x04\n\x02\x02\
    \x12\x04\xae\x01\x08'\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\xae\x01\x08\
    \x10\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\xae\x01\x11\x17\n\r\n\x05\x04\n\
    \x02\x02\x01\x12\x04\xae\x01\x18\"\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\
    \xae\x01%&\n\x0c\n\x02\x04\x0b\x12\x06\xb1\x01\0\xb9\x01\x01\n\x0b\n\x03\
    \x04\x0b\x01\x12\x04\xb1\x01\x08\x18\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\
    \xb2\x01\x08'\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xb2\x01\x08\x10\n\r\n\
    \x05\x04\x0b\x02\0\x05\x12\x04\xb2\x01\x11\x17\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\xb2\x01\x18\"\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xb2\x01%&\
    \n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\xb3\x01\x08)\n\r\n\x05\x04\x0b\x02\
    \x01\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\
    \xb3\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xb3\x01\x18$\n\r\
    \n\x05\x04\x0b\x02\x01\x03\x12\x04\xb3\x01'(\n\x0c\n\x04\x04\x0b\x02\x02\
    \x12\x04\xb4\x01\x08)\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xb4\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\xb4\x01\x11\x17\n\r\n\x05\x04\
    \x0b\x02\x02\x01\x12\x04\xb4\x01\x18$\n\r\n\x05\x04\x0b\x02\x02\x03\x12\
    \x04\xb4\x01'(\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\xb5\x01\x08)\n\r\n\
    \x05\x04\x0b\x02\x03\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x0b\x02\
    \x03\x05\x12\x04\xb5\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\
    \xb5\x01\x18$\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xb5\x01'(\n\x0c\n\
    \x04\x04\x0b\x02\x04\x12\x04\xb6\x01\x08'\n\r\n\x05\x04\x0b\x02\x04\x04\
    \x12\x04\xb6\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\xb6\x01\
    \x11\x17\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\xb6\x01\x18\"\n\r\n\x05\
    \x04\x0b\x02\x04\x03\x12\x04\xb6\x01%&\n\x0c\n\x04\x04\x0b\x02\x05\x12\
    \x04\xb7\x01\x081\n\r\n\x05\x04\x0b\x02\x05\x04\x12\x04\xb7\x01\x08\x10\
    \n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\xb7\x01\x11\x17\n\r\n\x05\x04\x0b\
    \x02\x05\x01\x12\x04\xb7\x01\x18,\n\r\n\x05\x04\x0b\x02\x05\x03\x12\x04\
    \xb7\x01/0\n\x0c\n\x04\x04\x0b\x02\x06\x12\x04\xb8\x01\x089\n\r\n\x05\
    \x04\x0b\x02\x06\x04\x12\x04\xb8\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x06\
    \x05\x12\x04\xb8\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x06\x01\x12\x04\xb8\
    \x01\x184\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\xb8\x0178\n\x0c\n\x02\
    \x04\x0c\x12\x06\xbb\x01\0\xbf\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\
    \xbb\x01\x08\x17\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xbc\x01\x08%\n\r\n\
    \x05\x04\x0c\x02\0\x04\x12\x04\xbc\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\
    \x05\x12\x04\xbc\x01\x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xbc\x01\
    \x18\x20\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xbc\x01#$\n\x0c\n\x04\x04\
    \x0c\x02\x01\x12\x04\xbd\x01\x08!\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\
    \xbd\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xbd\x01\x11\x17\n\
    \r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xbd\x01\x18\x1c\n\r\n\x05\x04\x0c\
    \x02\x01\x03\x12\x04\xbd\x01\x1f\x20\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\
    \xbe\x01\x08\x20\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xbe\x01\x08\x10\n\
    \r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xbe\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x02\x02\x01\x12\x04\xbe\x01\x18\x1b\n\r\n\x05\x04\x0c\x02\x02\x03\x12\
    \x04\xbe\x01\x1e\x1f\n\x0c\n\x02\x04\r\x12\x06\xc1\x01\0\xc6\x01\x01\n\
    \x0b\n\x03\x04\r\x01\x12\x04\xc1\x01\x08\x1c\n\x0c\n\x04\x04\r\x02\0\x12\
    \x04\xc2\x01\x08$\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xc2\x01\x08\x10\n\r\
    \n\x05\x04\r\x02\0\x05\x12\x04\xc2\x01\x11\x16\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xc2\x01\x17\x1f\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xc2\x01\"#\n\
    \x0c\n\x04\x04\r\x02\x01\x12\x04\xc3\x01\x08&\n\r\n\x05\x04\r\x02\x01\
    \x04\x12\x04\xc3\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xc3\x01\
    \x11\x16\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xc3\x01\x17!\n\r\n\x05\x04\
    \r\x02\x01\x03\x12\x04\xc3\x01$%\n\x0c\n\x04\x04\r\x02\x02\x12\x04\xc4\
    \x01\x08%\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\
    \x04\r\x02\x02\x05\x12\x04\xc4\x01\x11\x16\n\r\n\x05\x04\r\x02\x02\x01\
    \x12\x04\xc4\x01\x17\x20\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xc4\x01#$\n\
    \x0c\n\x04\x04\r\x02\x03\x12\x04\xc5\x01\x08*\n\r\n\x05\x04\r\x02\x03\
    \x04\x12\x04\xc5\x01\x08\x10\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\xc5\x01\
    \x11\x16\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xc5\x01\x17%\n\r\n\x05\x04\
    \r\x02\x03\x03\x12\x04\xc5\x01()\n\x0c\n\x02\x04\x0e\x12\x06\xc8\x01\0\
    \xdc\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xc8\x01\x08\x16\n\x0c\n\x04\
    \x04\x0e\x02\0\x12\x04\xc9\x01\x08(\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\
    \xc9\x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xc9\x01\x11\x17\n\r\
    \n\x05\x04\x0e\x02\0\x01\x12\x04\xc9\x01\x18#\n\r\n\x05\x04\x0e\x02\0\
    \x03\x12\x04\xc9\x01&'\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xca\x01\x08)\
    \n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\x0e\
    \x02\x01\x05\x12\x04\xca\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x01\x01\x12\
    \x04\xca\x01\x18$\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xca\x01'(\n\x0c\
    \n\x04\x04\x0e\x02\x02\x12\x04\xcb\x01\x08%\n\r\n\x05\x04\x0e\x02\x02\
    \x04\x12\x04\xcb\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xcb\
    \x01\x11\x17\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xcb\x01\x18\x20\n\r\n\
    \x05\x04\x0e\x02\x02\x03\x12\x04\xcb\x01#$\n\x0c\n\x04\x04\x0e\x02\x03\
    \x12\x04\xcc\x01\x08'\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xcc\x01\x08\
    \x10\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xcc\x01\x11\x17\n\r\n\x05\x04\
    \x0e\x02\x03\x01\x12\x04\xcc\x01\x18\"\n\r\n\x05\x04\x0e\x02\x03\x03\x12\
    \x04\xcc\x01%&\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\xcd\x01\x08'\n\r\n\
    \x05\x04\x0e\x02\x04\x04\x12\x04\xcd\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x04\x05\x12\x04\xcd\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\
    \xcd\x01\x18\"\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xcd\x01%&\n\x0c\n\
    \x04\x04\x0e\x02\x05\x12\x04\xce\x01\x08$\n\r\n\x05\x04\x0e\x02\x05\x04\
    \x12\x04\xce\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xce\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\xce\x01\x18\x1f\n\r\n\x05\
    \x04\x0e\x02\x05\x03\x12\x04\xce\x01\"#\n\x0c\n\x04\x04\x0e\x02\x06\x12\
    \x04\xcf\x01\x08&\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\xcf\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x06\x05\x12\x04\xcf\x01\x11\x17\n\r\n\x05\x04\x0e\
    \x02\x06\x01\x12\x04\xcf\x01\x18!\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\
    \xcf\x01$%\n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\xd0\x01\x08*\n\r\n\x05\
    \x04\x0e\x02\x07\x04\x12\x04\xd0\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x07\
    \x05\x12\x04\xd0\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xd0\
    \x01\x18%\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\xd0\x01()\n\x0c\n\x04\
    \x04\x0e\x02\x08\x12\x04\xd1\x01\x08&\n\r\n\x05\x04\x0e\x02\x08\x04\x12\
    \x04\xd1\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\xd1\x01\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\xd1\x01\x18\x20\n\r\n\x05\x04\
    \x0e\x02\x08\x03\x12\x04\xd1\x01#%\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\xd2\
    \x01\x08/\n\r\n\x05\x04\x0e\x02\t\x04\x12\x04\xd2\x01\x08\x10\n\r\n\x05\
    \x04\x0e\x02\t\x05\x12\x04\xd2\x01\x11\x17\n\r\n\x05\x04\x0e\x02\t\x01\
    \x12\x04\xd2\x01\x18)\n\r\n\x05\x04\x0e\x02\t\x03\x12\x04\xd2\x01,.\n\
    \x0c\n\x04\x04\x0e\x02\n\x12\x04\xd3\x01\x08,\n\r\n\x05\x04\x0e\x02\n\
    \x04\x12\x04\xd3\x01\x08\x10\n\r\n\x05\x04\x0e\x02\n\x05\x12\x04\xd3\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02\n\x01\x12\x04\xd3\x01\x18&\n\r\n\x05\x04\
    \x0e\x02\n\x03\x12\x04\xd3\x01)+\n\x0c\n\x04\x04\x0e\x02\x0b\x12\x04\xd4\
    \x01\x08.\n\r\n\x05\x04\x0e\x02\x0b\x04\x12\x04\xd4\x01\x08\x10\n\r\n\
    \x05\x04\x0e\x02\x0b\x05\x12\x04\xd4\x01\x11\x17\n\r\n\x05\x04\x0e\x02\
    \x0b\x01\x12\x04\xd4\x01\x18(\n\r\n\x05\x04\x0e\x02\x0b\x03\x12\x04\xd4\
    \x01+-\n\x0c\n\x04\x04\x0e\x02\x0c\x12\x04\xd5\x01\x08.\n\r\n\x05\x04\
    \x0e\x02\x0c\x04\x12\x04\xd5\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x0c\x05\
    \x12\x04\xd5\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x0c\x01\x12\x04\xd5\x01\
    \x18(\n\r\n\x05\x04\x0e\x02\x0c\x03\x12\x04\xd5\x01+-\n\x0c\n\x04\x04\
    \x0e\x02\r\x12\x04\xd6\x01\x08,\n\r\n\x05\x04\x0e\x02\r\x04\x12\x04\xd6\
    \x01\x08\x10\n\r\n\x05\x04\x0e\x02\r\x05\x12\x04\xd6\x01\x11\x17\n\r\n\
    \x05\x04\x0e\x02\r\x01\x12\x04\xd6\x01\x18&\n\r\n\x05\x04\x0e\x02\r\x03\
    \x12\x04\xd6\x01)+\n\x0c\n\x04\x04\x0e\x02\x0e\x12\x04\xd7\x01\x08.\n\r\
    \n\x05\x04\x0e\x02\x0e\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x0e\x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x0e\x01\x12\x04\
    \xd7\x01\x18(\n\r\n\x05\x04\x0e\x02\x0e\x03\x12\x04\xd7\x01+-\n\x0c\n\
    \x04\x04\x0e\x02\x0f\x12\x04\xd8\x01\x08.\n\r\n\x05\x04\x0e\x02\x0f\x04\
    \x12\x04\xd8\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x0f\x05\x12\x04\xd8\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x0f\x01\x12\x04\xd8\x01\x18(\n\r\n\x05\
    \x04\x0e\x02\x0f\x03\x12\x04\xd8\x01+-\n\x0c\n\x04\x04\x0e\x02\x10\x12\
    \x04\xd9\x01\x08.\n\r\n\x05\x04\x0e\x02\x10\x04\x12\x04\xd9\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x10\x05\x12\x04\xd9\x01\x11\x17\n\r\n\x05\x04\x0e\
    \x02\x10\x01\x12\x04\xd9\x01\x18(\n\r\n\x05\x04\x0e\x02\x10\x03\x12\x04\
    \xd9\x01+-\n\x0c\n\x04\x04\x0e\x02\x11\x12\x04\xda\x01\x08+\n\r\n\x05\
    \x04\x0e\x02\x11\x04\x12\x04\xda\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x11\
    \x05\x12\x04\xda\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x11\x01\x12\x04\xda\
    \x01\x18%\n\r\n\x05\x04\x0e\x02\x11\x03\x12\x04\xda\x01(*\n\x0c\n\x04\
    \x04\x0e\x02\x12\x12\x04\xdb\x01\x08.\n\r\n\x05\x04\x0e\x02\x12\x04\x12\
    \x04\xdb\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x12\x05\x12\x04\xdb\x01\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x12\x01\x12\x04\xdb\x01\x18(\n\r\n\x05\x04\
    \x0e\x02\x12\x03\x12\x04\xdb\x01+-\n\x0c\n\x02\x04\x0f\x12\x06\xde\x01\0\
    \xe5\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xde\x01\x08\x15\n\x0c\n\x04\
    \x04\x0f\x02\0\x12\x04\xdf\x01\x08\x1e\n\r\n\x05\x04\x0f\x02\0\x04\x12\
    \x04\xdf\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xdf\x01\x11\x17\
    \n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xdf\x01\x18\x19\n\r\n\x05\x04\x0f\
    \x02\0\x03\x12\x04\xdf\x01\x1c\x1d\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\
    \xe0\x01\x08\x1e\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xe0\x01\x08\x10\n\
    \r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xe0\x01\x11\x17\n\r\n\x05\x04\x0f\
    \x02\x01\x01\x12\x04\xe0\x01\x18\x19\n\r\n\x05\x04\x0f\x02\x01\x03\x12\
    \x04\xe0\x01\x1c\x1d\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xe1\x01\x08\x1e\
    \n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x0f\
    \x02\x02\x05\x12\x04\xe1\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x02\x01\x12\
    \x04\xe1\x01\x18\x19\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xe1\x01\x1c\
    \x1d\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\xe2\x01\x08\x1e\n\r\n\x05\x04\
    \x0f\x02\x03\x04\x12\x04\xe2\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x03\x05\
    \x12\x04\xe2\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xe2\x01\
    \x18\x19\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xe2\x01\x1c\x1d\n\x0c\n\
    \x04\x04\x0f\x02\x04\x12\x04\xe3\x01\x08!\n\r\n\x05\x04\x0f\x02\x04\x04\
    \x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\xe3\x01\
    \x11\x17\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\xe3\x01\x18\x1c\n\r\n\x05\
    \x04\x0f\x02\x04\x03\x12\x04\xe3\x01\x1f\x20\n\x0c\n\x04\x04\x0f\x02\x05\
    \x12\x04\xe4\x01\x08\"\n\r\n\x05\x04\x0f\x02\x05\x04\x12\x04\xe4\x01\x08\
    \x10\n\r\n\x05\x04\x0f\x02\x05\x05\x12\x04\xe4\x01\x11\x17\n\r\n\x05\x04\
    \x0f\x02\x05\x01\x12\x04\xe4\x01\x18\x1d\n\r\n\x05\x04\x0f\x02\x05\x03\
    \x12\x04\xe4\x01\x20!\n\x0c\n\x02\x04\x10\x12\x06\xe7\x01\0\xea\x01\x01\
    \n\x0b\n\x03\x04\x10\x01\x12\x04\xe7\x01\x08\x16\n\x0c\n\x04\x04\x10\x02\
    \0\x12\x04\xe8\x01\x08&\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xe8\x01\x08\
    \x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xe8\x01\x11\x17\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\xe8\x01\x18!\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \xe8\x01$%\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xe9\x01\x08'\n\r\n\x05\
    \x04\x10\x02\x01\x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\x04\x10\x02\x01\
    \x05\x12\x04\xe9\x01\x11\x16\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xe9\
    \x01\x17\"\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xe9\x01%&\n\x0c\n\x02\
    \x04\x11\x12\x06\xec\x01\0\xf0\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xec\x01\x08\x1b\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xed\x01\x08$\n\r\n\
    \x05\x04\x11\x02\0\x04\x12\x04\xed\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\xed\x01\x11\x17\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xed\x01\
    \x18\x1f\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xed\x01\"#\n\x0c\n\x04\x04\
    \x11\x02\x01\x12\x04\xee\x01\x08-\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\
    \xee\x01\x08\x10\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xee\x01\x11\x17\n\
    \r\n\x05\x04\x11\x02\x01\x01\x12\x04\xee\x01\x18(\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\xee\x01+,\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xef\x01\
    \x082\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xef\x01\x08\x10\n\r\n\x05\
    \x04\x11\x02\x02\x05\x12\x04\xef\x01\x11\x17\n\r\n\x05\x04\x11\x02\x02\
    \x01\x12\x04\xef\x01\x18-\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xef\x010\
    1\n\x0c\n\x02\x04\x12\x12\x06\xf2\x01\0\x81\x02\x01\n\x0b\n\x03\x04\x12\
    \x01\x12\x04\xf2\x01\x08\x1c\n\x0e\n\x04\x04\x12\x03\0\x12\x06\xf3\x01\
    \x08\xf6\x01\t\n\r\n\x05\x04\x12\x03\0\x01\x12\x04\xf3\x01\x10\x15\n\x0e\
    \n\x06\x04\x12\x03\0\x02\0\x12\x04\xf4\x01\x10(\n\x0f\n\x07\x04\x12\x03\
    \0\x02\0\x04\x12\x04\xf4\x01\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\0\x05\
    \x12\x04\xf4\x01\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\0\x01\x12\x04\xf4\
    \x01\x20#\n\x0f\n\x07\x04\x12\x03\0\x02\0\x03\x12\x04\xf4\x01&'\n\x0e\n\
    \x06\x04\x12\x03\0\x02\x01\x12\x04\xf5\x01\x10(\n\x0f\n\x07\x04\x12\x03\
    \0\x02\x01\x04\x12\x04\xf5\x01\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\x01\
    \x05\x12\x04\xf5\x01\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x01\x12\
    \x04\xf5\x01\x20#\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x03\x12\x04\xf5\x01&\
    '\n\x0e\n\x04\x04\x12\x03\x01\x12\x06\xf8\x01\x08\xfb\x01\t\n\r\n\x05\
    \x04\x12\x03\x01\x01\x12\x04\xf8\x01\x10\x1e\n\x0e\n\x06\x04\x12\x03\x01\
    \x02\0\x12\x04\xf9\x01\x10.\n\x0f\n\x07\x04\x12\x03\x01\x02\0\x04\x12\
    \x04\xf9\x01\x10\x18\n\x0f\n\x07\x04\x12\x03\x01\x02\0\x05\x12\x04\xf9\
    \x01\x19\x1f\n\x0f\n\x07\x04\x12\x03\x01\x02\0\x01\x12\x04\xf9\x01\x20)\
    \n\x0f\n\x07\x04\x12\x03\x01\x02\0\x03\x12\x04\xf9\x01,-\n\x0e\n\x06\x04\
    \x12\x03\x01\x02\x01\x12\x04\xfa\x01\x10A\n\x0f\n\x07\x04\x12\x03\x01\
    \x02\x01\x04\x12\x04\xfa\x01\x10\x18\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\
    \x06\x12\x04\xfa\x01\x194\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\x01\x12\
    \x04\xfa\x015<\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\x03\x12\x04\xfa\x01?@\
    \n\x0c\n\x04\x04\x12\x02\0\x12\x04\xfd\x01\x08%\n\r\n\x05\x04\x12\x02\0\
    \x04\x12\x04\xfd\x01\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xfd\x01\
    \x11\x17\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xfd\x01\x18\x20\n\r\n\x05\
    \x04\x12\x02\0\x03\x12\x04\xfd\x01#$\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\
    \xfe\x01\x08\"\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xfe\x01\x08\x10\n\r\
    \n\x05\x04\x12\x02\x01\x05\x12\x04\xfe\x01\x11\x17\n\r\n\x05\x04\x12\x02\
    \x01\x01\x12\x04\xfe\x01\x18\x1d\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\
    \xfe\x01\x20!\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xff\x01\x08I\n\r\n\x05\
    \x04\x12\x02\x02\x04\x12\x04\xff\x01\x08\x10\n\r\n\x05\x04\x12\x02\x02\
    \x06\x12\x04\xff\x01\x115\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xff\x016\
    D\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xff\x01GH\n\x0c\n\x04\x04\x12\
    \x02\x03\x12\x04\x80\x02\x08>\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\x80\
    \x02\x08\x10\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\x80\x02\x11,\n\r\n\
    \x05\x04\x12\x02\x03\x01\x12\x04\x80\x02-9\n\r\n\x05\x04\x12\x02\x03\x03\
    \x12\x04\x80\x02<=\n\x0c\n\x02\x04\x13\x12\x06\x83\x02\0\x90\x02\x01\n\
    \x0b\n\x03\x04\x13\x01\x12\x04\x83\x02\x08\x17\n\x0e\n\x04\x04\x13\x03\0\
    \x12\x06\x84\x02\x08\x88\x02\t\n\r\n\x05\x04\x13\x03\0\x01\x12\x04\x84\
    \x02\x10\x1d\n\x0e\n\x06\x04\x13\x03\0\x02\0\x12\x04\x85\x02\x10-\n\x0f\
    \n\x07\x04\x13\x03\0\x02\0\x04\x12\x04\x85\x02\x10\x18\n\x0f\n\x07\x04\
    \x13\x03\0\x02\0\x05\x12\x04\x85\x02\x19\x1f\n\x0f\n\x07\x04\x13\x03\0\
    \x02\0\x01\x12\x04\x85\x02\x20(\n\x0f\n\x07\x04\x13\x03\0\x02\0\x03\x12\
    \x04\x85\x02+,\n\x0e\n\x06\x04\x13\x03\0\x02\x01\x12\x04\x86\x02\x10>\n\
    \x0f\n\x07\x04\x13\x03\0\x02\x01\x04\x12\x04\x86\x02\x10\x18\n\x0f\n\x07\
    \x04\x13\x03\0\x02\x01\x05\x12\x04\x86\x02\x19\x1e\n\x0f\n\x07\x04\x13\
    \x03\0\x02\x01\x01\x12\x04\x86\x02\x1f9\n\x0f\n\x07\x04\x13\x03\0\x02\
    \x01\x03\x12\x04\x86\x02<=\n\x0e\n\x06\x04\x13\x03\0\x02\x02\x12\x04\x87\
    \x02\x10=\n\x0f\n\x07\x04\x13\x03\0\x02\x02\x04\x12\x04\x87\x02\x10\x18\
    \n\x0f\n\x07\x04\x13\x03\0\x02\x02\x05\x12\x04\x87\x02\x19\x1e\n\x0f\n\
    \x07\x04\x13\x03\0\x02\x02\x01\x12\x04\x87\x02\x1f8\n\x0f\n\x07\x04\x13\
    \x03\0\x02\x02\x03\x12\x04\x87\x02;<\n\x0c\n\x04\x04\x13\x02\0\x12\x04\
    \x8a\x02\x08/\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\x8a\x02\x08\x10\n\r\n\
    \x05\x04\x13\x02\0\x05\x12\x04\x8a\x02\x11\x17\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\x8a\x02\x18*\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x8a\x02-.\
    \n\x0c\n\x04\x04\x13\x02\x01\x12\x04\x8b\x02\x08D\n\r\n\x05\x04\x13\x02\
    \x01\x04\x12\x04\x8b\x02\x08\x10\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\
    \x8b\x02\x11/\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\x8b\x020?\n\r\n\x05\
    \x04\x13\x02\x01\x03\x12\x04\x8b\x02BC\n\x0c\n\x04\x04\x13\x02\x02\x12\
    \x04\x8c\x02\x086\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\x8c\x02\x08\x10\
    \n\r\n\x05\x04\x13\x02\x02\x06\x12\x04\x8c\x02\x11\x20\n\r\n\x05\x04\x13\
    \x02\x02\x01\x12\x04\x8c\x02!1\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x8c\
    \x0245\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\x8d\x02\x08(\n\r\n\x05\x04\
    \x13\x02\x03\x04\x12\x04\x8d\x02\x08\x10\n\r\n\x05\x04\x13\x02\x03\x05\
    \x12\x04\x8d\x02\x11\x17\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\x8d\x02\
    \x18#\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\x8d\x02&'\n\x0c\n\x04\x04\
    \x13\x02\x04\x12\x04\x8e\x02\x08)\n\r\n\x05\x04\x13\x02\x04\x04\x12\x04\
    \x8e\x02\x08\x10\n\r\n\x05\x04\x13\x02\x04\x05\x12\x04\x8e\x02\x11\x17\n\
    \r\n\x05\x04\x13\x02\x04\x01\x12\x04\x8e\x02\x18$\n\r\n\x05\x04\x13\x02\
    \x04\x03\x12\x04\x8e\x02'(\n\x0c\n\x04\x04\x13\x02\x05\x12\x04\x8f\x02\
    \x087\n\r\n\x05\x04\x13\x02\x05\x04\x12\x04\x8f\x02\x08\x10\n\r\n\x05\
    \x04\x13\x02\x05\x06\x12\x04\x8f\x02\x11%\n\r\n\x05\x04\x13\x02\x05\x01\
    \x12\x04\x8f\x02&2\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\x8f\x0256\n\x0c\
    \n\x02\x04\x14\x12\x06\x92\x02\0\x97\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\
    \x04\x92\x02\x08$\n\x0c\n\x04\x04\x14\x02\0\x12\x04\x93\x02\x088\n\r\n\
    \x05\x04\x14\x02\0\x04\x12\x04\x93\x02\x08\x10\n\r\n\x05\x04\x14\x02\0\
    \x06\x12\x04\x93\x02\x11!\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x93\x02\"3\
    \n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x93\x0267\n\x0c\n\x04\x04\x14\x02\
    \x01\x12\x04\x94\x02\x08'\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\x94\x02\
    \x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\x94\x02\x11\x16\n\r\n\x05\
    \x04\x14\x02\x01\x01\x12\x04\x94\x02\x17\"\n\r\n\x05\x04\x14\x02\x01\x03\
    \x12\x04\x94\x02%&\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\x95\x02\x08)\n\r\
    \n\x05\x04\x14\x02\x02\x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\x04\x14\x02\
    \x02\x05\x12\x04\x95\x02\x11\x17\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\
    \x95\x02\x18$\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\x95\x02'(\n\x0c\n\
    \x04\x04\x14\x02\x03\x12\x04\x96\x02\x08:\n\r\n\x05\x04\x14\x02\x03\x04\
    \x12\x04\x96\x02\x08\x10\n\r\n\x05\x04\x14\x02\x03\x06\x12\x04\x96\x02\
    \x11&\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\x96\x02'5\n\r\n\x05\x04\x14\
    \x02\x03\x03\x12\x04\x96\x0289\n\x0c\n\x02\x04\x15\x12\x06\x99\x02\0\x9d\
    \x02\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\x99\x02\x088\n\x0c\n\x04\x04\
    \x15\x02\0\x12\x04\x9a\x02\x08$\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\x9a\
    \x02\x08\x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x9a\x02\x11\x16\n\r\n\
    \x05\x04\x15\x02\0\x01\x12\x04\x9a\x02\x17\x1f\n\r\n\x05\x04\x15\x02\0\
    \x03\x12\x04\x9a\x02\"#\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\x9b\x02\x08?\
    \n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04\x15\
    \x02\x01\x06\x12\x04\x9b\x02\x111\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\
    \x9b\x022:\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x9b\x02=>\n\x0c\n\x04\
    \x04\x15\x02\x02\x12\x04\x9c\x02\x08:\n\r\n\x05\x04\x15\x02\x02\x04\x12\
    \x04\x9c\x02\x08\x10\n\r\n\x05\x04\x15\x02\x02\x06\x12\x04\x9c\x02\x11-\
    \n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\x9c\x02.5\n\r\n\x05\x04\x15\x02\
    \x02\x03\x12\x04\x9c\x0289\n\x0c\n\x02\x04\x16\x12\x06\x9f\x02\0\xa3\x02\
    \x01\n\x0b\n\x03\x04\x16\x01\x12\x04\x9f\x02\x086\n\x0c\n\x04\x04\x16\
    \x02\0\x12\x04\xa0\x02\x08\"\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xa0\x02\
    \x08\x10\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xa0\x02\x11\x17\n\r\n\x05\
    \x04\x16\x02\0\x01\x12\x04\xa0\x02\x18\x1d\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\xa0\x02\x20!\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xa1\x02\x08\"\
    \n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xa1\x02\x08\x10\n\r\n\x05\x04\x16\
    \x02\x01\x05\x12\x04\xa1\x02\x11\x17\n\r\n\x05\x04\x16\x02\x01\x01\x12\
    \x04\xa1\x02\x18\x1d\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xa1\x02\x20!\
    \n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xa2\x02\x08%\n\r\n\x05\x04\x16\x02\
    \x02\x04\x12\x04\xa2\x02\x08\x10\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\
    \xa2\x02\x11\x17\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xa2\x02\x18\x20\n\
    \r\n\x05\x04\x16\x02\x02\x03\x12\x04\xa2\x02#$\n\x0c\n\x02\x04\x17\x12\
    \x06\xa5\x02\0\xa8\x02\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xa5\x02\x085\
    \n\x0c\n\x04\x04\x17\x02\0\x12\x04\xa6\x02\x083\n\r\n\x05\x04\x17\x02\0\
    \x04\x12\x04\xa6\x02\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xa6\x02\
    \x11\x17\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xa6\x02\x18.\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\xa6\x0212\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xa7\
    \x02\x083\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xa7\x02\x08\x10\n\r\n\
    \x05\x04\x17\x02\x01\x05\x12\x04\xa7\x02\x11\x17\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\xa7\x02\x18.\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xa7\
    \x0212\n\x0c\n\x02\x04\x18\x12\x06\xaa\x02\0\xb0\x02\x01\n\x0b\n\x03\x04\
    \x18\x01\x12\x04\xaa\x02\x08+\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xab\x02\
    \x08(\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xab\x02\x08\x10\n\r\n\x05\x04\
    \x18\x02\0\x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\
    \x04\xab\x02\x18#\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xab\x02&'\n\x0c\n\
    \x04\x04\x18\x02\x01\x12\x04\xac\x02\x08&\n\r\n\x05\x04\x18\x02\x01\x04\
    \x12\x04\xac\x02\x08\x10\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xac\x02\
    \x11\x17\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xac\x02\x18!\n\r\n\x05\
    \x04\x18\x02\x01\x03\x12\x04\xac\x02$%\n\x0c\n\x04\x04\x18\x02\x02\x12\
    \x04\xad\x02\x08(\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\xad\x02\x08\x10\
    \n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xad\x02\x11\x17\n\r\n\x05\x04\x18\
    \x02\x02\x01\x12\x04\xad\x02\x18#\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\
    \xad\x02&'\n\x0c\n\x04\x04\x18\x02\x03\x12\x04\xae\x02\x08+\n\r\n\x05\
    \x04\x18\x02\x03\x04\x12\x04\xae\x02\x08\x10\n\r\n\x05\x04\x18\x02\x03\
    \x05\x12\x04\xae\x02\x11\x17\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xae\
    \x02\x18&\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xae\x02)*\n\x0c\n\x04\
    \x04\x18\x02\x04\x12\x04\xaf\x02\x08<\n\r\n\x05\x04\x18\x02\x04\x04\x12\
    \x04\xaf\x02\x08\x10\n\r\n\x05\x04\x18\x02\x04\x06\x12\x04\xaf\x02\x11&\
    \n\r\n\x05\x04\x18\x02\x04\x01\x12\x04\xaf\x02'7\n\r\n\x05\x04\x18\x02\
    \x04\x03\x12\x04\xaf\x02:;\n\x0c\n\x02\x04\x19\x12\x06\xb2\x02\0\xb4\x02\
    \x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xb2\x02\x08*\n\x0c\n\x04\x04\x19\
    \x02\0\x12\x04\xb3\x02\x08#\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xb3\x02\
    \x08\x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xb3\x02\x11\x16\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\xb3\x02\x17\x1e\n\r\n\x05\x04\x19\x02\0\x03\
    \x12\x04\xb3\x02!\"\n\x0c\n\x02\x04\x1a\x12\x06\xb6\x02\0\xba\x02\x01\n\
    \x0b\n\x03\x04\x1a\x01\x12\x04\xb6\x02\x087\n\x0c\n\x04\x04\x1a\x02\0\
    \x12\x04\xb7\x02\x085\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xb7\x02\x08\
    \x10\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xb7\x02\x11\x20\n\r\n\x05\x04\
    \x1a\x02\0\x01\x12\x04\xb7\x02!0\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xb7\
    \x0234\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xb8\x02\x08(\n\r\n\x05\x04\
    \x1a\x02\x01\x04\x12\x04\xb8\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x01\x05\
    \x12\x04\xb8\x02\x11\x16\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xb8\x02\
    \x17#\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xb8\x02&'\n\x0c\n\x04\x04\
    \x1a\x02\x02\x12\x04\xb9\x02\x08'\n\r\n\x05\x04\x1a\x02\x02\x04\x12\x04\
    \xb9\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xb9\x02\x11\x16\n\
    \r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xb9\x02\x17\"\n\r\n\x05\x04\x1a\x02\
    \x02\x03\x12\x04\xb9\x02%&\n\x0c\n\x02\x04\x1b\x12\x06\xbc\x02\0\xd1\x02\
    \x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xbc\x02\x085\n\x0e\n\x04\x04\x1b\
    \x03\0\x12\x06\xbd\x02\x08\xc2\x02\t\n\r\n\x05\x04\x1b\x03\0\x01\x12\x04\
    \xbd\x02\x10\x14\n\x0e\n\x06\x04\x1b\x03\0\x02\0\x12\x04\xbe\x02\x10(\n\
    \x0f\n\x07\x04\x1b\x03\0\x02\0\x04\x12\x04\xbe\x02\x10\x18\n\x0f\n\x07\
    \x04\x1b\x03\0\x02\0\x05\x12\x04\xbe\x02\x19\x1e\n\x0f\n\x07\x04\x1b\x03\
    \0\x02\0\x01\x12\x04\xbe\x02\x1f#\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x03\
    \x12\x04\xbe\x02&'\n\x0e\n\x06\x04\x1b\x03\0\x02\x01\x12\x04\xbf\x02\x10\
    -\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x04\x12\x04\xbf\x02\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\0\x02\x01\x05\x12\x04\xbf\x02\x19\x1e\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x01\x01\x12\x04\xbf\x02\x1f(\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\x01\x03\x12\x04\xbf\x02+,\n\x0e\n\x06\x04\x1b\x03\0\x02\x02\x12\x04\
    \xc0\x02\x10,\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x04\x12\x04\xc0\x02\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x05\x12\x04\xc0\x02\x19\x1e\n\x0f\
    \n\x07\x04\x1b\x03\0\x02\x02\x01\x12\x04\xc0\x02\x1f'\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x02\x03\x12\x04\xc0\x02*+\n\x0e\n\x06\x04\x1b\x03\0\x02\
    \x03\x12\x04\xc1\x02\x10,\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x04\x12\x04\
    \xc1\x02\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x05\x12\x04\xc1\x02\
    \x19\x1e\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x01\x12\x04\xc1\x02\x1f'\n\
    \x0f\n\x07\x04\x1b\x03\0\x02\x03\x03\x12\x04\xc1\x02*+\n\x0c\n\x04\x04\
    \x1b\x02\0\x12\x04\xc4\x02\x08'\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xc4\
    \x02\x08\x10\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xc4\x02\x11\x16\n\r\n\
    \x05\x04\x1b\x02\0\x01\x12\x04\xc4\x02\x17\"\n\r\n\x05\x04\x1b\x02\0\x03\
    \x12\x04\xc4\x02%&\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xc5\x02\x088\n\r\
    \n\x05\x04\x1b\x02\x01\x04\x12\x04\xc5\x02\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x01\x05\x12\x04\xc5\x02\x11\x17\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\
    \xc5\x02\x183\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xc5\x0267\n\x0c\n\
    \x04\x04\x1b\x02\x02\x12\x04\xc6\x02\x08\"\n\r\n\x05\x04\x1b\x02\x02\x04\
    \x12\x04\xc6\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\xc6\x02\
    \x11\x17\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xc6\x02\x18\x1d\n\r\n\x05\
    \x04\x1b\x02\x02\x03\x12\x04\xc6\x02\x20!\n\x0c\n\x04\x04\x1b\x02\x03\
    \x12\x04\xc7\x02\x08=\n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\xc7\x02\x08\
    \x10\n\r\n\x05\x04\x1b\x02\x03\x05\x12\x04\xc7\x02\x11\x17\n\r\n\x05\x04\
    \x1b\x02\x03\x01\x12\x04\xc7\x02\x188\n\r\n\x05\x04\x1b\x02\x03\x03\x12\
    \x04\xc7\x02;<\n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xc8\x02\x084\n\r\n\
    \x05\x04\x1b\x02\x04\x04\x12\x04\xc8\x02\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x04\x06\x12\x04\xc8\x02\x11\"\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xc8\
    \x02#/\n\r\n\x05\x04\x1b\x02\x04\x03\x12\x04\xc8\x0223\n\x0c\n\x04\x04\
    \x1b\x02\x05\x12\x04\xc9\x02\x089\n\r\n\x05\x04\x1b\x02\x05\x04\x12\x04\
    \xc9\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x05\x05\x12\x04\xc9\x02\x11\x17\n\
    \r\n\x05\x04\x1b\x02\x05\x01\x12\x04\xc9\x02\x184\n\r\n\x05\x04\x1b\x02\
    \x05\x03\x12\x04\xc9\x0278\n\x0c\n\x04\x04\x1b\x02\x06\x12\x04\xca\x02\
    \x088\n\r\n\x05\x04\x1b\x02\x06\x04\x12\x04\xca\x02\x08\x10\n\r\n\x05\
    \x04\x1b\x02\x06\x05\x12\x04\xca\x02\x11\x17\n\r\n\x05\x04\x1b\x02\x06\
    \x01\x12\x04\xca\x02\x183\n\r\n\x05\x04\x1b\x02\x06\x03\x12\x04\xca\x026\
    7\n\x0c\n\x04\x04\x1b\x02\x07\x12\x04\xcb\x02\x08;\n\r\n\x05\x04\x1b\x02\
    \x07\x04\x12\x04\xcb\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x07\x05\x12\x04\
    \xcb\x02\x11\x17\n\r\n\x05\x04\x1b\x02\x07\x01\x12\x04\xcb\x02\x185\n\r\
    \n\x05\x04\x1b\x02\x07\x03\x12\x04\xcb\x028:\n\x0c\n\x04\x04\x1b\x02\x08\
    \x12\x04\xcc\x02\x08;\n\r\n\x05\x04\x1b\x02\x08\x04\x12\x04\xcc\x02\x08\
    \x10\n\r\n\x05\x04\x1b\x02\x08\x05\x12\x04\xcc\x02\x11\x17\n\r\n\x05\x04\
    \x1b\x02\x08\x01\x12\x04\xcc\x02\x185\n\r\n\x05\x04\x1b\x02\x08\x03\x12\
    \x04\xcc\x028:\n\x0c\n\x04\x04\x1b\x02\t\x12\x04\xcd\x02\x08;\n\r\n\x05\
    \x04\x1b\x02\t\x04\x12\x04\xcd\x02\x08\x10\n\r\n\x05\x04\x1b\x02\t\x06\
    \x12\x04\xcd\x02\x11\x1f\n\r\n\x05\x04\x1b\x02\t\x01\x12\x04\xcd\x02\x20\
    5\n\r\n\x05\x04\x1b\x02\t\x03\x12\x04\xcd\x028:\n\x0c\n\x04\x04\x1b\x02\
    \n\x12\x04\xce\x02\x08P\n\r\n\x05\x04\x1b\x02\n\x04\x12\x04\xce\x02\x08\
    \x10\n\r\n\x05\x04\x1b\x02\n\x06\x12\x04\xce\x02\x11D\n\r\n\x05\x04\x1b\
    \x02\n\x01\x12\x04\xce\x02EJ\n\r\n\x05\x04\x1b\x02\n\x03\x12\x04\xce\x02\
    MO\n\x0c\n\x04\x04\x1b\x02\x0b\x12\x04\xcf\x02\x08?\n\r\n\x05\x04\x1b\
    \x02\x0b\x04\x12\x04\xcf\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x0b\x05\x12\
    \x04\xcf\x02\x11\x17\n\r\n\x05\x04\x1b\x02\x0b\x01\x12\x04\xcf\x02\x189\
    \n\r\n\x05\x04\x1b\x02\x0b\x03\x12\x04\xcf\x02<>\n\x0c\n\x04\x04\x1b\x02\
    \x0c\x12\x04\xd0\x02\x088\n\r\n\x05\x04\x1b\x02\x0c\x04\x12\x04\xd0\x02\
    \x08\x10\n\r\n\x05\x04\x1b\x02\x0c\x05\x12\x04\xd0\x02\x11\x17\n\r\n\x05\
    \x04\x1b\x02\x0c\x01\x12\x04\xd0\x02\x182\n\r\n\x05\x04\x1b\x02\x0c\x03\
    \x12\x04\xd0\x0257\n\x0c\n\x02\x04\x1c\x12\x06\xd3\x02\0\xe3\x02\x01\n\
    \x0b\n\x03\x04\x1c\x01\x12\x04\xd3\x02\x080\n\x0e\n\x04\x04\x1c\x03\0\
    \x12\x06\xd4\x02\x08\xd7\x02\t\n\r\n\x05\x04\x1c\x03\0\x01\x12\x04\xd4\
    \x02\x10\x15\n\x0e\n\x06\x04\x1c\x03\0\x02\0\x12\x04\xd5\x02\x10)\n\x0f\
    \n\x07\x04\x1c\x03\0\x02\0\x04\x12\x04\xd5\x02\x10\x18\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\0\x05\x12\x04\xd5\x02\x19\x1e\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\0\x01\x12\x04\xd5\x02\x1f$\n\x0f\n\x07\x04\x1c\x03\0\x02\0\x03\x12\
    \x04\xd5\x02'(\n\x0e\n\x06\x04\x1c\x03\0\x02\x01\x12\x04\xd6\x02\x10.\n\
    \x0f\n\x07\x04\x1c\x03\0\x02\x01\x04\x12\x04\xd6\x02\x10\x18\n\x0f\n\x07\
    \x04\x1c\x03\0\x02\x01\x05\x12\x04\xd6\x02\x19\x1e\n\x0f\n\x07\x04\x1c\
    \x03\0\x02\x01\x01\x12\x04\xd6\x02\x1f)\n\x0f\n\x07\x04\x1c\x03\0\x02\
    \x01\x03\x12\x04\xd6\x02,-\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xd9\x02\x08\
    $\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xd9\x02\x08\x10\n\r\n\x05\x04\x1c\
    \x02\0\x05\x12\x04\xd9\x02\x11\x16\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\
    \xd9\x02\x17\x1f\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xd9\x02\"#\n\x0c\n\
    \x04\x04\x1c\x02\x01\x12\x04\xda\x02\x08*\n\r\n\x05\x04\x1c\x02\x01\x04\
    \x12\x04\xda\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xda\x02\
    \x11\x16\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xda\x02\x17%\n\r\n\x05\
    \x04\x1c\x02\x01\x03\x12\x04\xda\x02()\n\x0c\n\x04\x04\x1c\x02\x02\x12\
    \x04\xdb\x02\x08%\n\r\n\x05\x04\x1c\x02\x02\x04\x12\x04\xdb\x02\x08\x10\
    \n\r\n\x05\x04\x1c\x02\x02\x05\x12\x04\xdb\x02\x11\x16\n\r\n\x05\x04\x1c\
    \x02\x02\x01\x12\x04\xdb\x02\x17\x20\n\r\n\x05\x04\x1c\x02\x02\x03\x12\
    \x04\xdb\x02#$\n\x0c\n\x04\x04\x1c\x02\x03\x12\x04\xdc\x02\x08%\n\r\n\
    \x05\x04\x1c\x02\x03\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04\x1c\x02\
    \x03\x05\x12\x04\xdc\x02\x11\x16\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\
    \xdc\x02\x17\x20\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xdc\x02#$\n\x0c\n\
    \x04\x04\x1c\x02\x04\x12\x04\xdd\x02\x08&\n\r\n\x05\x04\x1c\x02\x04\x04\
    \x12\x04\xdd\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x04\x05\x12\x04\xdd\x02\
    \x11\x16\n\r\n\x05\x04\x1c\x02\x04\x01\x12\x04\xdd\x02\x17!\n\r\n\x05\
    \x04\x1c\x02\x04\x03\x12\x04\xdd\x02$%\n\x0c\n\x04\x04\x1c\x02\x05\x12\
    \x04\xde\x02\x08(\n\r\n\x05\x04\x1c\x02\x05\x04\x12\x04\xde\x02\x08\x10\
    \n\r\n\x05\x04\x1c\x02\x05\x05\x12\x04\xde\x02\x11\x16\n\r\n\x05\x04\x1c\
    \x02\x05\x01\x12\x04\xde\x02\x17#\n\r\n\x05\x04\x1c\x02\x05\x03\x12\x04\
    \xde\x02&'\n\x0c\n\x04\x04\x1c\x02\x06\x12\x04\xdf\x02\x08)\n\r\n\x05\
    \x04\x1c\x02\x06\x04\x12\x04\xdf\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x06\
    \x05\x12\x04\xdf\x02\x11\x16\n\r\n\x05\x04\x1c\x02\x06\x01\x12\x04\xdf\
    \x02\x17$\n\r\n\x05\x04\x1c\x02\x06\x03\x12\x04\xdf\x02'(\n\x0c\n\x04\
    \x04\x1c\x02\x07\x12\x04\xe0\x02\x08)\n\r\n\x05\x04\x1c\x02\x07\x04\x12\
    \x04\xe0\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x07\x05\x12\x04\xe0\x02\x11\
    \x16\n\r\n\x05\x04\x1c\x02\x07\x01\x12\x04\xe0\x02\x17$\n\r\n\x05\x04\
    \x1c\x02\x07\x03\x12\x04\xe0\x02'(\n\x0c\n\x04\x04\x1c\x02\x08\x12\x04\
    \xe1\x02\x08)\n\r\n\x05\x04\x1c\x02\x08\x04\x12\x04\xe1\x02\x08\x10\n\r\
    \n\x05\x04\x1c\x02\x08\x05\x12\x04\xe1\x02\x11\x16\n\r\n\x05\x04\x1c\x02\
    \x08\x01\x12\x04\xe1\x02\x17$\n\r\n\x05\x04\x1c\x02\x08\x03\x12\x04\xe1\
    \x02'(\n\x0c\n\x04\x04\x1c\x02\t\x12\x04\xe2\x02\x08M\n\r\n\x05\x04\x1c\
    \x02\t\x04\x12\x04\xe2\x02\x08\x10\n\r\n\x05\x04\x1c\x02\t\x06\x12\x04\
    \xe2\x02\x11@\n\r\n\x05\x04\x1c\x02\t\x01\x12\x04\xe2\x02AG\n\r\n\x05\
    \x04\x1c\x02\t\x03\x12\x04\xe2\x02JL\n\x0c\n\x02\x04\x1d\x12\x06\xe5\x02\
    \0\xef\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xe5\x02\x08\x19\n\x0e\n\
    \x04\x04\x1d\x03\0\x12\x06\xe6\x02\x08\xea\x02\t\n\r\n\x05\x04\x1d\x03\0\
    \x01\x12\x04\xe6\x02\x10\x19\n\x0e\n\x06\x04\x1d\x03\0\x02\0\x12\x04\xe7\
    \x02\x105\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x04\x12\x04\xe7\x02\x10\x18\n\
    \x0f\n\x07\x04\x1d\x03\0\x02\0\x05\x12\x04\xe7\x02\x19\x1e\n\x0f\n\x07\
    \x04\x1d\x03\0\x02\0\x01\x12\x04\xe7\x02\x1f0\n\x0f\n\x07\x04\x1d\x03\0\
    \x02\0\x03\x12\x04\xe7\x0234\n\x0e\n\x06\x04\x1d\x03\0\x02\x01\x12\x04\
    \xe8\x02\x103\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x04\x12\x04\xe8\x02\x10\
    \x18\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x05\x12\x04\xe8\x02\x19\x1f\n\x0f\
    \n\x07\x04\x1d\x03\0\x02\x01\x01\x12\x04\xe8\x02\x20.\n\x0f\n\x07\x04\
    \x1d\x03\0\x02\x01\x03\x12\x04\xe8\x0212\n\x0e\n\x06\x04\x1d\x03\0\x02\
    \x02\x12\x04\xe9\x02\x105\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x04\x12\x04\
    \xe9\x02\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x05\x12\x04\xe9\x02\
    \x19\x1f\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x01\x12\x04\xe9\x02\x200\n\
    \x0f\n\x07\x04\x1d\x03\0\x02\x02\x03\x12\x04\xe9\x0234\n\x0c\n\x04\x04\
    \x1d\x02\0\x12\x04\xec\x02\x08+\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xec\
    \x02\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xec\x02\x11\x16\n\r\n\
    \x05\x04\x1d\x02\0\x01\x12\x04\xec\x02\x17&\n\r\n\x05\x04\x1d\x02\0\x03\
    \x12\x04\xec\x02)*\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xed\x02\x08E\n\r\
    \n\x05\x04\x1d\x02\x01\x04\x12\x04\xed\x02\x08\x10\n\r\n\x05\x04\x1d\x02\
    \x01\x06\x12\x04\xed\x02\x11:\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xed\
    \x02;@\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xed\x02CD\n\x0c\n\x04\x04\
    \x1d\x02\x02\x12\x04\xee\x02\x088\n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\
    \xee\x02\x08\x10\n\r\n\x05\x04\x1d\x02\x02\x06\x12\x04\xee\x02\x11-\n\r\
    \n\x05\x04\x1d\x02\x02\x01\x12\x04\xee\x02.3\n\r\n\x05\x04\x1d\x02\x02\
    \x03\x12\x04\xee\x0267\n\x0c\n\x02\x04\x1e\x12\x06\xf1\x02\0\x81\x03\x01\
    \n\x0b\n\x03\x04\x1e\x01\x12\x04\xf1\x02\x086\n\x0c\n\x04\x04\x1e\x02\0\
    \x12\x04\xf2\x02\x08(\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xf2\x02\x08\
    \x10\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xf2\x02\x11\x17\n\r\n\x05\x04\
    \x1e\x02\0\x01\x12\x04\xf2\x02\x18#\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\
    \xf2\x02&'\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\xf3\x02\x08&\n\r\n\x05\
    \x04\x1e\x02\x01\x04\x12\x04\xf3\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x01\
    \x05\x12\x04\xf3\x02\x11\x17\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xf3\
    \x02\x18!\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xf3\x02$%\n\x0c\n\x04\
    \x04\x1e\x02\x02\x12\x04\xf4\x02\x08%\n\r\n\x05\x04\x1e\x02\x02\x04\x12\
    \x04\xf4\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\xf4\x02\x11\
    \x17\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xf4\x02\x18\x20\n\r\n\x05\x04\
    \x1e\x02\x02\x03\x12\x04\xf4\x02#$\n\x0c\n\x04\x04\x1e\x02\x03\x12\x04\
    \xf5\x02\x08+\n\r\n\x05\x04\x1e\x02\x03\x04\x12\x04\xf5\x02\x08\x10\n\r\
    \n\x05\x04\x1e\x02\x03\x05\x12\x04\xf5\x02\x11\x17\n\r\n\x05\x04\x1e\x02\
    \x03\x01\x12\x04\xf5\x02\x18&\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xf5\
    \x02)*\n\x0c\n\x04\x04\x1e\x02\x04\x12\x04\xf6\x02\x081\n\r\n\x05\x04\
    \x1e\x02\x04\x04\x12\x04\xf6\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x04\x06\
    \x12\x04\xf6\x02\x11#\n\r\n\x05\x04\x1e\x02\x04\x01\x12\x04\xf6\x02$,\n\
    \r\n\x05\x04\x1e\x02\x04\x03\x12\x04\xf6\x02/0\n\x0c\n\x04\x04\x1e\x02\
    \x05\x12\x04\xf7\x02\x08+\n\r\n\x05\x04\x1e\x02\x05\x04\x12\x04\xf7\x02\
    \x08\x10\n\r\n\x05\x04\x1e\x02\x05\x05\x12\x04\xf7\x02\x11\x17\n\r\n\x05\
    \x04\x1e\x02\x05\x01\x12\x04\xf7\x02\x18&\n\r\n\x05\x04\x1e\x02\x05\x03\
    \x12\x04\xf7\x02)*\n\x0c\n\x04\x04\x1e\x02\x06\x12\x04\xf8\x02\x08/\n\r\
    \n\x05\x04\x1e\x02\x06\x04\x12\x04\xf8\x02\x08\x10\n\r\n\x05\x04\x1e\x02\
    \x06\x05\x12\x04\xf8\x02\x11\x17\n\r\n\x05\x04\x1e\x02\x06\x01\x12\x04\
    \xf8\x02\x18*\n\r\n\x05\x04\x1e\x02\x06\x03\x12\x04\xf8\x02-.\n\x0c\n\
    \x04\x04\x1e\x02\x07\x12\x04\xf9\x02\x08&\n\r\n\x05\x04\x1e\x02\x07\x04\
    \x12\x04\xf9\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x07\x05\x12\x04\xf9\x02\
    \x11\x17\n\r\n\x05\x04\x1e\x02\x07\x01\x12\x04\xf9\x02\x18!\n\r\n\x05\
    \x04\x1e\x02\x07\x03\x12\x04\xf9\x02$%\n\x0c\n\x04\x04\x1e\x02\x08\x12\
    \x04\xfa\x02\x08.\n\r\n\x05\x04\x1e\x02\x08\x04\x12\x04\xfa\x02\x08\x10\
    \n\r\n\x05\x04\x1e\x02\x08\x06\x12\x04\xfa\x02\x11\x1f\n\r\n\x05\x04\x1e\
    \x02\x08\x01\x12\x04\xfa\x02\x20)\n\r\n\x05\x04\x1e\x02\x08\x03\x12\x04\
    \xfa\x02,-\n\x0c\n\x04\x04\x1e\x02\t\x12\x04\xfb\x02\x08/\n\r\n\x05\x04\
    \x1e\x02\t\x04\x12\x04\xfb\x02\x08\x10\n\r\n\x05\x04\x1e\x02\t\x05\x12\
    \x04\xfb\x02\x11\x17\n\r\n\x05\x04\x1e\x02\t\x01\x12\x04\xfb\x02\x18)\n\
    \r\n\x05\x04\x1e\x02\t\x03\x12\x04\xfb\x02,.\n\x0c\n\x04\x04\x1e\x02\n\
    \x12\x04\xfc\x02\x088\n\r\n\x05\x04\x1e\x02\n\x04\x12\x04\xfc\x02\x08\
    \x10\n\r\n\x05\x04\x1e\x02\n\x06\x12\x04\xfc\x02\x11!\n\r\n\x05\x04\x1e\
    \x02\n\x01\x12\x04\xfc\x02\"2\n\r\n\x05\x04\x1e\x02\n\x03\x12\x04\xfc\
    \x0257\n\x0c\n\x04\x04\x1e\x02\x0b\x12\x04\xfd\x02\x087\n\r\n\x05\x04\
    \x1e\x02\x0b\x04\x12\x04\xfd\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x0b\x06\
    \x12\x04\xfd\x02\x11\x20\n\r\n\x05\x04\x1e\x02\x0b\x01\x12\x04\xfd\x02!1\
    \n\r\n\x05\x04\x1e\x02\x0b\x03\x12\x04\xfd\x0246\n\x0c\n\x04\x04\x1e\x02\
    \x0c\x12\x04\xfe\x02\x08<\n\r\n\x05\x04\x1e\x02\x0c\x04\x12\x04\xfe\x02\
    \x08\x10\n\r\n\x05\x04\x1e\x02\x0c\x05\x12\x04\xfe\x02\x11\x17\n\r\n\x05\
    \x04\x1e\x02\x0c\x01\x12\x04\xfe\x02\x186\n\r\n\x05\x04\x1e\x02\x0c\x03\
    \x12\x04\xfe\x029;\n\x0c\n\x04\x04\x1e\x02\r\x12\x04\xff\x02\x08.\n\r\n\
    \x05\x04\x1e\x02\r\x04\x12\x04\xff\x02\x08\x10\n\r\n\x05\x04\x1e\x02\r\
    \x05\x12\x04\xff\x02\x11\x17\n\r\n\x05\x04\x1e\x02\r\x01\x12\x04\xff\x02\
    \x18(\n\r\n\x05\x04\x1e\x02\r\x03\x12\x04\xff\x02+-\n\x0c\n\x04\x04\x1e\
    \x02\x0e\x12\x04\x80\x03\x088\n\r\n\x05\x04\x1e\x02\x0e\x04\x12\x04\x80\
    \x03\x08\x10\n\r\n\x05\x04\x1e\x02\x0e\x06\x12\x04\x80\x03\x11#\n\r\n\
    \x05\x04\x1e\x02\x0e\x01\x12\x04\x80\x03$2\n\r\n\x05\x04\x1e\x02\x0e\x03\
    \x12\x04\x80\x0357\n\x0c\n\x02\x04\x1f\x12\x06\x83\x03\0\x91\x03\x01\n\
    \x0b\n\x03\x04\x1f\x01\x12\x04\x83\x03\x08?\n\x0c\n\x04\x04\x1f\x02\0\
    \x12\x04\x84\x03\x08*\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\x84\x03\x08\
    \x10\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\x84\x03\x11\x17\n\r\n\x05\x04\
    \x1f\x02\0\x01\x12\x04\x84\x03\x18%\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\
    \x84\x03()\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\x85\x03\x08Q\n\r\n\x05\
    \x04\x1f\x02\x01\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x01\
    \x06\x12\x04\x85\x03\x11@\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\x85\x03A\
    L\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\x85\x03OP\n\x0c\n\x04\x04\x1f\
    \x02\x02\x12\x04\x86\x03\x08\x20\n\r\n\x05\x04\x1f\x02\x02\x04\x12\x04\
    \x86\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\x86\x03\x11\x17\n\
    \r\n\x05\x04\x1f\x02\x02\x01\x12\x04\x86\x03\x18\x1b\n\r\n\x05\x04\x1f\
    \x02\x02\x03\x12\x04\x86\x03\x1e\x1f\n\x0c\n\x04\x04\x1f\x02\x03\x12\x04\
    \x87\x03\x080\n\r\n\x05\x04\x1f\x02\x03\x04\x12\x04\x87\x03\x08\x10\n\r\
    \n\x05\x04\x1f\x02\x03\x05\x12\x04\x87\x03\x11\x17\n\r\n\x05\x04\x1f\x02\
    \x03\x01\x12\x04\x87\x03\x18+\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\x87\
    \x03./\n\x0c\n\x04\x04\x1f\x02\x04\x12\x04\x88\x03\x08+\n\r\n\x05\x04\
    \x1f\x02\x04\x04\x12\x04\x88\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x04\x05\
    \x12\x04\x88\x03\x11\x17\n\r\n\x05\x04\x1f\x02\x04\x01\x12\x04\x88\x03\
    \x18&\n\r\n\x05\x04\x1f\x02\x04\x03\x12\x04\x88\x03)*\n\x0c\n\x04\x04\
    \x1f\x02\x05\x12\x04\x89\x03\x08-\n\r\n\x05\x04\x1f\x02\x05\x04\x12\x04\
    \x89\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x05\x06\x12\x04\x89\x03\x11\x20\n\
    \r\n\x05\x04\x1f\x02\x05\x01\x12\x04\x89\x03!(\n\r\n\x05\x04\x1f\x02\x05\
    \x03\x12\x04\x89\x03+,\n\x0c\n\x04\x04\x1f\x02\x06\x12\x04\x8a\x03\x083\
    \n\r\n\x05\x04\x1f\x02\x06\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\x04\x1f\
    \x02\x06\x05\x12\x04\x8a\x03\x11\x17\n\r\n\x05\x04\x1f\x02\x06\x01\x12\
    \x04\x8a\x03\x18.\n\r\n\x05\x04\x1f\x02\x06\x03\x12\x04\x8a\x0312\n\x0c\
    \n\x04\x04\x1f\x02\x07\x12\x04\x8b\x03\x081\n\r\n\x05\x04\x1f\x02\x07\
    \x04\x12\x04\x8b\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x07\x05\x12\x04\x8b\
    \x03\x11\x17\n\r\n\x05\x04\x1f\x02\x07\x01\x12\x04\x8b\x03\x18,\n\r\n\
    \x05\x04\x1f\x02\x07\x03\x12\x04\x8b\x03/0\n\x0c\n\x04\x04\x1f\x02\x08\
    \x12\x04\x8c\x03\x085\n\r\n\x05\x04\x1f\x02\x08\x04\x12\x04\x8c\x03\x08\
    \x10\n\r\n\x05\x04\x1f\x02\x08\x05\x12\x04\x8c\x03\x11\x17\n\r\n\x05\x04\
    \x1f\x02\x08\x01\x12\x04\x8c\x03\x180\n\r\n\x05\x04\x1f\x02\x08\x03\x12\
    \x04\x8c\x0334\n\x0c\n\x04\x04\x1f\x02\t\x12\x04\x8d\x03\x084\n\r\n\x05\
    \x04\x1f\x02\t\x04\x12\x04\x8d\x03\x08\x10\n\r\n\x05\x04\x1f\x02\t\x05\
    \x12\x04\x8d\x03\x11\x17\n\r\n\x05\x04\x1f\x02\t\x01\x12\x04\x8d\x03\x18\
    .\n\r\n\x05\x04\x1f\x02\t\x03\x12\x04\x8d\x0313\n\x0c\n\x04\x04\x1f\x02\
    \n\x12\x04\x8e\x03\x089\n\r\n\x05\x04\x1f\x02\n\x04\x12\x04\x8e\x03\x08\
    \x10\n\r\n\x05\x04\x1f\x02\n\x05\x12\x04\x8e\x03\x11\x17\n\r\n\x05\x04\
    \x1f\x02\n\x01\x12\x04\x8e\x03\x183\n\r\n\x05\x04\x1f\x02\n\x03\x12\x04\
    \x8e\x0368\n\x0c\n\x04\x04\x1f\x02\x0b\x12\x04\x8f\x03\x08.\n\r\n\x05\
    \x04\x1f\x02\x0b\x04\x12\x04\x8f\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x0b\
    \x05\x12\x04\x8f\x03\x11\x17\n\r\n\x05\x04\x1f\x02\x0b\x01\x12\x04\x8f\
    \x03\x18(\n\r\n\x05\x04\x1f\x02\x0b\x03\x12\x04\x8f\x03+-\n\x0c\n\x04\
    \x04\x1f\x02\x0c\x12\x04\x90\x03\x08,\n\r\n\x05\x04\x1f\x02\x0c\x04\x12\
    \x04\x90\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x0c\x05\x12\x04\x90\x03\x11\
    \x17\n\r\n\x05\x04\x1f\x02\x0c\x01\x12\x04\x90\x03\x18&\n\r\n\x05\x04\
    \x1f\x02\x0c\x03\x12\x04\x90\x03)+\n\x0c\n\x02\x04\x20\x12\x06\x93\x03\0\
    \x99\x03\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x93\x03\x086\n\x0c\n\x04\
    \x04\x20\x02\0\x12\x04\x94\x03\x08%\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\
    \x94\x03\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\x94\x03\x11\x17\n\r\
    \n\x05\x04\x20\x02\0\x01\x12\x04\x94\x03\x18\x20\n\r\n\x05\x04\x20\x02\0\
    \x03\x12\x04\x94\x03#$\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\x95\x03\x08*\
    \n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\x95\x03\x08\x10\n\r\n\x05\x04\x20\
    \x02\x01\x05\x12\x04\x95\x03\x11\x17\n\r\n\x05\x04\x20\x02\x01\x01\x12\
    \x04\x95\x03\x18%\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\x95\x03()\n\x0c\
    \n\x04\x04\x20\x02\x02\x12\x04\x96\x03\x08Q\n\r\n\x05\x04\x20\x02\x02\
    \x04\x12\x04\x96\x03\x08\x10\n\r\n\x05\x04\x20\x02\x02\x06\x12\x04\x96\
    \x03\x11@\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\x96\x03AL\n\r\n\x05\x04\
    \x20\x02\x02\x03\x12\x04\x96\x03OP\n\x0c\n\x04\x04\x20\x02\x03\x12\x04\
    \x97\x03\x08\x20\n\r\n\x05\x04\x20\x02\x03\x04\x12\x04\x97\x03\x08\x10\n\
    \r\n\x05\x04\x20\x02\x03\x05\x12\x04\x97\x03\x11\x17\n\r\n\x05\x04\x20\
    \x02\x03\x01\x12\x04\x97\x03\x18\x1b\n\r\n\x05\x04\x20\x02\x03\x03\x12\
    \x04\x97\x03\x1e\x1f\n\x0c\n\x04\x04\x20\x02\x04\x12\x04\x98\x03\x08+\n\
    \r\n\x05\x04\x20\x02\x04\x04\x12\x04\x98\x03\x08\x10\n\r\n\x05\x04\x20\
    \x02\x04\x05\x12\x04\x98\x03\x11\x17\n\r\n\x05\x04\x20\x02\x04\x01\x12\
    \x04\x98\x03\x18&\n\r\n\x05\x04\x20\x02\x04\x03\x12\x04\x98\x03)*\n\x0c\
    \n\x02\x04!\x12\x06\x9b\x03\0\xba\x03\x01\n\x0b\n\x03\x04!\x01\x12\x04\
    \x9b\x03\x086\n\x0e\n\x04\x04!\x03\0\x12\x06\x9c\x03\x08\x9e\x03\t\n\r\n\
    \x05\x04!\x03\0\x01\x12\x04\x9c\x03\x10\x18\n\x0e\n\x06\x04!\x03\0\x02\0\
    \x12\x04\x9d\x03\x100\n\x0f\n\x07\x04!\x03\0\x02\0\x04\x12\x04\x9d\x03\
    \x10\x18\n\x0f\n\x07\x04!\x03\0\x02\0\x05\x12\x04\x9d\x03\x19\x1f\n\x0f\
    \n\x07\x04!\x03\0\x02\0\x01\x12\x04\x9d\x03\x20+\n\x0f\n\x07\x04!\x03\0\
    \x02\0\x03\x12\x04\x9d\x03./\n\x0c\n\x04\x04!\x02\0\x12\x04\xa0\x03\x08*\
    \n\r\n\x05\x04!\x02\0\x04\x12\x04\xa0\x03\x08\x10\n\r\n\x05\x04!\x02\0\
    \x05\x12\x04\xa0\x03\x11\x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\xa0\x03\
    \x18%\n\r\n\x05\x04!\x02\0\x03\x12\x04\xa0\x03()\n\x0c\n\x04\x04!\x02\
    \x01\x12\x04\xa1\x03\x08Q\n\r\n\x05\x04!\x02\x01\x04\x12\x04\xa1\x03\x08\
    \x10\n\r\n\x05\x04!\x02\x01\x06\x12\x04\xa1\x03\x11@\n\r\n\x05\x04!\x02\
    \x01\x01\x12\x04\xa1\x03AL\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xa1\x03OP\
    \n\x0c\n\x04\x04!\x02\x02\x12\x04\xa2\x03\x08\x20\n\r\n\x05\x04!\x02\x02\
    \x04\x12\x04\xa2\x03\x08\x10\n\r\n\x05\x04!\x02\x02\x05\x12\x04\xa2\x03\
    \x11\x17\n\r\n\x05\x04!\x02\x02\x01\x12\x04\xa2\x03\x18\x1b\n\r\n\x05\
    \x04!\x02\x02\x03\x12\x04\xa2\x03\x1e\x1f\n\x0c\n\x04\x04!\x02\x03\x12\
    \x04\xa3\x03\x08!\n\r\n\x05\x04!\x02\x03\x04\x12\x04\xa3\x03\x08\x10\n\r\
    \n\x05\x04!\x02\x03\x05\x12\x04\xa3\x03\x11\x16\n\r\n\x05\x04!\x02\x03\
    \x01\x12\x04\xa3\x03\x17\x1c\n\r\n\x05\x04!\x02\x03\x03\x12\x04\xa3\x03\
    \x1f\x20\n\x0c\n\x04\x04!\x02\x04\x12\x04\xa4\x03\x08!\n\r\n\x05\x04!\
    \x02\x04\x04\x12\x04\xa4\x03\x08\x10\n\r\n\x05\x04!\x02\x04\x05\x12\x04\
    \xa4\x03\x11\x16\n\r\n\x05\x04!\x02\x04\x01\x12\x04\xa4\x03\x17\x1c\n\r\
    \n\x05\x04!\x02\x04\x03\x12\x04\xa4\x03\x1f\x20\n\x0c\n\x04\x04!\x02\x05\
    \x12\x04\xa5\x03\x08#\n\r\n\x05\x04!\x02\x05\x04\x12\x04\xa5\x03\x08\x10\
    \n\r\n\x05\x04!\x02\x05\x05\x12\x04\xa5\x03\x11\x16\n\r\n\x05\x04!\x02\
    \x05\x01\x12\x04\xa5\x03\x17\x1e\n\r\n\x05\x04!\x02\x05\x03\x12\x04\xa5\
    \x03!\"\n\x0c\n\x04\x04!\x02\x06\x12\x04\xa6\x03\x08\"\n\r\n\x05\x04!\
    \x02\x06\x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x04!\x02\x06\x05\x12\x04\
    \xa6\x03\x11\x16\n\r\n\x05\x04!\x02\x06\x01\x12\x04\xa6\x03\x17\x1d\n\r\
    \n\x05\x04!\x02\x06\x03\x12\x04\xa6\x03\x20!\n\x0c\n\x04\x04!\x02\x07\
    \x12\x04\xa7\x03\x08\"\n\r\n\x05\x04!\x02\x07\x04\x12\x04\xa7\x03\x08\
    \x10\n\r\n\x05\x04!\x02\x07\x05\x12\x04\xa7\x03\x11\x16\n\r\n\x05\x04!\
    \x02\x07\x01\x12\x04\xa7\x03\x17\x1d\n\r\n\x05\x04!\x02\x07\x03\x12\x04\
    \xa7\x03\x20!\n\x0c\n\x04\x04!\x02\x08\x12\x04\xa8\x03\x08!\n\r\n\x05\
    \x04!\x02\x08\x04\x12\x04\xa8\x03\x08\x10\n\r\n\x05\x04!\x02\x08\x05\x12\
    \x04\xa8\x03\x11\x16\n\r\n\x05\x04!\x02\x08\x01\x12\x04\xa8\x03\x17\x1c\
    \n\r\n\x05\x04!\x02\x08\x03\x12\x04\xa8\x03\x1f\x20\n\x0c\n\x04\x04!\x02\
    \t\x12\x04\xa9\x03\x08)\n\r\n\x05\x04!\x02\t\x04\x12\x04\xa9\x03\x08\x10\
    \n\r\n\x05\x04!\x02\t\x05\x12\x04\xa9\x03\x11\x16\n\r\n\x05\x04!\x02\t\
    \x01\x12\x04\xa9\x03\x17#\n\r\n\x05\x04!\x02\t\x03\x12\x04\xa9\x03&(\n\
    \x0c\n\x04\x04!\x02\n\x12\x04\xaa\x03\x08)\n\r\n\x05\x04!\x02\n\x04\x12\
    \x04\xaa\x03\x08\x10\n\r\n\x05\x04!\x02\n\x05\x12\x04\xaa\x03\x11\x16\n\
    \r\n\x05\x04!\x02\n\x01\x12\x04\xaa\x03\x17#\n\r\n\x05\x04!\x02\n\x03\
    \x12\x04\xaa\x03&(\n\x0c\n\x04\x04!\x02\x0b\x12\x04\xab\x03\x08(\n\r\n\
    \x05\x04!\x02\x0b\x04\x12\x04\xab\x03\x08\x10\n\r\n\x05\x04!\x02\x0b\x05\
    \x12\x04\xab\x03\x11\x16\n\r\n\x05\x04!\x02\x0b\x01\x12\x04\xab\x03\x17\
    \"\n\r\n\x05\x04!\x02\x0b\x03\x12\x04\xab\x03%'\n\x0c\n\x04\x04!\x02\x0c\
    \x12\x04\xac\x03\x08N\n\r\n\x05\x04!\x02\x0c\x04\x12\x04\xac\x03\x08\x10\
    \n\r\n\x05\x04!\x02\x0c\x06\x12\x04\xac\x03\x11@\n\r\n\x05\x04!\x02\x0c\
    \x01\x12\x04\xac\x03AH\n\r\n\x05\x04!\x02\x0c\x03\x12\x04\xac\x03KM\n\
    \x0c\n\x04\x04!\x02\r\x12\x04\xad\x03\x08.\n\r\n\x05\x04!\x02\r\x04\x12\
    \x04\xad\x03\x08\x10\n\r\n\x05\x04!\x02\r\x05\x12\x04\xad\x03\x11\x16\n\
    \r\n\x05\x04!\x02\r\x01\x12\x04\xad\x03\x17(\n\r\n\x05\x04!\x02\r\x03\
    \x12\x04\xad\x03+-\n\x0c\n\x04\x04!\x02\x0e\x12\x04\xae\x03\x08+\n\r\n\
    \x05\x04!\x02\x0e\x04\x12\x04\xae\x03\x08\x10\n\r\n\x05\x04!\x02\x0e\x05\
    \x12\x04\xae\x03\x11\x16\n\r\n\x05\x04!\x02\x0e\x01\x12\x04\xae\x03\x17%\
    \n\r\n\x05\x04!\x02\x0e\x03\x12\x04\xae\x03(*\n\x0c\n\x04\x04!\x02\x0f\
    \x12\x04\xaf\x03\x08(\n\r\n\x05\x04!\x02\x0f\x04\x12\x04\xaf\x03\x08\x10\
    \n\r\n\x05\x04!\x02\x0f\x05\x12\x04\xaf\x03\x11\x16\n\r\n\x05\x04!\x02\
    \x0f\x01\x12\x04\xaf\x03\x17\"\n\r\n\x05\x04!\x02\x0f\x03\x12\x04\xaf\
    \x03%'\n\x0c\n\x04\x04!\x02\x10\x12\x04\xb0\x03\x08,\n\r\n\x05\x04!\x02\
    \x10\x04\x12\x04\xb0\x03\x08\x10\n\r\n\x05\x04!\x02\x10\x05\x12\x04\xb0\
    \x03\x11\x16\n\r\n\x05\x04!\x02\x10\x01\x12\x04\xb0\x03\x17&\n\r\n\x05\
    \x04!\x02\x10\x03\x12\x04\xb0\x03)+\n\x0c\n\x04\x04!\x02\x11\x12\x04\xb1\
    \x03\x08&\n\r\n\x05\x04!\x02\x11\x04\x12\x04\xb1\x03\x08\x10\n\r\n\x05\
    \x04!\x02\x11\x05\x12\x04\xb1\x03\x11\x16\n\r\n\x05\x04!\x02\x11\x01\x12\
    \x04\xb1\x03\x17\x20\n\r\n\x05\x04!\x02\x11\x03\x12\x04\xb1\x03#%\n\x0c\
    \n\x04\x04!\x02\x12\x12\x04\xb2\x03\x08&\n\r\n\x05\x04!\x02\x12\x04\x12\
    \x04\xb2\x03\x08\x10\n\r\n\x05\x04!\x02\x12\x05\x12\x04\xb2\x03\x11\x16\
    \n\r\n\x05\x04!\x02\x12\x01\x12\x04\xb2\x03\x17\x20\n\r\n\x05\x04!\x02\
    \x12\x03\x12\x04\xb2\x03#%\n\x0c\n\x04\x04!\x02\x13\x12\x04\xb3\x03\x08&\
    \n\r\n\x05\x04!\x02\x13\x04\x12\x04\xb3\x03\x08\x10\n\r\n\x05\x04!\x02\
    \x13\x05\x12\x04\xb3\x03\x11\x16\n\r\n\x05\x04!\x02\x13\x01\x12\x04\xb3\
    \x03\x17\x20\n\r\n\x05\x04!\x02\x13\x03\x12\x04\xb3\x03#%\n\x0c\n\x04\
    \x04!\x02\x14\x12\x04\xb4\x03\x08!\n\r\n\x05\x04!\x02\x14\x04\x12\x04\
    \xb4\x03\x08\x10\n\r\n\x05\x04!\x02\x14\x05\x12\x04\xb4\x03\x11\x16\n\r\
    \n\x05\x04!\x02\x14\x01\x12\x04\xb4\x03\x17\x1b\n\r\n\x05\x04!\x02\x14\
    \x03\x12\x04\xb4\x03\x1e\x20\n\x0c\n\x04\x04!\x02\x15\x12\x04\xb5\x03\
    \x08.\n\r\n\x05\x04!\x02\x15\x04\x12\x04\xb5\x03\x08\x10\n\r\n\x05\x04!\
    \x02\x15\x05\x12\x04\xb5\x03\x11\x17\n\r\n\x05\x04!\x02\x15\x01\x12\x04\
    \xb5\x03\x18(\n\r\n\x05\x04!\x02\x15\x03\x12\x04\xb5\x03+-\n\x0c\n\x04\
    \x04!\x02\x16\x12\x04\xb6\x03\x081\n\r\n\x05\x04!\x02\x16\x04\x12\x04\
    \xb6\x03\x08\x10\n\r\n\x05\x04!\x02\x16\x05\x12\x04\xb6\x03\x11\x17\n\r\
    \n\x05\x04!\x02\x16\x01\x12\x04\xb6\x03\x18+\n\r\n\x05\x04!\x02\x16\x03\
    \x12\x04\xb6\x03.0\n\x0c\n\x04\x04!\x02\x17\x12\x04\xb7\x03\x082\n\r\n\
    \x05\x04!\x02\x17\x04\x12\x04\xb7\x03\x08\x10\n\r\n\x05\x04!\x02\x17\x05\
    \x12\x04\xb7\x03\x11\x17\n\r\n\x05\x04!\x02\x17\x01\x12\x04\xb7\x03\x18,\
    \n\r\n\x05\x04!\x02\x17\x03\x12\x04\xb7\x03/1\n\x0c\n\x04\x04!\x02\x18\
    \x12\x04\xb8\x03\x08,\n\r\n\x05\x04!\x02\x18\x04\x12\x04\xb8\x03\x08\x10\
    \n\r\n\x05\x04!\x02\x18\x05\x12\x04\xb8\x03\x11\x16\n\r\n\x05\x04!\x02\
    \x18\x01\x12\x04\xb8\x03\x17&\n\r\n\x05\x04!\x02\x18\x03\x12\x04\xb8\x03\
    )+\n\x0c\n\x04\x04!\x02\x19\x12\x04\xb9\x03\x08Y\n\r\n\x05\x04!\x02\x19\
    \x04\x12\x04\xb9\x03\x08\x10\n\r\n\x05\x04!\x02\x19\x06\x12\x04\xb9\x03\
    \x11I\n\r\n\x05\x04!\x02\x19\x01\x12\x04\xb9\x03JS\n\r\n\x05\x04!\x02\
    \x19\x03\x12\x04\xb9\x03VX\n\x0c\n\x02\x04\"\x12\x06\xbc\x03\0\xc5\x03\
    \x01\n\x0b\n\x03\x04\"\x01\x12\x04\xbc\x03\x084\n\x0c\n\x04\x04\"\x02\0\
    \x12\x04\xbd\x03\x08K\n\r\n\x05\x04\"\x02\0\x04\x12\x04\xbd\x03\x08\x10\
    \n\r\n\x05\x04\"\x02\0\x06\x12\x04\xbd\x03\x11@\n\r\n\x05\x04\"\x02\0\
    \x01\x12\x04\xbd\x03AF\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xbd\x03IJ\n\x0c\
    \n\x04\x04\"\x02\x01\x12\x04\xbe\x03\x08M\n\r\n\x05\x04\"\x02\x01\x04\
    \x12\x04\xbe\x03\x08\x10\n\r\n\x05\x04\"\x02\x01\x06\x12\x04\xbe\x03\x11\
    @\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xbe\x03AH\n\r\n\x05\x04\"\x02\x01\
    \x03\x12\x04\xbe\x03KL\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xbf\x03\x08$\n\
    \r\n\x05\x04\"\x02\x02\x04\x12\x04\xbf\x03\x08\x10\n\r\n\x05\x04\"\x02\
    \x02\x05\x12\x04\xbf\x03\x11\x17\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xbf\
    \x03\x18\x1f\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xbf\x03\"#\n\x0c\n\x04\
    \x04\"\x02\x03\x12\x04\xc0\x03\x08)\n\r\n\x05\x04\"\x02\x03\x04\x12\x04\
    \xc0\x03\x08\x10\n\r\n\x05\x04\"\x02\x03\x05\x12\x04\xc0\x03\x11\x17\n\r\
    \n\x05\x04\"\x02\x03\x01\x12\x04\xc0\x03\x18$\n\r\n\x05\x04\"\x02\x03\
    \x03\x12\x04\xc0\x03'(\n\x0c\n\x04\x04\"\x02\x04\x12\x04\xc1\x03\x08.\n\
    \r\n\x05\x04\"\x02\x04\x04\x12\x04\xc1\x03\x08\x10\n\r\n\x05\x04\"\x02\
    \x04\x05\x12\x04\xc1\x03\x11\x17\n\r\n\x05\x04\"\x02\x04\x01\x12\x04\xc1\
    \x03\x18)\n\r\n\x05\x04\"\x02\x04\x03\x12\x04\xc1\x03,-\n\x0c\n\x04\x04\
    \"\x02\x05\x12\x04\xc2\x03\x08(\n\r\n\x05\x04\"\x02\x05\x04\x12\x04\xc2\
    \x03\x08\x10\n\r\n\x05\x04\"\x02\x05\x05\x12\x04\xc2\x03\x11\x15\n\r\n\
    \x05\x04\"\x02\x05\x01\x12\x04\xc2\x03\x16#\n\r\n\x05\x04\"\x02\x05\x03\
    \x12\x04\xc2\x03&'\n\x0c\n\x04\x04\"\x02\x06\x12\x04\xc3\x03\x08H\n\r\n\
    \x05\x04\"\x02\x06\x04\x12\x04\xc3\x03\x08\x10\n\r\n\x05\x04\"\x02\x06\
    \x06\x12\x04\xc3\x03\x11.\n\r\n\x05\x04\"\x02\x06\x01\x12\x04\xc3\x03/C\
    \n\r\n\x05\x04\"\x02\x06\x03\x12\x04\xc3\x03FG\n\x0c\n\x04\x04\"\x02\x07\
    \x12\x04\xc4\x03\x08+\n\r\n\x05\x04\"\x02\x07\x04\x12\x04\xc4\x03\x08\
    \x10\n\r\n\x05\x04\"\x02\x07\x05\x12\x04\xc4\x03\x11\x17\n\r\n\x05\x04\"\
    \x02\x07\x01\x12\x04\xc4\x03\x18&\n\r\n\x05\x04\"\x02\x07\x03\x12\x04\
    \xc4\x03)*\n\x0c\n\x02\x04#\x12\x06\xc7\x03\0\xc8\x03\x01\n\x0b\n\x03\
    \x04#\x01\x12\x04\xc7\x03\x084\n\x0c\n\x02\x04$\x12\x06\xca\x03\0\xdd\
    \x03\x01\n\x0b\n\x03\x04$\x01\x12\x04\xca\x03\x084\n\x0c\n\x04\x04$\x02\
    \0\x12\x04\xcb\x03\x08'\n\r\n\x05\x04$\x02\0\x04\x12\x04\xcb\x03\x08\x10\
    \n\r\n\x05\x04$\x02\0\x05\x12\x04\xcb\x03\x11\x17\n\r\n\x05\x04$\x02\0\
    \x01\x12\x04\xcb\x03\x18\"\n\r\n\x05\x04$\x02\0\x03\x12\x04\xcb\x03%&\n\
    \x0c\n\x04\x04$\x02\x01\x12\x04\xcc\x03\x08R\n\r\n\x05\x04$\x02\x01\x04\
    \x12\x04\xcc\x03\x08\x10\n\r\n\x05\x04$\x02\x01\x06\x12\x04\xcc\x03\x11@\
    \n\r\n\x05\x04$\x02\x01\x01\x12\x04\xcc\x03AM\n\r\n\x05\x04$\x02\x01\x03\
    \x12\x04\xcc\x03PQ\n\x0c\n\x04\x04$\x02\x02\x12\x04\xcd\x03\x084\n\r\n\
    \x05\x04$\x02\x02\x04\x12\x04\xcd\x03\x08\x10\n\r\n\x05\x04$\x02\x02\x06\
    \x12\x04\xcd\x03\x11\"\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xcd\x03#/\n\r\
    \n\x05\x04$\x02\x02\x03\x12\x04\xcd\x0323\n\x0c\n\x04\x04$\x02\x03\x12\
    \x04\xce\x03\x08,\n\r\n\x05\x04$\x02\x03\x04\x12\x04\xce\x03\x08\x10\n\r\
    \n\x05\x04$\x02\x03\x05\x12\x04\xce\x03\x11\x17\n\r\n\x05\x04$\x02\x03\
    \x01\x12\x04\xce\x03\x18'\n\r\n\x05\x04$\x02\x03\x03\x12\x04\xce\x03*+\n\
    \x0c\n\x04\x04$\x02\x04\x12\x04\xcf\x03\x08+\n\r\n\x05\x04$\x02\x04\x04\
    \x12\x04\xcf\x03\x08\x10\n\r\n\x05\x04$\x02\x04\x05\x12\x04\xcf\x03\x11\
    \x17\n\r\n\x05\x04$\x02\x04\x01\x12\x04\xcf\x03\x18&\n\r\n\x05\x04$\x02\
    \x04\x03\x12\x04\xcf\x03)*\n\x0c\n\x04\x04$\x02\x05\x12\x04\xd0\x03\x08&\
    \n\r\n\x05\x04$\x02\x05\x04\x12\x04\xd0\x03\x08\x10\n\r\n\x05\x04$\x02\
    \x05\x05\x12\x04\xd0\x03\x11\x16\n\r\n\x05\x04$\x02\x05\x01\x12\x04\xd0\
    \x03\x17!\n\r\n\x05\x04$\x02\x05\x03\x12\x04\xd0\x03$%\n\x0c\n\x04\x04$\
    \x02\x06\x12\x04\xd1\x03\x080\n\r\n\x05\x04$\x02\x06\x04\x12\x04\xd1\x03\
    \x08\x10\n\r\n\x05\x04$\x02\x06\x06\x12\x04\xd1\x03\x11#\n\r\n\x05\x04$\
    \x02\x06\x01\x12\x04\xd1\x03$+\n\r\n\x05\x04$\x02\x06\x03\x12\x04\xd1\
    \x03./\n\x0c\n\x04\x04$\x02\x07\x12\x04\xd2\x03\x08:\n\r\n\x05\x04$\x02\
    \x07\x04\x12\x04\xd2\x03\x08\x10\n\r\n\x05\x04$\x02\x07\x06\x12\x04\xd2\
    \x03\x11(\n\r\n\x05\x04$\x02\x07\x01\x12\x04\xd2\x03)5\n\r\n\x05\x04$\
    \x02\x07\x03\x12\x04\xd2\x0389\n\x0c\n\x04\x04$\x02\x08\x12\x04\xd3\x03\
    \x08.\n\r\n\x05\x04$\x02\x08\x04\x12\x04\xd3\x03\x08\x10\n\r\n\x05\x04$\
    \x02\x08\x06\x12\x04\xd3\x03\x11\"\n\r\n\x05\x04$\x02\x08\x01\x12\x04\
    \xd3\x03#)\n\r\n\x05\x04$\x02\x08\x03\x12\x04\xd3\x03,-\n\x0c\n\x04\x04$\
    \x02\t\x12\x04\xd4\x03\x088\n\r\n\x05\x04$\x02\t\x04\x12\x04\xd4\x03\x08\
    \x10\n\r\n\x05\x04$\x02\t\x06\x12\x04\xd4\x03\x11!\n\r\n\x05\x04$\x02\t\
    \x01\x12\x04\xd4\x03\"2\n\r\n\x05\x04$\x02\t\x03\x12\x04\xd4\x0357\n\x0c\
    \n\x04\x04$\x02\n\x12\x04\xd5\x03\x08=\n\r\n\x05\x04$\x02\n\x04\x12\x04\
    \xd5\x03\x08\x10\n\r\n\x05\x04$\x02\n\x06\x12\x04\xd5\x03\x11\x20\n\r\n\
    \x05\x04$\x02\n\x01\x12\x04\xd5\x03!7\n\r\n\x05\x04$\x02\n\x03\x12\x04\
    \xd5\x03:<\n\x0c\n\x04\x04$\x02\x0b\x12\x04\xd6\x03\x086\n\r\n\x05\x04$\
    \x02\x0b\x04\x12\x04\xd6\x03\x08\x10\n\r\n\x05\x04$\x02\x0b\x06\x12\x04\
    \xd6\x03\x11\x20\n\r\n\x05\x04$\x02\x0b\x01\x12\x04\xd6\x03!0\n\r\n\x05\
    \x04$\x02\x0b\x03\x12\x04\xd6\x0335\n\x0c\n\x04\x04$\x02\x0c\x12\x04\xd7\
    \x03\x08?\n\r\n\x05\x04$\x02\x0c\x04\x12\x04\xd7\x03\x08\x10\n\r\n\x05\
    \x04$\x02\x0c\x06\x12\x04\xd7\x03\x11!\n\r\n\x05\x04$\x02\x0c\x01\x12\
    \x04\xd7\x03\"9\n\r\n\x05\x04$\x02\x0c\x03\x12\x04\xd7\x03<>\n\x0c\n\x04\
    \x04$\x02\r\x12\x04\xd8\x03\x08)\n\r\n\x05\x04$\x02\r\x04\x12\x04\xd8\
    \x03\x08\x10\n\r\n\x05\x04$\x02\r\x05\x12\x04\xd8\x03\x11\x17\n\r\n\x05\
    \x04$\x02\r\x01\x12\x04\xd8\x03\x18#\n\r\n\x05\x04$\x02\r\x03\x12\x04\
    \xd8\x03&(\n\x0c\n\x04\x04$\x02\x0e\x12\x04\xd9\x03\x080\n\r\n\x05\x04$\
    \x02\x0e\x04\x12\x04\xd9\x03\x08\x10\n\r\n\x05\x04$\x02\x0e\x06\x12\x04\
    \xd9\x03\x11!\n\r\n\x05\x04$\x02\x0e\x01\x12\x04\xd9\x03\"*\n\r\n\x05\
    \x04$\x02\x0e\x03\x12\x04\xd9\x03-/\n\x0c\n\x04\x04$\x02\x0f\x12\x04\xda\
    \x03\x08)\n\r\n\x05\x04$\x02\x0f\x04\x12\x04\xda\x03\x08\x10\n\r\n\x05\
    \x04$\x02\x0f\x05\x12\x04\xda\x03\x11\x16\n\r\n\x05\x04$\x02\x0f\x01\x12\
    \x04\xda\x03\x17#\n\r\n\x05\x04$\x02\x0f\x03\x12\x04\xda\x03&(\n\x0c\n\
    \x04\x04$\x02\x10\x12\x04\xdb\x03\x08*\n\r\n\x05\x04$\x02\x10\x04\x12\
    \x04\xdb\x03\x08\x10\n\r\n\x05\x04$\x02\x10\x05\x12\x04\xdb\x03\x11\x16\
    \n\r\n\x05\x04$\x02\x10\x01\x12\x04\xdb\x03\x17$\n\r\n\x05\x04$\x02\x10\
    \x03\x12\x04\xdb\x03')\n\x0c\n\x04\x04$\x02\x11\x12\x04\xdc\x03\x082\n\r\
    \n\x05\x04$\x02\x11\x04\x12\x04\xdc\x03\x08\x10\n\r\n\x05\x04$\x02\x11\
    \x05\x12\x04\xdc\x03\x11\x16\n\r\n\x05\x04$\x02\x11\x01\x12\x04\xdc\x03\
    \x17,\n\r\n\x05\x04$\x02\x11\x03\x12\x04\xdc\x03/1\n\x0c\n\x02\x04%\x12\
    \x06\xdf\x03\0\xe6\x03\x01\n\x0b\n\x03\x04%\x01\x12\x04\xdf\x03\x081\n\
    \x0e\n\x04\x04%\x03\0\x12\x06\xe0\x03\x08\xe3\x03\t\n\r\n\x05\x04%\x03\0\
    \x01\x12\x04\xe0\x03\x10\x17\n\x0e\n\x06\x04%\x03\0\x02\0\x12\x04\xe1\
    \x03\x101\n\x0f\n\x07\x04%\x03\0\x02\0\x04\x12\x04\xe1\x03\x10\x18\n\x0f\
    \n\x07\x04%\x03\0\x02\0\x05\x12\x04\xe1\x03\x19\x1f\n\x0f\n\x07\x04%\x03\
    \0\x02\0\x01\x12\x04\xe1\x03\x20,\n\x0f\n\x07\x04%\x03\0\x02\0\x03\x12\
    \x04\xe1\x03/0\n\x0e\n\x06\x04%\x03\0\x02\x01\x12\x04\xe2\x03\x102\n\x0f\
    \n\x07\x04%\x03\0\x02\x01\x04\x12\x04\xe2\x03\x10\x18\n\x0f\n\x07\x04%\
    \x03\0\x02\x01\x05\x12\x04\xe2\x03\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02\
    \x01\x01\x12\x04\xe2\x03\x20-\n\x0f\n\x07\x04%\x03\0\x02\x01\x03\x12\x04\
    \xe2\x0301\n\x0c\n\x04\x04%\x02\0\x12\x04\xe5\x03\x08Q\n\r\n\x05\x04%\
    \x02\0\x04\x12\x04\xe5\x03\x08\x10\n\r\n\x05\x04%\x02\0\x06\x12\x04\xe5\
    \x03\x11C\n\r\n\x05\x04%\x02\0\x01\x12\x04\xe5\x03DL\n\r\n\x05\x04%\x02\
    \0\x03\x12\x04\xe5\x03OP\n\x0c\n\x02\x04&\x12\x06\xe8\x03\0\xed\x03\x01\
    \n\x0b\n\x03\x04&\x01\x12\x04\xe8\x03\x086\n\x0c\n\x04\x04&\x02\0\x12\
    \x04\xe9\x03\x08'\n\r\n\x05\x04&\x02\0\x04\x12\x04\xe9\x03\x08\x10\n\r\n\
    \x05\x04&\x02\0\x05\x12\x04\xe9\x03\x11\x17\n\r\n\x05\x04&\x02\0\x01\x12\
    \x04\xe9\x03\x18\"\n\r\n\x05\x04&\x02\0\x03\x12\x04\xe9\x03%&\n\x0c\n\
    \x04\x04&\x02\x01\x12\x04\xea\x03\x08U\n\r\n\x05\x04&\x02\x01\x04\x12\
    \x04\xea\x03\x08\x10\n\r\n\x05\x04&\x02\x01\x06\x12\x04\xea\x03\x11@\n\r\
    \n\x05\x04&\x02\x01\x01\x12\x04\xea\x03AP\n\r\n\x05\x04&\x02\x01\x03\x12\
    \x04\xea\x03ST\n\x0c\n\x04\x04&\x02\x02\x12\x04\xeb\x03\x08,\n\r\n\x05\
    \x04&\x02\x02\x04\x12\x04\xeb\x03\x08\x10\n\r\n\x05\x04&\x02\x02\x05\x12\
    \x04\xeb\x03\x11\x17\n\r\n\x05\x04&\x02\x02\x01\x12\x04\xeb\x03\x18'\n\r\
    \n\x05\x04&\x02\x02\x03\x12\x04\xeb\x03*+\n\x0c\n\x04\x04&\x02\x03\x12\
    \x04\xec\x03\x08+\n\r\n\x05\x04&\x02\x03\x04\x12\x04\xec\x03\x08\x10\n\r\
    \n\x05\x04&\x02\x03\x05\x12\x04\xec\x03\x11\x17\n\r\n\x05\x04&\x02\x03\
    \x01\x12\x04\xec\x03\x18&\n\r\n\x05\x04&\x02\x03\x03\x12\x04\xec\x03)*\n\
    \x0c\n\x02\x04'\x12\x06\xef\x03\0\xf3\x03\x01\n\x0b\n\x03\x04'\x01\x12\
    \x04\xef\x03\x083\n\x0c\n\x04\x04'\x02\0\x12\x04\xf0\x03\x08'\n\r\n\x05\
    \x04'\x02\0\x04\x12\x04\xf0\x03\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\
    \xf0\x03\x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\xf0\x03\x18\"\n\r\n\
    \x05\x04'\x02\0\x03\x12\x04\xf0\x03%&\n\x0c\n\x04\x04'\x02\x01\x12\x04\
    \xf1\x03\x08Q\n\r\n\x05\x04'\x02\x01\x04\x12\x04\xf1\x03\x08\x10\n\r\n\
    \x05\x04'\x02\x01\x06\x12\x04\xf1\x03\x11@\n\r\n\x05\x04'\x02\x01\x01\
    \x12\x04\xf1\x03AL\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xf1\x03OP\n\x0c\n\
    \x04\x04'\x02\x02\x12\x04\xf2\x03\x08#\n\r\n\x05\x04'\x02\x02\x04\x12\
    \x04\xf2\x03\x08\x10\n\r\n\x05\x04'\x02\x02\x05\x12\x04\xf2\x03\x11\x17\
    \n\r\n\x05\x04'\x02\x02\x01\x12\x04\xf2\x03\x18\x1e\n\r\n\x05\x04'\x02\
    \x02\x03\x12\x04\xf2\x03!\"\n\x0c\n\x02\x04(\x12\x06\xf5\x03\0\xf8\x03\
    \x01\n\x0b\n\x03\x04(\x01\x12\x04\xf5\x03\x089\n\x0c\n\x04\x04(\x02\0\
    \x12\x04\xf6\x03\x081\n\r\n\x05\x04(\x02\0\x04\x12\x04\xf6\x03\x08\x10\n\
    \r\n\x05\x04(\x02\0\x06\x12\x04\xf6\x03\x11#\n\r\n\x05\x04(\x02\0\x01\
    \x12\x04\xf6\x03$,\n\r\n\x05\x04(\x02\0\x03\x12\x04\xf6\x03/0\n\x0c\n\
    \x04\x04(\x02\x01\x12\x04\xf7\x03\x08%\n\r\n\x05\x04(\x02\x01\x04\x12\
    \x04\xf7\x03\x08\x10\n\r\n\x05\x04(\x02\x01\x05\x12\x04\xf7\x03\x11\x17\
    \n\r\n\x05\x04(\x02\x01\x01\x12\x04\xf7\x03\x18\x20\n\r\n\x05\x04(\x02\
    \x01\x03\x12\x04\xf7\x03#$\n\x0c\n\x02\x04)\x12\x06\xfa\x03\0\xfc\x03\
    \x01\n\x0b\n\x03\x04)\x01\x12\x04\xfa\x03\x08;\n\x0c\n\x04\x04)\x02\0\
    \x12\x04\xfb\x03\x08*\n\r\n\x05\x04)\x02\0\x04\x12\x04\xfb\x03\x08\x10\n\
    \r\n\x05\x04)\x02\0\x05\x12\x04\xfb\x03\x11\x17\n\r\n\x05\x04)\x02\0\x01\
    \x12\x04\xfb\x03\x18%\n\r\n\x05\x04)\x02\0\x03\x12\x04\xfb\x03()\n\x0c\n\
    \x02\x04*\x12\x06\xfe\x03\0\x82\x04\x01\n\x0b\n\x03\x04*\x01\x12\x04\xfe\
    \x03\x08;\n\x0c\n\x04\x04*\x02\0\x12\x04\xff\x03\x08'\n\r\n\x05\x04*\x02\
    \0\x04\x12\x04\xff\x03\x08\x10\n\r\n\x05\x04*\x02\0\x05\x12\x04\xff\x03\
    \x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\x04\xff\x03\x18\"\n\r\n\x05\x04*\
    \x02\0\x03\x12\x04\xff\x03%&\n\x0c\n\x04\x04*\x02\x01\x12\x04\x80\x04\
    \x08#\n\r\n\x05\x04*\x02\x01\x04\x12\x04\x80\x04\x08\x10\n\r\n\x05\x04*\
    \x02\x01\x05\x12\x04\x80\x04\x11\x17\n\r\n\x05\x04*\x02\x01\x01\x12\x04\
    \x80\x04\x18\x1e\n\r\n\x05\x04*\x02\x01\x03\x12\x04\x80\x04!\"\n\x0c\n\
    \x04\x04*\x02\x02\x12\x04\x81\x04\x08$\n\r\n\x05\x04*\x02\x02\x04\x12\
    \x04\x81\x04\x08\x10\n\r\n\x05\x04*\x02\x02\x05\x12\x04\x81\x04\x11\x17\
    \n\r\n\x05\x04*\x02\x02\x01\x12\x04\x81\x04\x18\x1f\n\r\n\x05\x04*\x02\
    \x02\x03\x12\x04\x81\x04\"#\n\x0c\n\x02\x04+\x12\x06\x84\x04\0\x8d\x04\
    \x01\n\x0b\n\x03\x04+\x01\x12\x04\x84\x04\x08-\n\x0c\n\x04\x04+\x02\0\
    \x12\x04\x85\x04\x08'\n\r\n\x05\x04+\x02\0\x04\x12\x04\x85\x04\x08\x10\n\
    \r\n\x05\x04+\x02\0\x05\x12\x04\x85\x04\x11\x17\n\r\n\x05\x04+\x02\0\x01\
    \x12\x04\x85\x04\x18\"\n\r\n\x05\x04+\x02\0\x03\x12\x04\x85\x04%&\n\x0c\
    \n\x04\x04+\x02\x01\x12\x04\x86\x04\x08'\n\r\n\x05\x04+\x02\x01\x04\x12\
    \x04\x86\x04\x08\x10\n\r\n\x05\x04+\x02\x01\x05\x12\x04\x86\x04\x11\x17\
    \n\r\n\x05\x04+\x02\x01\x01\x12\x04\x86\x04\x18\"\n\r\n\x05\x04+\x02\x01\
    \x03\x12\x04\x86\x04%&\n\x0c\n\x04\x04+\x02\x02\x12\x04\x87\x04\x08)\n\r\
    \n\x05\x04+\x02\x02\x04\x12\x04\x87\x04\x08\x10\n\r\n\x05\x04+\x02\x02\
    \x05\x12\x04\x87\x04\x11\x17\n\r\n\x05\x04+\x02\x02\x01\x12\x04\x87\x04\
    \x18$\n\r\n\x05\x04+\x02\x02\x03\x12\x04\x87\x04'(\n\x0c\n\x04\x04+\x02\
    \x03\x12\x04\x88\x04\x08*\n\r\n\x05\x04+\x02\x03\x04\x12\x04\x88\x04\x08\
    \x10\n\r\n\x05\x04+\x02\x03\x05\x12\x04\x88\x04\x11\x17\n\r\n\x05\x04+\
    \x02\x03\x01\x12\x04\x88\x04\x18%\n\r\n\x05\x04+\x02\x03\x03\x12\x04\x88\
    \x04()\n\x0c\n\x04\x04+\x02\x04\x12\x04\x89\x04\x08)\n\r\n\x05\x04+\x02\
    \x04\x04\x12\x04\x89\x04\x08\x10\n\r\n\x05\x04+\x02\x04\x05\x12\x04\x89\
    \x04\x11\x17\n\r\n\x05\x04+\x02\x04\x01\x12\x04\x89\x04\x18$\n\r\n\x05\
    \x04+\x02\x04\x03\x12\x04\x89\x04'(\n\x0c\n\x04\x04+\x02\x05\x12\x04\x8a\
    \x04\x08*\n\r\n\x05\x04+\x02\x05\x04\x12\x04\x8a\x04\x08\x10\n\r\n\x05\
    \x04+\x02\x05\x05\x12\x04\x8a\x04\x11\x17\n\r\n\x05\x04+\x02\x05\x01\x12\
    \x04\x8a\x04\x18%\n\r\n\x05\x04+\x02\x05\x03\x12\x04\x8a\x04()\n\x0c\n\
    \x04\x04+\x02\x06\x12\x04\x8b\x04\x08+\n\r\n\x05\x04+\x02\x06\x04\x12\
    \x04\x8b\x04\x08\x10\n\r\n\x05\x04+\x02\x06\x05\x12\x04\x8b\x04\x11\x17\
    \n\r\n\x05\x04+\x02\x06\x01\x12\x04\x8b\x04\x18&\n\r\n\x05\x04+\x02\x06\
    \x03\x12\x04\x8b\x04)*\n\x0c\n\x04\x04+\x02\x07\x12\x04\x8c\x04\x08%\n\r\
    \n\x05\x04+\x02\x07\x04\x12\x04\x8c\x04\x08\x10\n\r\n\x05\x04+\x02\x07\
    \x05\x12\x04\x8c\x04\x11\x17\n\r\n\x05\x04+\x02\x07\x01\x12\x04\x8c\x04\
    \x18\x20\n\r\n\x05\x04+\x02\x07\x03\x12\x04\x8c\x04#$\n\x0c\n\x02\x04,\
    \x12\x06\x8f\x04\0\x94\x04\x01\n\x0b\n\x03\x04,\x01\x12\x04\x8f\x04\x08.\
    \n\x0c\n\x04\x04,\x02\0\x12\x04\x90\x04\x08'\n\r\n\x05\x04,\x02\0\x04\
    \x12\x04\x90\x04\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\x90\x04\x11\
    \x17\n\r\n\x05\x04,\x02\0\x01\x12\x04\x90\x04\x18\"\n\r\n\x05\x04,\x02\0\
    \x03\x12\x04\x90\x04%&\n\x0c\n\x04\x04,\x02\x01\x12\x04\x91\x04\x08%\n\r\
    \n\x05\x04,\x02\x01\x04\x12\x04\x91\x04\x08\x10\n\r\n\x05\x04,\x02\x01\
    \x05\x12\x04\x91\x04\x11\x17\n\r\n\x05\x04,\x02\x01\x01\x12\x04\x91\x04\
    \x18\x20\n\r\n\x05\x04,\x02\x01\x03\x12\x04\x91\x04#$\n\x0c\n\x04\x04,\
    \x02\x02\x12\x04\x92\x04\x08:\n\r\n\x05\x04,\x02\x02\x04\x12\x04\x92\x04\
    \x08\x10\n\r\n\x05\x04,\x02\x02\x06\x12\x04\x92\x04\x11(\n\r\n\x05\x04,\
    \x02\x02\x01\x12\x04\x92\x04)5\n\r\n\x05\x04,\x02\x02\x03\x12\x04\x92\
    \x0489\n\x0c\n\x04\x04,\x02\x03\x12\x04\x93\x04\x08$\n\r\n\x05\x04,\x02\
    \x03\x04\x12\x04\x93\x04\x08\x10\n\r\n\x05\x04,\x02\x03\x05\x12\x04\x93\
    \x04\x11\x17\n\r\n\x05\x04,\x02\x03\x01\x12\x04\x93\x04\x18\x1e\n\r\n\
    \x05\x04,\x02\x03\x03\x12\x04\x93\x04!#\n\x0c\n\x02\x04-\x12\x06\x96\x04\
    \0\x9d\x04\x01\n\x0b\n\x03\x04-\x01\x12\x04\x96\x04\x08-\n\x0c\n\x04\x04\
    -\x02\0\x12\x04\x97\x04\x08)\n\r\n\x05\x04-\x02\0\x04\x12\x04\x97\x04\
    \x08\x10\n\r\n\x05\x04-\x02\0\x05\x12\x04\x97\x04\x11\x17\n\r\n\x05\x04-\
    \x02\0\x01\x12\x04\x97\x04\x18$\n\r\n\x05\x04-\x02\0\x03\x12\x04\x97\x04\
    '(\n\x0c\n\x04\x04-\x02\x01\x12\x04\x98\x04\x08.\n\r\n\x05\x04-\x02\x01\
    \x04\x12\x04\x98\x04\x08\x10\n\r\n\x05\x04-\x02\x01\x05\x12\x04\x98\x04\
    \x11\x17\n\r\n\x05\x04-\x02\x01\x01\x12\x04\x98\x04\x18)\n\r\n\x05\x04-\
    \x02\x01\x03\x12\x04\x98\x04,-\n\x0c\n\x04\x04-\x02\x02\x12\x04\x99\x04\
    \x08(\n\r\n\x05\x04-\x02\x02\x04\x12\x04\x99\x04\x08\x10\n\r\n\x05\x04-\
    \x02\x02\x05\x12\x04\x99\x04\x11\x17\n\r\n\x05\x04-\x02\x02\x01\x12\x04\
    \x99\x04\x18#\n\r\n\x05\x04-\x02\x02\x03\x12\x04\x99\x04&'\n\x0c\n\x04\
    \x04-\x02\x03\x12\x04\x9a\x04\x08-\n\r\n\x05\x04-\x02\x03\x04\x12\x04\
    \x9a\x04\x08\x10\n\r\n\x05\x04-\x02\x03\x05\x12\x04\x9a\x04\x11\x17\n\r\
    \n\x05\x04-\x02\x03\x01\x12\x04\x9a\x04\x18(\n\r\n\x05\x04-\x02\x03\x03\
    \x12\x04\x9a\x04+,\n\x0c\n\x04\x04-\x02\x04\x12\x04\x9b\x04\x08/\n\r\n\
    \x05\x04-\x02\x04\x04\x12\x04\x9b\x04\x08\x10\n\r\n\x05\x04-\x02\x04\x05\
    \x12\x04\x9b\x04\x11\x17\n\r\n\x05\x04-\x02\x04\x01\x12\x04\x9b\x04\x18*\
    \n\r\n\x05\x04-\x02\x04\x03\x12\x04\x9b\x04-.\n\x0c\n\x04\x04-\x02\x05\
    \x12\x04\x9c\x04\x08%\n\r\n\x05\x04-\x02\x05\x04\x12\x04\x9c\x04\x08\x10\
    \n\r\n\x05\x04-\x02\x05\x05\x12\x04\x9c\x04\x11\x17\n\r\n\x05\x04-\x02\
    \x05\x01\x12\x04\x9c\x04\x18\x20\n\r\n\x05\x04-\x02\x05\x03\x12\x04\x9c\
    \x04#$\n\x0c\n\x02\x04.\x12\x06\x9f\x04\0\xa6\x04\x01\n\x0b\n\x03\x04.\
    \x01\x12\x04\x9f\x04\x08/\n\x0c\n\x04\x04.\x02\0\x12\x04\xa0\x04\x08,\n\
    \r\n\x05\x04.\x02\0\x04\x12\x04\xa0\x04\x08\x10\n\r\n\x05\x04.\x02\0\x05\
    \x12\x04\xa0\x04\x11\x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\xa0\x04\x18'\n\
    \r\n\x05\x04.\x02\0\x03\x12\x04\xa0\x04*+\n\x0c\n\x04\x04.\x02\x01\x12\
    \x04\xa1\x04\x08'\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xa1\x04\x08\x10\n\r\
    \n\x05\x04.\x02\x01\x05\x12\x04\xa1\x04\x11\x17\n\r\n\x05\x04.\x02\x01\
    \x01\x12\x04\xa1\x04\x18\"\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xa1\x04%&\
    \n\x0c\n\x04\x04.\x02\x02\x12\x04\xa2\x04\x08&\n\r\n\x05\x04.\x02\x02\
    \x04\x12\x04\xa2\x04\x08\x10\n\r\n\x05\x04.\x02\x02\x05\x12\x04\xa2\x04\
    \x11\x17\n\r\n\x05\x04.\x02\x02\x01\x12\x04\xa2\x04\x18!\n\r\n\x05\x04.\
    \x02\x02\x03\x12\x04\xa2\x04$%\n\x0c\n\x04\x04.\x02\x03\x12\x04\xa3\x04\
    \x08*\n\r\n\x05\x04.\x02\x03\x04\x12\x04\xa3\x04\x08\x10\n\r\n\x05\x04.\
    \x02\x03\x05\x12\x04\xa3\x04\x11\x17\n\r\n\x05\x04.\x02\x03\x01\x12\x04\
    \xa3\x04\x18%\n\r\n\x05\x04.\x02\x03\x03\x12\x04\xa3\x04()\n\x0c\n\x04\
    \x04.\x02\x04\x12\x04\xa4\x04\x08,\n\r\n\x05\x04.\x02\x04\x04\x12\x04\
    \xa4\x04\x08\x10\n\r\n\x05\x04.\x02\x04\x05\x12\x04\xa4\x04\x11\x17\n\r\
    \n\x05\x04.\x02\x04\x01\x12\x04\xa4\x04\x18'\n\r\n\x05\x04.\x02\x04\x03\
    \x12\x04\xa4\x04*+\n\x0c\n\x04\x04.\x02\x05\x12\x04\xa5\x04\x08#\n\r\n\
    \x05\x04.\x02\x05\x04\x12\x04\xa5\x04\x08\x10\n\r\n\x05\x04.\x02\x05\x05\
    \x12\x04\xa5\x04\x11\x17\n\r\n\x05\x04.\x02\x05\x01\x12\x04\xa5\x04\x18\
    \x1e\n\r\n\x05\x04.\x02\x05\x03\x12\x04\xa5\x04!\"\n\x0c\n\x02\x04/\x12\
    \x06\xa8\x04\0\xad\x04\x01\n\x0b\n\x03\x04/\x01\x12\x04\xa8\x04\x088\n\
    \x0c\n\x04\x04/\x02\0\x12\x04\xa9\x04\x08'\n\r\n\x05\x04/\x02\0\x04\x12\
    \x04\xa9\x04\x08\x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xa9\x04\x11\x17\n\
    \r\n\x05\x04/\x02\0\x01\x12\x04\xa9\x04\x18\"\n\r\n\x05\x04/\x02\0\x03\
    \x12\x04\xa9\x04%&\n\x0c\n\x04\x04/\x02\x01\x12\x04\xaa\x04\x08(\n\r\n\
    \x05\x04/\x02\x01\x04\x12\x04\xaa\x04\x08\x10\n\r\n\x05\x04/\x02\x01\x05\
    \x12\x04\xaa\x04\x11\x17\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xaa\x04\x18#\
    \n\r\n\x05\x04/\x02\x01\x03\x12\x04\xaa\x04&'\n\x0c\n\x04\x04/\x02\x02\
    \x12\x04\xab\x04\x08%\n\r\n\x05\x04/\x02\x02\x04\x12\x04\xab\x04\x08\x10\
    \n\r\n\x05\x04/\x02\x02\x05\x12\x04\xab\x04\x11\x17\n\r\n\x05\x04/\x02\
    \x02\x01\x12\x04\xab\x04\x18\x20\n\r\n\x05\x04/\x02\x02\x03\x12\x04\xab\
    \x04#$\n\x0c\n\x04\x04/\x02\x03\x12\x04\xac\x04\x08$\n\r\n\x05\x04/\x02\
    \x03\x04\x12\x04\xac\x04\x08\x10\n\r\n\x05\x04/\x02\x03\x05\x12\x04\xac\
    \x04\x11\x17\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xac\x04\x18\x1f\n\r\n\
    \x05\x04/\x02\x03\x03\x12\x04\xac\x04\"#\n\x0c\n\x02\x040\x12\x06\xaf\
    \x04\0\xbd\x04\x01\n\x0b\n\x03\x040\x01\x12\x04\xaf\x04\x08\x1a\n\x0c\n\
    \x04\x040\x02\0\x12\x04\xb0\x04\x08&\n\r\n\x05\x040\x02\0\x04\x12\x04\
    \xb0\x04\x08\x10\n\r\n\x05\x040\x02\0\x05\x12\x04\xb0\x04\x11\x17\n\r\n\
    \x05\x040\x02\0\x01\x12\x04\xb0\x04\x18!\n\r\n\x05\x040\x02\0\x03\x12\
    \x04\xb0\x04$%\n\x0c\n\x04\x040\x02\x01\x12\x04\xb1\x04\x08$\n\r\n\x05\
    \x040\x02\x01\x04\x12\x04\xb1\x04\x08\x10\n\r\n\x05\x040\x02\x01\x05\x12\
    \x04\xb1\x04\x11\x17\n\r\n\x05\x040\x02\x01\x01\x12\x04\xb1\x04\x18\x1f\
    \n\r\n\x05\x040\x02\x01\x03\x12\x04\xb1\x04\"#\n\x0c\n\x04\x040\x02\x02\
    \x12\x04\xb2\x04\x08*\n\r\n\x05\x040\x02\x02\x04\x12\x04\xb2\x04\x08\x10\
    \n\r\n\x05\x040\x02\x02\x05\x12\x04\xb2\x04\x11\x17\n\r\n\x05\x040\x02\
    \x02\x01\x12\x04\xb2\x04\x18%\n\r\n\x05\x040\x02\x02\x03\x12\x04\xb2\x04\
    ()\n\x0c\n\x04\x040\x02\x03\x12\x04\xb3\x04\x08$\n\r\n\x05\x040\x02\x03\
    \x04\x12\x04\xb3\x04\x08\x10\n\r\n\x05\x040\x02\x03\x05\x12\x04\xb3\x04\
    \x11\x17\n\r\n\x05\x040\x02\x03\x01\x12\x04\xb3\x04\x18\x1f\n\r\n\x05\
    \x040\x02\x03\x03\x12\x04\xb3\x04\"#\n\x0c\n\x04\x040\x02\x04\x12\x04\
    \xb4\x04\x08-\n\r\n\x05\x040\x02\x04\x04\x12\x04\xb4\x04\x08\x10\n\r\n\
    \x05\x040\x02\x04\x05\x12\x04\xb4\x04\x11\x16\n\r\n\x05\x040\x02\x04\x01\
    \x12\x04\xb4\x04\x17(\n\r\n\x05\x040\x02\x04\x03\x12\x04\xb4\x04+,\n\x0c\
    \n\x04\x040\x02\x05\x12\x04\xb5\x04\x08/\n\r\n\x05\x040\x02\x05\x04\x12\
    \x04\xb5\x04\x08\x10\n\r\n\x05\x040\x02\x05\x05\x12\x04\xb5\x04\x11\x17\
    \n\r\n\x05\x040\x02\x05\x01\x12\x04\xb5\x04\x18*\n\r\n\x05\x040\x02\x05\
    \x03\x12\x04\xb5\x04-.\n\x0c\n\x04\x040\x02\x06\x12\x04\xb6\x04\x083\n\r\
    \n\x05\x040\x02\x06\x04\x12\x04\xb6\x04\x08\x10\n\r\n\x05\x040\x02\x06\
    \x05\x12\x04\xb6\x04\x11\x17\n\r\n\x05\x040\x02\x06\x01\x12\x04\xb6\x04\
    \x18.\n\r\n\x05\x040\x02\x06\x03\x12\x04\xb6\x0412\n\x0c\n\x04\x040\x02\
    \x07\x12\x04\xb7\x04\x08&\n\r\n\x05\x040\x02\x07\x04\x12\x04\xb7\x04\x08\
    \x10\n\r\n\x05\x040\x02\x07\x05\x12\x04\xb7\x04\x11\x17\n\r\n\x05\x040\
    \x02\x07\x01\x12\x04\xb7\x04\x18!\n\r\n\x05\x040\x02\x07\x03\x12\x04\xb7\
    \x04$%\n\x0c\n\x04\x040\x02\x08\x12\x04\xb8\x04\x08*\n\r\n\x05\x040\x02\
    \x08\x04\x12\x04\xb8\x04\x08\x10\n\r\n\x05\x040\x02\x08\x05\x12\x04\xb8\
    \x04\x11\x17\n\r\n\x05\x040\x02\x08\x01\x12\x04\xb8\x04\x18%\n\r\n\x05\
    \x040\x02\x08\x03\x12\x04\xb8\x04()\n\x0c\n\x04\x040\x02\t\x12\x04\xb9\
    \x04\x08&\n\r\n\x05\x040\x02\t\x04\x12\x04\xb9\x04\x08\x10\n\r\n\x05\x04\
    0\x02\t\x05\x12\x04\xb9\x04\x11\x17\n\r\n\x05\x040\x02\t\x01\x12\x04\xb9\
    \x04\x18\x20\n\r\n\x05\x040\x02\t\x03\x12\x04\xb9\x04#%\n\x0c\n\x04\x040\
    \x02\n\x12\x04\xba\x04\x08'\n\r\n\x05\x040\x02\n\x04\x12\x04\xba\x04\x08\
    \x10\n\r\n\x05\x040\x02\n\x05\x12\x04\xba\x04\x11\x17\n\r\n\x05\x040\x02\
    \n\x01\x12\x04\xba\x04\x18!\n\r\n\x05\x040\x02\n\x03\x12\x04\xba\x04$&\n\
    \x0c\n\x04\x040\x02\x0b\x12\x04\xbb\x04\x08&\n\r\n\x05\x040\x02\x0b\x04\
    \x12\x04\xbb\x04\x08\x10\n\r\n\x05\x040\x02\x0b\x05\x12\x04\xbb\x04\x11\
    \x17\n\r\n\x05\x040\x02\x0b\x01\x12\x04\xbb\x04\x18\x20\n\r\n\x05\x040\
    \x02\x0b\x03\x12\x04\xbb\x04#%\n\x0c\n\x04\x040\x02\x0c\x12\x04\xbc\x04\
    \x08,\n\r\n\x05\x040\x02\x0c\x04\x12\x04\xbc\x04\x08\x10\n\r\n\x05\x040\
    \x02\x0c\x05\x12\x04\xbc\x04\x11\x17\n\r\n\x05\x040\x02\x0c\x01\x12\x04\
    \xbc\x04\x18&\n\r\n\x05\x040\x02\x0c\x03\x12\x04\xbc\x04)+\n\x0c\n\x02\
    \x041\x12\x06\xbf\x04\0\xc6\x04\x01\n\x0b\n\x03\x041\x01\x12\x04\xbf\x04\
    \x086\n\x0c\n\x04\x041\x02\0\x12\x04\xc0\x04\x08$\n\r\n\x05\x041\x02\0\
    \x04\x12\x04\xc0\x04\x08\x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xc0\x04\
    \x11\x17\n\r\n\x05\x041\x02\0\x01\x12\x04\xc0\x04\x18\x1f\n\r\n\x05\x041\
    \x02\0\x03\x12\x04\xc0\x04\"#\n\x0c\n\x04\x041\x02\x01\x12\x04\xc1\x04\
    \x08'\n\r\n\x05\x041\x02\x01\x04\x12\x04\xc1\x04\x08\x10\n\r\n\x05\x041\
    \x02\x01\x05\x12\x04\xc1\x04\x11\x17\n\r\n\x05\x041\x02\x01\x01\x12\x04\
    \xc1\x04\x18\"\n\r\n\x05\x041\x02\x01\x03\x12\x04\xc1\x04%&\n\x0c\n\x04\
    \x041\x02\x02\x12\x04\xc2\x04\x08'\n\r\n\x05\x041\x02\x02\x04\x12\x04\
    \xc2\x04\x08\x10\n\r\n\x05\x041\x02\x02\x05\x12\x04\xc2\x04\x11\x17\n\r\
    \n\x05\x041\x02\x02\x01\x12\x04\xc2\x04\x18\"\n\r\n\x05\x041\x02\x02\x03\
    \x12\x04\xc2\x04%&\n\x0c\n\x04\x041\x02\x03\x12\x04\xc3\x04\x08%\n\r\n\
    \x05\x041\x02\x03\x04\x12\x04\xc3\x04\x08\x10\n\r\n\x05\x041\x02\x03\x05\
    \x12\x04\xc3\x04\x11\x17\n\r\n\x05\x041\x02\x03\x01\x12\x04\xc3\x04\x18\
    \x20\n\r\n\x05\x041\x02\x03\x03\x12\x04\xc3\x04#$\n\x0c\n\x04\x041\x02\
    \x04\x12\x04\xc4\x04\x08I\n\r\n\x05\x041\x02\x04\x04\x12\x04\xc4\x04\x08\
    \x10\n\r\n\x05\x041\x02\x04\x06\x12\x04\xc4\x04\x11@\n\r\n\x05\x041\x02\
    \x04\x01\x12\x04\xc4\x04AD\n\r\n\x05\x041\x02\x04\x03\x12\x04\xc4\x04GH\
    \n\x0c\n\x04\x041\x02\x05\x12\x04\xc5\x04\x08%\n\r\n\x05\x041\x02\x05\
    \x04\x12\x04\xc5\x04\x08\x10\n\r\n\x05\x041\x02\x05\x05\x12\x04\xc5\x04\
    \x11\x17\n\r\n\x05\x041\x02\x05\x01\x12\x04\xc5\x04\x18\x20\n\r\n\x05\
    \x041\x02\x05\x03\x12\x04\xc5\x04#$\n\x0c\n\x02\x042\x12\x06\xc8\x04\0\
    \xcf\x04\x01\n\x0b\n\x03\x042\x01\x12\x04\xc8\x04\x086\n\x0c\n\x04\x042\
    \x02\0\x12\x04\xc9\x04\x08$\n\r\n\x05\x042\x02\0\x04\x12\x04\xc9\x04\x08\
    \x10\n\r\n\x05\x042\x02\0\x05\x12\x04\xc9\x04\x11\x17\n\r\n\x05\x042\x02\
    \0\x01\x12\x04\xc9\x04\x18\x1f\n\r\n\x05\x042\x02\0\x03\x12\x04\xc9\x04\
    \"#\n\x0c\n\x04\x042\x02\x01\x12\x04\xca\x04\x08'\n\r\n\x05\x042\x02\x01\
    \x04\x12\x04\xca\x04\x08\x10\n\r\n\x05\x042\x02\x01\x05\x12\x04\xca\x04\
    \x11\x17\n\r\n\x05\x042\x02\x01\x01\x12\x04\xca\x04\x18\"\n\r\n\x05\x042\
    \x02\x01\x03\x12\x04\xca\x04%&\n\x0c\n\x04\x042\x02\x02\x12\x04\xcb\x04\
    \x08%\n\r\n\x05\x042\x02\x02\x04\x12\x04\xcb\x04\x08\x10\n\r\n\x05\x042\
    \x02\x02\x05\x12\x04\xcb\x04\x11\x17\n\r\n\x05\x042\x02\x02\x01\x12\x04\
    \xcb\x04\x18\x20\n\r\n\x05\x042\x02\x02\x03\x12\x04\xcb\x04#$\n\x0c\n\
    \x04\x042\x02\x03\x12\x04\xcc\x04\x08&\n\r\n\x05\x042\x02\x03\x04\x12\
    \x04\xcc\x04\x08\x10\n\r\n\x05\x042\x02\x03\x05\x12\x04\xcc\x04\x11\x17\
    \n\r\n\x05\x042\x02\x03\x01\x12\x04\xcc\x04\x18!\n\r\n\x05\x042\x02\x03\
    \x03\x12\x04\xcc\x04$%\n\x0c\n\x04\x042\x02\x04\x12\x04\xcd\x04\x08(\n\r\
    \n\x05\x042\x02\x04\x04\x12\x04\xcd\x04\x08\x10\n\r\n\x05\x042\x02\x04\
    \x05\x12\x04\xcd\x04\x11\x17\n\r\n\x05\x042\x02\x04\x01\x12\x04\xcd\x04\
    \x18#\n\r\n\x05\x042\x02\x04\x03\x12\x04\xcd\x04&'\n\x0c\n\x04\x042\x02\
    \x05\x12\x04\xce\x04\x08I\n\r\n\x05\x042\x02\x05\x04\x12\x04\xce\x04\x08\
    \x10\n\r\n\x05\x042\x02\x05\x06\x12\x04\xce\x04\x11@\n\r\n\x05\x042\x02\
    \x05\x01\x12\x04\xce\x04AD\n\r\n\x05\x042\x02\x05\x03\x12\x04\xce\x04GH\
    \n\x0c\n\x02\x043\x12\x06\xd1\x04\0\xd4\x04\x01\n\x0b\n\x03\x043\x01\x12\
    \x04\xd1\x04\x082\n\x0c\n\x04\x043\x02\0\x12\x04\xd2\x04\x08'\n\r\n\x05\
    \x043\x02\0\x04\x12\x04\xd2\x04\x08\x10\n\r\n\x05\x043\x02\0\x05\x12\x04\
    \xd2\x04\x11\x17\n\r\n\x05\x043\x02\0\x01\x12\x04\xd2\x04\x18\"\n\r\n\
    \x05\x043\x02\0\x03\x12\x04\xd2\x04%&\n\x0c\n\x04\x043\x02\x01\x12\x04\
    \xd3\x04\x08(\n\r\n\x05\x043\x02\x01\x04\x12\x04\xd3\x04\x08\x10\n\r\n\
    \x05\x043\x02\x01\x05\x12\x04\xd3\x04\x11\x17\n\r\n\x05\x043\x02\x01\x01\
    \x12\x04\xd3\x04\x18#\n\r\n\x05\x043\x02\x01\x03\x12\x04\xd3\x04&'\n\x0c\
    \n\x02\x044\x12\x06\xd6\x04\0\xdc\x04\x01\n\x0b\n\x03\x044\x01\x12\x04\
    \xd6\x04\x084\n\x0c\n\x04\x044\x02\0\x12\x04\xd7\x04\x086\n\r\n\x05\x044\
    \x02\0\x04\x12\x04\xd7\x04\x08\x10\n\r\n\x05\x044\x02\0\x06\x12\x04\xd7\
    \x04\x11\x20\n\r\n\x05\x044\x02\0\x01\x12\x04\xd7\x04!1\n\r\n\x05\x044\
    \x02\0\x03\x12\x04\xd7\x0445\n\x0c\n\x04\x044\x02\x01\x12\x04\xd8\x04\
    \x08'\n\r\n\x05\x044\x02\x01\x04\x12\x04\xd8\x04\x08\x10\n\r\n\x05\x044\
    \x02\x01\x05\x12\x04\xd8\x04\x11\x17\n\r\n\x05\x044\x02\x01\x01\x12\x04\
    \xd8\x04\x18\"\n\r\n\x05\x044\x02\x01\x03\x12\x04\xd8\x04%&\n\x0c\n\x04\
    \x044\x02\x02\x12\x04\xd9\x04\x08'\n\r\n\x05\x044\x02\x02\x04\x12\x04\
    \xd9\x04\x08\x10\n\r\n\x05\x044\x02\x02\x05\x12\x04\xd9\x04\x11\x17\n\r\
    \n\x05\x044\x02\x02\x01\x12\x04\xd9\x04\x18\"\n\r\n\x05\x044\x02\x02\x03\
    \x12\x04\xd9\x04%&\n\x0c\n\x04\x044\x02\x03\x12\x04\xda\x04\x08*\n\r\n\
    \x05\x044\x02\x03\x04\x12\x04\xda\x04\x08\x10\n\r\n\x05\x044\x02\x03\x05\
    \x12\x04\xda\x04\x11\x17\n\r\n\x05\x044\x02\x03\x01\x12\x04\xda\x04\x18%\
    \n\r\n\x05\x044\x02\x03\x03\x12\x04\xda\x04()\n\x0c\n\x04\x044\x02\x04\
    \x12\x04\xdb\x04\x08,\n\r\n\x05\x044\x02\x04\x04\x12\x04\xdb\x04\x08\x10\
    \n\r\n\x05\x044\x02\x04\x05\x12\x04\xdb\x04\x11\x17\n\r\n\x05\x044\x02\
    \x04\x01\x12\x04\xdb\x04\x18'\n\r\n\x05\x044\x02\x04\x03\x12\x04\xdb\x04\
    *+\n\x0c\n\x02\x045\x12\x06\xde\x04\0\xe3\x04\x01\n\x0b\n\x03\x045\x01\
    \x12\x04\xde\x04\x08)\n\x0c\n\x04\x045\x02\0\x12\x04\xdf\x04\x08'\n\r\n\
    \x05\x045\x02\0\x04\x12\x04\xdf\x04\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\
    \x04\xdf\x04\x11\x17\n\r\n\x05\x045\x02\0\x01\x12\x04\xdf\x04\x18\"\n\r\
    \n\x05\x045\x02\0\x03\x12\x04\xdf\x04%&\n\x0c\n\x04\x045\x02\x01\x12\x04\
    \xe0\x04\x08(\n\r\n\x05\x045\x02\x01\x04\x12\x04\xe0\x04\x08\x10\n\r\n\
    \x05\x045\x02\x01\x05\x12\x04\xe0\x04\x11\x17\n\r\n\x05\x045\x02\x01\x01\
    \x12\x04\xe0\x04\x18#\n\r\n\x05\x045\x02\x01\x03\x12\x04\xe0\x04&'\n\x0c\
    \n\x04\x045\x02\x02\x12\x04\xe1\x04\x08?\n\r\n\x05\x045\x02\x02\x04\x12\
    \x04\xe1\x04\x08\x10\n\r\n\x05\x045\x02\x02\x06\x12\x04\xe1\x04\x11$\n\r\
    \n\x05\x045\x02\x02\x01\x12\x04\xe1\x04%:\n\r\n\x05\x045\x02\x02\x03\x12\
    \x04\xe1\x04=>\n\x0c\n\x04\x045\x02\x03\x12\x04\xe2\x04\x08-\n\r\n\x05\
    \x045\x02\x03\x04\x12\x04\xe2\x04\x08\x10\n\r\n\x05\x045\x02\x03\x05\x12\
    \x04\xe2\x04\x11\x17\n\r\n\x05\x045\x02\x03\x01\x12\x04\xe2\x04\x18(\n\r\
    \n\x05\x045\x02\x03\x03\x12\x04\xe2\x04+,\n\x0c\n\x02\x046\x12\x06\xe5\
    \x04\0\xea\x04\x01\n\x0b\n\x03\x046\x01\x12\x04\xe5\x04\x086\n\x0c\n\x04\
    \x046\x02\0\x12\x04\xe6\x04\x083\n\r\n\x05\x046\x02\0\x04\x12\x04\xe6\
    \x04\x08\x10\n\r\n\x05\x046\x02\0\x05\x12\x04\xe6\x04\x11\x17\n\r\n\x05\
    \x046\x02\0\x01\x12\x04\xe6\x04\x18.\n\r\n\x05\x046\x02\0\x03\x12\x04\
    \xe6\x0412\n\x0c\n\x04\x046\x02\x01\x12\x04\xe7\x04\x084\n\r\n\x05\x046\
    \x02\x01\x04\x12\x04\xe7\x04\x08\x10\n\r\n\x05\x046\x02\x01\x05\x12\x04\
    \xe7\x04\x11\x17\n\r\n\x05\x046\x02\x01\x01\x12\x04\xe7\x04\x18/\n\r\n\
    \x05\x046\x02\x01\x03\x12\x04\xe7\x0423\n\x0c\n\x04\x046\x02\x02\x12\x04\
    \xe8\x04\x08'\n\r\n\x05\x046\x02\x02\x04\x12\x04\xe8\x04\x08\x10\n\r\n\
    \x05\x046\x02\x02\x05\x12\x04\xe8\x04\x11\x17\n\r\n\x05\x046\x02\x02\x01\
    \x12\x04\xe8\x04\x18\"\n\r\n\x05\x046\x02\x02\x03\x12\x04\xe8\x04%&\n\
    \x0c\n\x04\x046\x02\x03\x12\x04\xe9\x04\x08*\n\r\n\x05\x046\x02\x03\x04\
    \x12\x04\xe9\x04\x08\x10\n\r\n\x05\x046\x02\x03\x05\x12\x04\xe9\x04\x11\
    \x17\n\r\n\x05\x046\x02\x03\x01\x12\x04\xe9\x04\x18%\n\r\n\x05\x046\x02\
    \x03\x03\x12\x04\xe9\x04()\n\x0c\n\x02\x047\x12\x06\xec\x04\0\xef\x04\
    \x01\n\x0b\n\x03\x047\x01\x12\x04\xec\x04\x08)\n\x0c\n\x04\x047\x02\0\
    \x12\x04\xed\x04\x08'\n\r\n\x05\x047\x02\0\x04\x12\x04\xed\x04\x08\x10\n\
    \r\n\x05\x047\x02\0\x05\x12\x04\xed\x04\x11\x17\n\r\n\x05\x047\x02\0\x01\
    \x12\x04\xed\x04\x18\"\n\r\n\x05\x047\x02\0\x03\x12\x04\xed\x04%&\n\x0c\
    \n\x04\x047\x02\x01\x12\x04\xee\x04\x08T\n\r\n\x05\x047\x02\x01\x04\x12\
    \x04\xee\x04\x08\x10\n\r\n\x05\x047\x02\x01\x06\x12\x04\xee\x04\x11>\n\r\
    \n\x05\x047\x02\x01\x01\x12\x04\xee\x04?O\n\r\n\x05\x047\x02\x01\x03\x12\
    \x04\xee\x04RS\n\x0c\n\x02\x048\x12\x06\xf1\x04\0\xfa\x04\x01\n\x0b\n\
    \x03\x048\x01\x12\x04\xf1\x04\x084\n\x0c\n\x04\x048\x02\0\x12\x04\xf2\
    \x04\x08#\n\r\n\x05\x048\x02\0\x04\x12\x04\xf2\x04\x08\x10\n\r\n\x05\x04\
    8\x02\0\x05\x12\x04\xf2\x04\x11\x17\n\r\n\x05\x048\x02\0\x01\x12\x04\xf2\
    \x04\x18\x1e\n\r\n\x05\x048\x02\0\x03\x12\x04\xf2\x04!\"\n\x0c\n\x04\x04\
    8\x02\x01\x12\x04\xf3\x04\x08&\n\r\n\x05\x048\x02\x01\x04\x12\x04\xf3\
    \x04\x08\x10\n\r\n\x05\x048\x02\x01\x05\x12\x04\xf3\x04\x11\x17\n\r\n\
    \x05\x048\x02\x01\x01\x12\x04\xf3\x04\x18!\n\r\n\x05\x048\x02\x01\x03\
    \x12\x04\xf3\x04$%\n\x0c\n\x04\x048\x02\x02\x12\x04\xf4\x04\x08'\n\r\n\
    \x05\x048\x02\x02\x04\x12\x04\xf4\x04\x08\x10\n\r\n\x05\x048\x02\x02\x05\
    \x12\x04\xf4\x04\x11\x17\n\r\n\x05\x048\x02\x02\x01\x12\x04\xf4\x04\x18\
    \"\n\r\n\x05\x048\x02\x02\x03\x12\x04\xf4\x04%&\n\x0c\n\x04\x048\x02\x03\
    \x12\x04\xf5\x04\x08'\n\r\n\x05\x048\x02\x03\x04\x12\x04\xf5\x04\x08\x10\
    \n\r\n\x05\x048\x02\x03\x05\x12\x04\xf5\x04\x11\x17\n\r\n\x05\x048\x02\
    \x03\x01\x12\x04\xf5\x04\x18\"\n\r\n\x05\x048\x02\x03\x03\x12\x04\xf5\
    \x04%&\n\x0c\n\x04\x048\x02\x04\x12\x04\xf6\x04\x08)\n\r\n\x05\x048\x02\
    \x04\x04\x12\x04\xf6\x04\x08\x10\n\r\n\x05\x048\x02\x04\x05\x12\x04\xf6\
    \x04\x11\x17\n\r\n\x05\x048\x02\x04\x01\x12\x04\xf6\x04\x18$\n\r\n\x05\
    \x048\x02\x04\x03\x12\x04\xf6\x04'(\n\x0c\n\x04\x048\x02\x05\x12\x04\xf7\
    \x04\x08*\n\r\n\x05\x048\x02\x05\x04\x12\x04\xf7\x04\x08\x10\n\r\n\x05\
    \x048\x02\x05\x05\x12\x04\xf7\x04\x11\x17\n\r\n\x05\x048\x02\x05\x01\x12\
    \x04\xf7\x04\x18%\n\r\n\x05\x048\x02\x05\x03\x12\x04\xf7\x04()\n\x0c\n\
    \x04\x048\x02\x06\x12\x04\xf8\x04\x08)\n\r\n\x05\x048\x02\x06\x04\x12\
    \x04\xf8\x04\x08\x10\n\r\n\x05\x048\x02\x06\x05\x12\x04\xf8\x04\x11\x17\
    \n\r\n\x05\x048\x02\x06\x01\x12\x04\xf8\x04\x18$\n\r\n\x05\x048\x02\x06\
    \x03\x12\x04\xf8\x04'(\n\x0c\n\x04\x048\x02\x07\x12\x04\xf9\x04\x08#\n\r\
    \n\x05\x048\x02\x07\x04\x12\x04\xf9\x04\x08\x10\n\r\n\x05\x048\x02\x07\
    \x05\x12\x04\xf9\x04\x11\x17\n\r\n\x05\x048\x02\x07\x01\x12\x04\xf9\x04\
    \x18\x1e\n\r\n\x05\x048\x02\x07\x03\x12\x04\xf9\x04!\"\n\x0c\n\x02\x049\
    \x12\x06\xfc\x04\0\x88\x05\x01\n\x0b\n\x03\x049\x01\x12\x04\xfc\x04\x088\
    \n\x0c\n\x04\x049\x02\0\x12\x04\xfd\x04\x08#\n\r\n\x05\x049\x02\0\x04\
    \x12\x04\xfd\x04\x08\x10\n\r\n\x05\x049\x02\0\x05\x12\x04\xfd\x04\x11\
    \x17\n\r\n\x05\x049\x02\0\x01\x12\x04\xfd\x04\x18\x1e\n\r\n\x05\x049\x02\
    \0\x03\x12\x04\xfd\x04!\"\n\x0c\n\x04\x049\x02\x01\x12\x04\xfe\x04\x08$\
    \n\r\n\x05\x049\x02\x01\x04\x12\x04\xfe\x04\x08\x10\n\r\n\x05\x049\x02\
    \x01\x05\x12\x04\xfe\x04\x11\x17\n\r\n\x05\x049\x02\x01\x01\x12\x04\xfe\
    \x04\x18\x1f\n\r\n\x05\x049\x02\x01\x03\x12\x04\xfe\x04\"#\n\x0c\n\x04\
    \x049\x02\x02\x12\x04\xff\x04\x08$\n\r\n\x05\x049\x02\x02\x04\x12\x04\
    \xff\x04\x08\x10\n\r\n\x05\x049\x02\x02\x05\x12\x04\xff\x04\x11\x17\n\r\
    \n\x05\x049\x02\x02\x01\x12\x04\xff\x04\x18\x1f\n\r\n\x05\x049\x02\x02\
    \x03\x12\x04\xff\x04\"#\n\x0c\n\x04\x049\x02\x03\x12\x04\x80\x05\x08&\n\
    \r\n\x05\x049\x02\x03\x04\x12\x04\x80\x05\x08\x10\n\r\n\x05\x049\x02\x03\
    \x05\x12\x04\x80\x05\x11\x17\n\r\n\x05\x049\x02\x03\x01\x12\x04\x80\x05\
    \x18!\n\r\n\x05\x049\x02\x03\x03\x12\x04\x80\x05$%\n\x0c\n\x04\x049\x02\
    \x04\x12\x04\x81\x05\x08,\n\r\n\x05\x049\x02\x04\x04\x12\x04\x81\x05\x08\
    \x10\n\r\n\x05\x049\x02\x04\x05\x12\x04\x81\x05\x11\x17\n\r\n\x05\x049\
    \x02\x04\x01\x12\x04\x81\x05\x18'\n\r\n\x05\x049\x02\x04\x03\x12\x04\x81\
    \x05*+\n\x0c\n\x04\x049\x02\x05\x12\x04\x82\x05\x08&\n\r\n\x05\x049\x02\
    \x05\x04\x12\x04\x82\x05\x08\x10\n\r\n\x05\x049\x02\x05\x05\x12\x04\x82\
    \x05\x11\x17\n\r\n\x05\x049\x02\x05\x01\x12\x04\x82\x05\x18!\n\r\n\x05\
    \x049\x02\x05\x03\x12\x04\x82\x05$%\n\x0c\n\x04\x049\x02\x06\x12\x04\x83\
    \x05\x08'\n\r\n\x05\x049\x02\x06\x04\x12\x04\x83\x05\x08\x10\n\r\n\x05\
    \x049\x02\x06\x05\x12\x04\x83\x05\x11\x17\n\r\n\x05\x049\x02\x06\x01\x12\
    \x04\x83\x05\x18\"\n\r\n\x05\x049\x02\x06\x03\x12\x04\x83\x05%&\n\x0c\n\
    \x04\x049\x02\x07\x12\x04\x84\x05\x08&\n\r\n\x05\x049\x02\x07\x04\x12\
    \x04\x84\x05\x08\x10\n\r\n\x05\x049\x02\x07\x05\x12\x04\x84\x05\x11\x17\
    \n\r\n\x05\x049\x02\x07\x01\x12\x04\x84\x05\x18!\n\r\n\x05\x049\x02\x07\
    \x03\x12\x04\x84\x05$%\n\x0c\n\x04\x049\x02\x08\x12\x04\x85\x05\x08+\n\r\
    \n\x05\x049\x02\x08\x04\x12\x04\x85\x05\x08\x10\n\r\n\x05\x049\x02\x08\
    \x05\x12\x04\x85\x05\x11\x17\n\r\n\x05\x049\x02\x08\x01\x12\x04\x85\x05\
    \x18&\n\r\n\x05\x049\x02\x08\x03\x12\x04\x85\x05)*\n\x0c\n\x04\x049\x02\
    \t\x12\x04\x86\x05\x08.\n\r\n\x05\x049\x02\t\x04\x12\x04\x86\x05\x08\x10\
    \n\r\n\x05\x049\x02\t\x05\x12\x04\x86\x05\x11\x16\n\r\n\x05\x049\x02\t\
    \x01\x12\x04\x86\x05\x17(\n\r\n\x05\x049\x02\t\x03\x12\x04\x86\x05+-\n\
    \x0c\n\x04\x049\x02\n\x12\x04\x87\x05\x08$\n\r\n\x05\x049\x02\n\x04\x12\
    \x04\x87\x05\x08\x10\n\r\n\x05\x049\x02\n\x05\x12\x04\x87\x05\x11\x17\n\
    \r\n\x05\x049\x02\n\x01\x12\x04\x87\x05\x18\x1e\n\r\n\x05\x049\x02\n\x03\
    \x12\x04\x87\x05!#\n\x0c\n\x02\x04:\x12\x06\x8a\x05\0\x8d\x05\x01\n\x0b\
    \n\x03\x04:\x01\x12\x04\x8a\x05\x084\n\x0c\n\x04\x04:\x02\0\x12\x04\x8b\
    \x05\x08#\n\r\n\x05\x04:\x02\0\x04\x12\x04\x8b\x05\x08\x10\n\r\n\x05\x04\
    :\x02\0\x05\x12\x04\x8b\x05\x11\x17\n\r\n\x05\x04:\x02\0\x01\x12\x04\x8b\
    \x05\x18\x1e\n\r\n\x05\x04:\x02\0\x03\x12\x04\x8b\x05!\"\n\x0c\n\x04\x04\
    :\x02\x01\x12\x04\x8c\x05\x08%\n\r\n\x05\x04:\x02\x01\x04\x12\x04\x8c\
    \x05\x08\x10\n\r\n\x05\x04:\x02\x01\x05\x12\x04\x8c\x05\x11\x17\n\r\n\
    \x05\x04:\x02\x01\x01\x12\x04\x8c\x05\x18\x20\n\r\n\x05\x04:\x02\x01\x03\
    \x12\x04\x8c\x05#$\n\x0c\n\x02\x04;\x12\x06\x8f\x05\0\x92\x05\x01\n\x0b\
    \n\x03\x04;\x01\x12\x04\x8f\x05\x08&\n\x0c\n\x04\x04;\x02\0\x12\x04\x90\
    \x05\x08&\n\r\n\x05\x04;\x02\0\x04\x12\x04\x90\x05\x08\x10\n\r\n\x05\x04\
    ;\x02\0\x05\x12\x04\x90\x05\x11\x17\n\r\n\x05\x04;\x02\0\x01\x12\x04\x90\
    \x05\x18!\n\r\n\x05\x04;\x02\0\x03\x12\x04\x90\x05$%\n\x0c\n\x04\x04;\
    \x02\x01\x12\x04\x91\x05\x08#\n\r\n\x05\x04;\x02\x01\x04\x12\x04\x91\x05\
    \x08\x10\n\r\n\x05\x04;\x02\x01\x05\x12\x04\x91\x05\x11\x17\n\r\n\x05\
    \x04;\x02\x01\x01\x12\x04\x91\x05\x18\x1e\n\r\n\x05\x04;\x02\x01\x03\x12\
    \x04\x91\x05!\"\n\x0c\n\x02\x04<\x12\x06\x94\x05\0\x98\x05\x01\n\x0b\n\
    \x03\x04<\x01\x12\x04\x94\x05\x08+\n\x0c\n\x04\x04<\x02\0\x12\x04\x95\
    \x05\x08\x1f\n\r\n\x05\x04<\x02\0\x04\x12\x04\x95\x05\x08\x10\n\r\n\x05\
    \x04<\x02\0\x05\x12\x04\x95\x05\x11\x17\n\r\n\x05\x04<\x02\0\x01\x12\x04\
    \x95\x05\x18\x1a\n\r\n\x05\x04<\x02\0\x03\x12\x04\x95\x05\x1d\x1e\n\x0c\
    \n\x04\x04<\x02\x01\x12\x04\x96\x05\x08!\n\r\n\x05\x04<\x02\x01\x04\x12\
    \x04\x96\x05\x08\x10\n\r\n\x05\x04<\x02\x01\x05\x12\x04\x96\x05\x11\x17\
    \n\r\n\x05\x04<\x02\x01\x01\x12\x04\x96\x05\x18\x1c\n\r\n\x05\x04<\x02\
    \x01\x03\x12\x04\x96\x05\x1f\x20\n\x0c\n\x04\x04<\x02\x02\x12\x04\x97\
    \x05\x08#\n\r\n\x05\x04<\x02\x02\x04\x12\x04\x97\x05\x08\x10\n\r\n\x05\
    \x04<\x02\x02\x05\x12\x04\x97\x05\x11\x16\n\r\n\x05\x04<\x02\x02\x01\x12\
    \x04\x97\x05\x17\x1e\n\r\n\x05\x04<\x02\x02\x03\x12\x04\x97\x05!\"\n\x0c\
    \n\x02\x04=\x12\x06\x9a\x05\0\x9d\x05\x01\n\x0b\n\x03\x04=\x01\x12\x04\
    \x9a\x05\x08+\n\x0c\n\x04\x04=\x02\0\x12\x04\x9b\x05\x08\x1f\n\r\n\x05\
    \x04=\x02\0\x04\x12\x04\x9b\x05\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\x04\
    \x9b\x05\x11\x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\x9b\x05\x18\x1a\n\r\n\
    \x05\x04=\x02\0\x03\x12\x04\x9b\x05\x1d\x1e\n\x0c\n\x04\x04=\x02\x01\x12\
    \x04\x9c\x05\x08\x20\n\r\n\x05\x04=\x02\x01\x04\x12\x04\x9c\x05\x08\x10\
    \n\r\n\x05\x04=\x02\x01\x05\x12\x04\x9c\x05\x11\x16\n\r\n\x05\x04=\x02\
    \x01\x01\x12\x04\x9c\x05\x17\x1b\n\r\n\x05\x04=\x02\x01\x03\x12\x04\x9c\
    \x05\x1e\x1f\n\x0c\n\x02\x04>\x12\x06\x9f\x05\0\xa2\x05\x01\n\x0b\n\x03\
    \x04>\x01\x12\x04\x9f\x05\x081\n\x0c\n\x04\x04>\x02\0\x12\x04\xa0\x05\
    \x08Y\n\r\n\x05\x04>\x02\0\x04\x12\x04\xa0\x05\x08\x10\n\r\n\x05\x04>\
    \x02\0\x06\x12\x04\xa0\x05\x11I\n\r\n\x05\x04>\x02\0\x01\x12\x04\xa0\x05\
    JT\n\r\n\x05\x04>\x02\0\x03\x12\x04\xa0\x05WX\n\x0c\n\x04\x04>\x02\x01\
    \x12\x04\xa1\x05\x08H\n\r\n\x05\x04>\x02\x01\x04\x12\x04\xa1\x05\x08\x10\
    \n\r\n\x05\x04>\x02\x01\x06\x12\x04\xa1\x05\x11.\n\r\n\x05\x04>\x02\x01\
    \x01\x12\x04\xa1\x05/C\n\r\n\x05\x04>\x02\x01\x03\x12\x04\xa1\x05FG\n\
    \x0c\n\x02\x04?\x12\x06\xa4\x05\0\xbd\x05\x01\n\x0b\n\x03\x04?\x01\x12\
    \x04\xa4\x05\x08!\n\x0e\n\x04\x04?\x03\0\x12\x06\xa5\x05\x08\xab\x05\t\n\
    \r\n\x05\x04?\x03\0\x01\x12\x04\xa5\x05\x10\x17\n\x0e\n\x06\x04?\x03\0\
    \x02\0\x12\x04\xa6\x05\x10)\n\x0f\n\x07\x04?\x03\0\x02\0\x04\x12\x04\xa6\
    \x05\x10\x18\n\x0f\n\x07\x04?\x03\0\x02\0\x05\x12\x04\xa6\x05\x19\x1f\n\
    \x0f\n\x07\x04?\x03\0\x02\0\x01\x12\x04\xa6\x05\x20$\n\x0f\n\x07\x04?\
    \x03\0\x02\0\x03\x12\x04\xa6\x05'(\n\x0e\n\x06\x04?\x03\0\x02\x01\x12\
    \x04\xa7\x05\x10/\n\x0f\n\x07\x04?\x03\0\x02\x01\x04\x12\x04\xa7\x05\x10\
    \x18\n\x0f\n\x07\x04?\x03\0\x02\x01\x05\x12\x04\xa7\x05\x19\x1f\n\x0f\n\
    \x07\x04?\x03\0\x02\x01\x01\x12\x04\xa7\x05\x20*\n\x0f\n\x07\x04?\x03\0\
    \x02\x01\x03\x12\x04\xa7\x05-.\n\x0e\n\x06\x04?\x03\0\x02\x02\x12\x04\
    \xa8\x05\x10(\n\x0f\n\x07\x04?\x03\0\x02\x02\x04\x12\x04\xa8\x05\x10\x18\
    \n\x0f\n\x07\x04?\x03\0\x02\x02\x05\x12\x04\xa8\x05\x19\x1e\n\x0f\n\x07\
    \x04?\x03\0\x02\x02\x01\x12\x04\xa8\x05\x1f#\n\x0f\n\x07\x04?\x03\0\x02\
    \x02\x03\x12\x04\xa8\x05&'\n\x0e\n\x06\x04?\x03\0\x02\x03\x12\x04\xa9\
    \x05\x10)\n\x0f\n\x07\x04?\x03\0\x02\x03\x04\x12\x04\xa9\x05\x10\x18\n\
    \x0f\n\x07\x04?\x03\0\x02\x03\x05\x12\x04\xa9\x05\x19\x1e\n\x0f\n\x07\
    \x04?\x03\0\x02\x03\x01\x12\x04\xa9\x05\x1f$\n\x0f\n\x07\x04?\x03\0\x02\
    \x03\x03\x12\x04\xa9\x05'(\n\x0e\n\x06\x04?\x03\0\x02\x04\x12\x04\xaa\
    \x05\x10,\n\x0f\n\x07\x04?\x03\0\x02\x04\x04\x12\x04\xaa\x05\x10\x18\n\
    \x0f\n\x07\x04?\x03\0\x02\x04\x05\x12\x04\xaa\x05\x19\x1e\n\x0f\n\x07\
    \x04?\x03\0\x02\x04\x01\x12\x04\xaa\x05\x1f'\n\x0f\n\x07\x04?\x03\0\x02\
    \x04\x03\x12\x04\xaa\x05*+\n\x0c\n\x04\x04?\x02\0\x12\x04\xad\x05\x08&\n\
    \r\n\x05\x04?\x02\0\x04\x12\x04\xad\x05\x08\x10\n\r\n\x05\x04?\x02\0\x05\
    \x12\x04\xad\x05\x11\x17\n\r\n\x05\x04?\x02\0\x01\x12\x04\xad\x05\x18!\n\
    \r\n\x05\x04?\x02\0\x03\x12\x04\xad\x05$%\n\x0c\n\x04\x04?\x02\x01\x12\
    \x04\xae\x05\x08#\n\r\n\x05\x04?\x02\x01\x04\x12\x04\xae\x05\x08\x10\n\r\
    \n\x05\x04?\x02\x01\x05\x12\x04\xae\x05\x11\x17\n\r\n\x05\x04?\x02\x01\
    \x01\x12\x04\xae\x05\x18\x1e\n\r\n\x05\x04?\x02\x01\x03\x12\x04\xae\x05!\
    \"\n\x0c\n\x04\x04?\x02\x02\x12\x04\xaf\x05\x08%\n\r\n\x05\x04?\x02\x02\
    \x04\x12\x04\xaf\x05\x08\x10\n\r\n\x05\x04?\x02\x02\x05\x12\x04\xaf\x05\
    \x11\x17\n\r\n\x05\x04?\x02\x02\x01\x12\x04\xaf\x05\x18\x20\n\r\n\x05\
    \x04?\x02\x02\x03\x12\x04\xaf\x05#$\n\x0c\n\x04\x04?\x02\x03\x12\x04\xb0\
    \x05\x08'\n\r\n\x05\x04?\x02\x03\x04\x12\x04\xb0\x05\x08\x10\n\r\n\x05\
    \x04?\x02\x03\x05\x12\x04\xb0\x05\x11\x17\n\r\n\x05\x04?\x02\x03\x01\x12\
    \x04\xb0\x05\x18\"\n\r\n\x05\x04?\x02\x03\x03\x12\x04\xb0\x05%&\n\x0c\n\
    \x04\x04?\x02\x04\x12\x04\xb1\x05\x08#\n\r\n\x05\x04?\x02\x04\x04\x12\
    \x04\xb1\x05\x08\x10\n\r\n\x05\x04?\x02\x04\x05\x12\x04\xb1\x05\x11\x17\
    \n\r\n\x05\x04?\x02\x04\x01\x12\x04\xb1\x05\x18\x1e\n\r\n\x05\x04?\x02\
    \x04\x03\x12\x04\xb1\x05!\"\n\x0c\n\x04\x04?\x02\x05\x12\x04\xb2\x05\x08\
    $\n\r\n\x05\x04?\x02\x05\x04\x12\x04\xb2\x05\x08\x10\n\r\n\x05\x04?\x02\
    \x05\x05\x12\x04\xb2\x05\x11\x17\n\r\n\x05\x04?\x02\x05\x01\x12\x04\xb2\
    \x05\x18\x1f\n\r\n\x05\x04?\x02\x05\x03\x12\x04\xb2\x05\"#\n\x0c\n\x04\
    \x04?\x02\x06\x12\x04\xb3\x05\x08&\n\r\n\x05\x04?\x02\x06\x04\x12\x04\
    \xb3\x05\x08\x10\n\r\n\x05\x04?\x02\x06\x05\x12\x04\xb3\x05\x11\x17\n\r\
    \n\x05\x04?\x02\x06\x01\x12\x04\xb3\x05\x18!\n\r\n\x05\x04?\x02\x06\x03\
    \x12\x04\xb3\x05$%\n\x0c\n\x04\x04?\x02\x07\x12\x04\xb4\x05\x08&\n\r\n\
    \x05\x04?\x02\x07\x04\x12\x04\xb4\x05\x08\x10\n\r\n\x05\x04?\x02\x07\x05\
    \x12\x04\xb4\x05\x11\x17\n\r\n\x05\x04?\x02\x07\x01\x12\x04\xb4\x05\x18!\
    \n\r\n\x05\x04?\x02\x07\x03\x12\x04\xb4\x05$%\n\x0c\n\x04\x04?\x02\x08\
    \x12\x04\xb5\x05\x08/\n\r\n\x05\x04?\x02\x08\x04\x12\x04\xb5\x05\x08\x10\
    \n\r\n\x05\x04?\x02\x08\x05\x12\x04\xb5\x05\x11\x17\n\r\n\x05\x04?\x02\
    \x08\x01\x12\x04\xb5\x05\x18*\n\r\n\x05\x04?\x02\x08\x03\x12\x04\xb5\x05\
    -.\n\x0c\n\x04\x04?\x02\t\x12\x04\xb6\x05\x08,\n\r\n\x05\x04?\x02\t\x04\
    \x12\x04\xb6\x05\x08\x10\n\r\n\x05\x04?\x02\t\x05\x12\x04\xb6\x05\x11\
    \x17\n\r\n\x05\x04?\x02\t\x01\x12\x04\xb6\x05\x18&\n\r\n\x05\x04?\x02\t\
    \x03\x12\x04\xb6\x05)+\n\x0c\n\x04\x04?\x02\n\x12\x04\xb7\x05\x08(\n\r\n\
    \x05\x04?\x02\n\x04\x12\x04\xb7\x05\x08\x10\n\r\n\x05\x04?\x02\n\x05\x12\
    \x04\xb7\x05\x11\x17\n\r\n\x05\x04?\x02\n\x01\x12\x04\xb7\x05\x18\"\n\r\
    \n\x05\x04?\x02\n\x03\x12\x04\xb7\x05%'\n\x0c\n\x04\x04?\x02\x0b\x12\x04\
    \xb8\x05\x08B\n\r\n\x05\x04?\x02\x0b\x04\x12\x04\xb8\x05\x08\x10\n\r\n\
    \x05\x04?\x02\x0b\x06\x12\x04\xb8\x05\x113\n\r\n\x05\x04?\x02\x0b\x01\
    \x12\x04\xb8\x054<\n\r\n\x05\x04?\x02\x0b\x03\x12\x04\xb8\x05?A\n\x0c\n\
    \x04\x04?\x02\x0c\x12\x04\xb9\x05\x08'\n\r\n\x05\x04?\x02\x0c\x04\x12\
    \x04\xb9\x05\x08\x10\n\r\n\x05\x04?\x02\x0c\x05\x12\x04\xb9\x05\x11\x17\
    \n\r\n\x05\x04?\x02\x0c\x01\x12\x04\xb9\x05\x18!\n\r\n\x05\x04?\x02\x0c\
    \x03\x12\x04\xb9\x05$&\n\x0c\n\x04\x04?\x02\r\x12\x04\xba\x05\x08$\n\r\n\
    \x05\x04?\x02\r\x04\x12\x04\xba\x05\x08\x10\n\r\n\x05\x04?\x02\r\x05\x12\
    \x04\xba\x05\x11\x17\n\r\n\x05\x04?\x02\r\x01\x12\x04\xba\x05\x18\x1e\n\
    \r\n\x05\x04?\x02\r\x03\x12\x04\xba\x05!#\n\x0c\n\x04\x04?\x02\x0e\x12\
    \x04\xbb\x05\x08%\n\r\n\x05\x04?\x02\x0e\x04\x12\x04\xbb\x05\x08\x10\n\r\
    \n\x05\x04?\x02\x0e\x05\x12\x04\xbb\x05\x11\x17\n\r\n\x05\x04?\x02\x0e\
    \x01\x12\x04\xbb\x05\x18\x1f\n\r\n\x05\x04?\x02\x0e\x03\x12\x04\xbb\x05\
    \"$\n\x0c\n\x04\x04?\x02\x0f\x12\x04\xbc\x05\x08(\n\r\n\x05\x04?\x02\x0f\
    \x04\x12\x04\xbc\x05\x08\x10\n\r\n\x05\x04?\x02\x0f\x05\x12\x04\xbc\x05\
    \x11\x17\n\r\n\x05\x04?\x02\x0f\x01\x12\x04\xbc\x05\x18\"\n\r\n\x05\x04?\
    \x02\x0f\x03\x12\x04\xbc\x05%'\n\x0c\n\x02\x04@\x12\x06\xbf\x05\0\xc1\
    \x05\x01\n\x0b\n\x03\x04@\x01\x12\x04\xbf\x05\x08:\n\x0c\n\x04\x04@\x02\
    \0\x12\x04\xc0\x05\x089\n\r\n\x05\x04@\x02\0\x04\x12\x04\xc0\x05\x08\x10\
    \n\r\n\x05\x04@\x02\0\x06\x12\x04\xc0\x05\x11+\n\r\n\x05\x04@\x02\0\x01\
    \x12\x04\xc0\x05,4\n\r\n\x05\x04@\x02\0\x03\x12\x04\xc0\x0578\n\x0c\n\
    \x02\x04A\x12\x06\xc3\x05\0\xc5\x05\x01\n\x0b\n\x03\x04A\x01\x12\x04\xc3\
    \x05\x08\x1c\n\x0c\n\x04\x04A\x02\0\x12\x04\xc4\x05\x089\n\r\n\x05\x04A\
    \x02\0\x04\x12\x04\xc4\x05\x08\x10\n\r\n\x05\x04A\x02\0\x06\x12\x04\xc4\
    \x05\x11+\n\r\n\x05\x04A\x02\0\x01\x12\x04\xc4\x05,4\n\r\n\x05\x04A\x02\
    \0\x03\x12\x04\xc4\x0578\n\x0c\n\x02\x04B\x12\x06\xc7\x05\0\xcc\x05\x01\
    \n\x0b\n\x03\x04B\x01\x12\x04\xc7\x05\x08?\n\x0c\n\x04\x04B\x02\0\x12\
    \x04\xc8\x05\x08$\n\r\n\x05\x04B\x02\0\x04\x12\x04\xc8\x05\x08\x10\n\r\n\
    \x05\x04B\x02\0\x05\x12\x04\xc8\x05\x11\x17\n\r\n\x05\x04B\x02\0\x01\x12\
    \x04\xc8\x05\x18\x1f\n\r\n\x05\x04B\x02\0\x03\x12\x04\xc8\x05\"#\n\x0c\n\
    \x04\x04B\x02\x01\x12\x04\xc9\x05\x08$\n\r\n\x05\x04B\x02\x01\x04\x12\
    \x04\xc9\x05\x08\x10\n\r\n\x05\x04B\x02\x01\x05\x12\x04\xc9\x05\x11\x17\
    \n\r\n\x05\x04B\x02\x01\x01\x12\x04\xc9\x05\x18\x1f\n\r\n\x05\x04B\x02\
    \x01\x03\x12\x04\xc9\x05\"#\n\x0c\n\x04\x04B\x02\x02\x12\x04\xca\x05\x08\
    $\n\r\n\x05\x04B\x02\x02\x04\x12\x04\xca\x05\x08\x10\n\r\n\x05\x04B\x02\
    \x02\x05\x12\x04\xca\x05\x11\x17\n\r\n\x05\x04B\x02\x02\x01\x12\x04\xca\
    \x05\x18\x1f\n\r\n\x05\x04B\x02\x02\x03\x12\x04\xca\x05\"#\n\x0c\n\x04\
    \x04B\x02\x03\x12\x04\xcb\x05\x08$\n\r\n\x05\x04B\x02\x03\x04\x12\x04\
    \xcb\x05\x08\x10\n\r\n\x05\x04B\x02\x03\x05\x12\x04\xcb\x05\x11\x17\n\r\
    \n\x05\x04B\x02\x03\x01\x12\x04\xcb\x05\x18\x1f\n\r\n\x05\x04B\x02\x03\
    \x03\x12\x04\xcb\x05\"#\n\x0c\n\x02\x04C\x12\x06\xce\x05\0\xd0\x05\x01\n\
    \x0b\n\x03\x04C\x01\x12\x04\xce\x05\x08@\n\x0c\n\x04\x04C\x02\0\x12\x04\
    \xcf\x05\x089\n\r\n\x05\x04C\x02\0\x04\x12\x04\xcf\x05\x08\x10\n\r\n\x05\
    \x04C\x02\0\x06\x12\x04\xcf\x05\x11+\n\r\n\x05\x04C\x02\0\x01\x12\x04\
    \xcf\x05,4\n\r\n\x05\x04C\x02\0\x03\x12\x04\xcf\x0578\n\x0c\n\x02\x04D\
    \x12\x06\xd2\x05\0\xd6\x05\x01\n\x0b\n\x03\x04D\x01\x12\x04\xd2\x05\x08A\
    \n\x0c\n\x04\x04D\x02\0\x12\x04\xd3\x05\x08%\n\r\n\x05\x04D\x02\0\x04\
    \x12\x04\xd3\x05\x08\x10\n\r\n\x05\x04D\x02\0\x05\x12\x04\xd3\x05\x11\
    \x17\n\r\n\x05\x04D\x02\0\x01\x12\x04\xd3\x05\x18\x20\n\r\n\x05\x04D\x02\
    \0\x03\x12\x04\xd3\x05#$\n\x0c\n\x04\x04D\x02\x01\x12\x04\xd4\x05\x08%\n\
    \r\n\x05\x04D\x02\x01\x04\x12\x04\xd4\x05\x08\x10\n\r\n\x05\x04D\x02\x01\
    \x05\x12\x04\xd4\x05\x11\x17\n\r\n\x05\x04D\x02\x01\x01\x12\x04\xd4\x05\
    \x18\x20\n\r\n\x05\x04D\x02\x01\x03\x12\x04\xd4\x05#$\n\x0c\n\x04\x04D\
    \x02\x02\x12\x04\xd5\x05\x08'\n\r\n\x05\x04D\x02\x02\x04\x12\x04\xd5\x05\
    \x08\x10\n\r\n\x05\x04D\x02\x02\x05\x12\x04\xd5\x05\x11\x17\n\r\n\x05\
    \x04D\x02\x02\x01\x12\x04\xd5\x05\x18\"\n\r\n\x05\x04D\x02\x02\x03\x12\
    \x04\xd5\x05%&\n\x0c\n\x02\x04E\x12\x06\xd8\x05\0\xd9\x05\x01\n\x0b\n\
    \x03\x04E\x01\x12\x04\xd8\x05\x08;\n\x0c\n\x02\x04F\x12\x06\xdb\x05\0\
    \xdd\x05\x01\n\x0b\n\x03\x04F\x01\x12\x04\xdb\x05\x08:\n\x0c\n\x04\x04F\
    \x02\0\x12\x04\xdc\x05\x08&\n\r\n\x05\x04F\x02\0\x04\x12\x04\xdc\x05\x08\
    \x10\n\r\n\x05\x04F\x02\0\x05\x12\x04\xdc\x05\x11\x17\n\r\n\x05\x04F\x02\
    \0\x01\x12\x04\xdc\x05\x18!\n\r\n\x05\x04F\x02\0\x03\x12\x04\xdc\x05$%\n\
    \x0c\n\x02\x04G\x12\x06\xdf\x05\0\xe1\x05\x01\n\x0b\n\x03\x04G\x01\x12\
    \x04\xdf\x05\x08:\n\x0c\n\x04\x04G\x02\0\x12\x04\xe0\x05\x08&\n\r\n\x05\
    \x04G\x02\0\x04\x12\x04\xe0\x05\x08\x10\n\r\n\x05\x04G\x02\0\x05\x12\x04\
    \xe0\x05\x11\x17\n\r\n\x05\x04G\x02\0\x01\x12\x04\xe0\x05\x18!\n\r\n\x05\
    \x04G\x02\0\x03\x12\x04\xe0\x05$%\n\x0c\n\x02\x04H\x12\x06\xe3\x05\0\xe5\
    \x05\x01\n\x0b\n\x03\x04H\x01\x12\x04\xe3\x05\x08:\n\x0c\n\x04\x04H\x02\
    \0\x12\x04\xe4\x05\x08#\n\r\n\x05\x04H\x02\0\x04\x12\x04\xe4\x05\x08\x10\
    \n\r\n\x05\x04H\x02\0\x05\x12\x04\xe4\x05\x11\x16\n\r\n\x05\x04H\x02\0\
    \x01\x12\x04\xe4\x05\x17\x1e\n\r\n\x05\x04H\x02\0\x03\x12\x04\xe4\x05!\"\
    \n\x0c\n\x02\x04I\x12\x06\xe7\x05\0\xeb\x05\x01\n\x0b\n\x03\x04I\x01\x12\
    \x04\xe7\x05\x087\n\x0c\n\x04\x04I\x02\0\x12\x04\xe8\x05\x08$\n\r\n\x05\
    \x04I\x02\0\x04\x12\x04\xe8\x05\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\
    \xe8\x05\x11\x17\n\r\n\x05\x04I\x02\0\x01\x12\x04\xe8\x05\x18\x1f\n\r\n\
    \x05\x04I\x02\0\x03\x12\x04\xe8\x05\"#\n\x0c\n\x04\x04I\x02\x01\x12\x04\
    \xe9\x05\x08&\n\r\n\x05\x04I\x02\x01\x04\x12\x04\xe9\x05\x08\x10\n\r\n\
    \x05\x04I\x02\x01\x05\x12\x04\xe9\x05\x11\x17\n\r\n\x05\x04I\x02\x01\x01\
    \x12\x04\xe9\x05\x18!\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xe9\x05$%\n\x0c\
    \n\x04\x04I\x02\x02\x12\x04\xea\x05\x08\"\n\r\n\x05\x04I\x02\x02\x04\x12\
    \x04\xea\x05\x08\x10\n\r\n\x05\x04I\x02\x02\x05\x12\x04\xea\x05\x11\x17\
    \n\r\n\x05\x04I\x02\x02\x01\x12\x04\xea\x05\x18\x1d\n\r\n\x05\x04I\x02\
    \x02\x03\x12\x04\xea\x05\x20!\n\x0c\n\x02\x04J\x12\x06\xed\x05\0\xf3\x05\
    \x01\n\x0b\n\x03\x04J\x01\x12\x04\xed\x05\x08%\n\x0c\n\x04\x04J\x02\0\
    \x12\x04\xee\x05\x08$\n\r\n\x05\x04J\x02\0\x04\x12\x04\xee\x05\x08\x10\n\
    \r\n\x05\x04J\x02\0\x05\x12\x04\xee\x05\x11\x17\n\r\n\x05\x04J\x02\0\x01\
    \x12\x04\xee\x05\x18\x1f\n\r\n\x05\x04J\x02\0\x03\x12\x04\xee\x05\"#\n\
    \x0c\n\x04\x04J\x02\x01\x12\x04\xef\x05\x08&\n\r\n\x05\x04J\x02\x01\x04\
    \x12\x04\xef\x05\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\x04\xef\x05\x11\
    \x17\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xef\x05\x18!\n\r\n\x05\x04J\x02\
    \x01\x03\x12\x04\xef\x05$%\n\x0c\n\x04\x04J\x02\x02\x12\x04\xf0\x05\x08<\
    \n\r\n\x05\x04J\x02\x02\x04\x12\x04\xf0\x05\x08\x10\n\r\n\x05\x04J\x02\
    \x02\x06\x12\x04\xf0\x05\x11$\n\r\n\x05\x04J\x02\x02\x01\x12\x04\xf0\x05\
    %7\n\r\n\x05\x04J\x02\x02\x03\x12\x04\xf0\x05:;\n\x0c\n\x04\x04J\x02\x03\
    \x12\x04\xf1\x05\x08W\n\r\n\x05\x04J\x02\x03\x04\x12\x04\xf1\x05\x08\x10\
    \n\r\n\x05\x04J\x02\x03\x06\x12\x04\xf1\x05\x11@\n\r\n\x05\x04J\x02\x03\
    \x01\x12\x04\xf1\x05AR\n\r\n\x05\x04J\x02\x03\x03\x12\x04\xf1\x05UV\n\
    \x0c\n\x04\x04J\x02\x04\x12\x04\xf2\x05\x08S\n\r\n\x05\x04J\x02\x04\x04\
    \x12\x04\xf2\x05\x08\x10\n\r\n\x05\x04J\x02\x04\x06\x12\x04\xf2\x05\x11@\
    \n\r\n\x05\x04J\x02\x04\x01\x12\x04\xf2\x05AN\n\r\n\x05\x04J\x02\x04\x03\
    \x12\x04\xf2\x05QR\n\x0c\n\x02\x04K\x12\x06\xf5\x05\0\xf9\x05\x01\n\x0b\
    \n\x03\x04K\x01\x12\x04\xf5\x05\x08/\n\x0c\n\x04\x04K\x02\0\x12\x04\xf6\
    \x05\x08#\n\r\n\x05\x04K\x02\0\x04\x12\x04\xf6\x05\x08\x10\n\r\n\x05\x04\
    K\x02\0\x05\x12\x04\xf6\x05\x11\x16\n\r\n\x05\x04K\x02\0\x01\x12\x04\xf6\
    \x05\x17\x1e\n\r\n\x05\x04K\x02\0\x03\x12\x04\xf6\x05!\"\n\x0c\n\x04\x04\
    K\x02\x01\x12\x04\xf7\x05\x08!\n\r\n\x05\x04K\x02\x01\x04\x12\x04\xf7\
    \x05\x08\x10\n\r\n\x05\x04K\x02\x01\x05\x12\x04\xf7\x05\x11\x16\n\r\n\
    \x05\x04K\x02\x01\x01\x12\x04\xf7\x05\x17\x1c\n\r\n\x05\x04K\x02\x01\x03\
    \x12\x04\xf7\x05\x1f\x20\n\x0c\n\x04\x04K\x02\x02\x12\x04\xf8\x05\x08&\n\
    \r\n\x05\x04K\x02\x02\x04\x12\x04\xf8\x05\x08\x10\n\r\n\x05\x04K\x02\x02\
    \x05\x12\x04\xf8\x05\x11\x15\n\r\n\x05\x04K\x02\x02\x01\x12\x04\xf8\x05\
    \x16!\n\r\n\x05\x04K\x02\x02\x03\x12\x04\xf8\x05$%\n\x0c\n\x02\x04L\x12\
    \x06\xfb\x05\0\x8a\x06\x01\n\x0b\n\x03\x04L\x01\x12\x04\xfb\x05\x08+\n\
    \x0e\n\x04\x04L\x03\0\x12\x06\xfc\x05\x08\xfe\x05\t\n\r\n\x05\x04L\x03\0\
    \x01\x12\x04\xfc\x05\x10\x15\n\x0e\n\x06\x04L\x03\0\x02\0\x12\x04\xfd\
    \x05\x10+\n\x0f\n\x07\x04L\x03\0\x02\0\x04\x12\x04\xfd\x05\x10\x18\n\x0f\
    \n\x07\x04L\x03\0\x02\0\x05\x12\x04\xfd\x05\x19\x1e\n\x0f\n\x07\x04L\x03\
    \0\x02\0\x01\x12\x04\xfd\x05\x1f&\n\x0f\n\x07\x04L\x03\0\x02\0\x03\x12\
    \x04\xfd\x05)*\n\x0c\n\x04\x04L\x02\0\x12\x04\x80\x06\x08$\n\r\n\x05\x04\
    L\x02\0\x04\x12\x04\x80\x06\x08\x10\n\r\n\x05\x04L\x02\0\x05\x12\x04\x80\
    \x06\x11\x17\n\r\n\x05\x04L\x02\0\x01\x12\x04\x80\x06\x18\x1f\n\r\n\x05\
    \x04L\x02\0\x03\x12\x04\x80\x06\"#\n\x0c\n\x04\x04L\x02\x01\x12\x04\x81\
    \x06\x08!\n\r\n\x05\x04L\x02\x01\x04\x12\x04\x81\x06\x08\x10\n\r\n\x05\
    \x04L\x02\x01\x05\x12\x04\x81\x06\x11\x17\n\r\n\x05\x04L\x02\x01\x01\x12\
    \x04\x81\x06\x18\x1c\n\r\n\x05\x04L\x02\x01\x03\x12\x04\x81\x06\x1f\x20\
    \n\x0c\n\x04\x04L\x02\x02\x12\x04\x82\x06\x08!\n\r\n\x05\x04L\x02\x02\
    \x04\x12\x04\x82\x06\x08\x10\n\r\n\x05\x04L\x02\x02\x05\x12\x04\x82\x06\
    \x11\x17\n\r\n\x05\x04L\x02\x02\x01\x12\x04\x82\x06\x18\x1c\n\r\n\x05\
    \x04L\x02\x02\x03\x12\x04\x82\x06\x1f\x20\n\x0c\n\x04\x04L\x02\x03\x12\
    \x04\x83\x06\x08.\n\r\n\x05\x04L\x02\x03\x04\x12\x04\x83\x06\x08\x10\n\r\
    \n\x05\x04L\x02\x03\x05\x12\x04\x83\x06\x11\x17\n\r\n\x05\x04L\x02\x03\
    \x01\x12\x04\x83\x06\x18)\n\r\n\x05\x04L\x02\x03\x03\x12\x04\x83\x06,-\n\
    \x0c\n\x04\x04L\x02\x04\x12\x04\x84\x06\x08D\n\r\n\x05\x04L\x02\x04\x04\
    \x12\x04\x84\x06\x08\x10\n\r\n\x05\x04L\x02\x04\x06\x12\x04\x84\x06\x119\
    \n\r\n\x05\x04L\x02\x04\x01\x12\x04\x84\x06:?\n\r\n\x05\x04L\x02\x04\x03\
    \x12\x04\x84\x06BC\n\x0c\n\x04\x04L\x02\x05\x12\x04\x85\x06\x08%\n\r\n\
    \x05\x04L\x02\x05\x04\x12\x04\x85\x06\x08\x10\n\r\n\x05\x04L\x02\x05\x05\
    \x12\x04\x85\x06\x11\x16\n\r\n\x05\x04L\x02\x05\x01\x12\x04\x85\x06\x17\
    \x20\n\r\n\x05\x04L\x02\x05\x03\x12\x04\x85\x06#$\n\x0c\n\x04\x04L\x02\
    \x06\x12\x04\x86\x06\x08.\n\r\n\x05\x04L\x02\x06\x04\x12\x04\x86\x06\x08\
    \x10\n\r\n\x05\x04L\x02\x06\x05\x12\x04\x86\x06\x11\x17\n\r\n\x05\x04L\
    \x02\x06\x01\x12\x04\x86\x06\x18)\n\r\n\x05\x04L\x02\x06\x03\x12\x04\x86\
    \x06,-\n\x0c\n\x04\x04L\x02\x07\x12\x04\x87\x06\x08*\n\r\n\x05\x04L\x02\
    \x07\x04\x12\x04\x87\x06\x08\x10\n\r\n\x05\x04L\x02\x07\x05\x12\x04\x87\
    \x06\x11\x17\n\r\n\x05\x04L\x02\x07\x01\x12\x04\x87\x06\x18%\n\r\n\x05\
    \x04L\x02\x07\x03\x12\x04\x87\x06()\n\x0c\n\x04\x04L\x02\x08\x12\x04\x88\
    \x06\x08,\n\r\n\x05\x04L\x02\x08\x04\x12\x04\x88\x06\x08\x10\n\r\n\x05\
    \x04L\x02\x08\x05\x12\x04\x88\x06\x11\x17\n\r\n\x05\x04L\x02\x08\x01\x12\
    \x04\x88\x06\x18'\n\r\n\x05\x04L\x02\x08\x03\x12\x04\x88\x06*+\n\x0c\n\
    \x04\x04L\x02\t\x12\x04\x89\x06\x08G\n\r\n\x05\x04L\x02\t\x04\x12\x04\
    \x89\x06\x08\x10\n\r\n\x05\x04L\x02\t\x06\x12\x04\x89\x06\x11;\n\r\n\x05\
    \x04L\x02\t\x01\x12\x04\x89\x06<A\n\r\n\x05\x04L\x02\t\x03\x12\x04\x89\
    \x06DF\n\x0c\n\x02\x04M\x12\x06\x8c\x06\0\x91\x06\x01\n\x0b\n\x03\x04M\
    \x01\x12\x04\x8c\x06\x08-\n\x0c\n\x04\x04M\x02\0\x12\x04\x8d\x06\x08&\n\
    \r\n\x05\x04M\x02\0\x04\x12\x04\x8d\x06\x08\x10\n\r\n\x05\x04M\x02\0\x05\
    \x12\x04\x8d\x06\x11\x17\n\r\n\x05\x04M\x02\0\x01\x12\x04\x8d\x06\x18!\n\
    \r\n\x05\x04M\x02\0\x03\x12\x04\x8d\x06$%\n\x0c\n\x04\x04M\x02\x01\x12\
    \x04\x8e\x06\x08!\n\r\n\x05\x04M\x02\x01\x04\x12\x04\x8e\x06\x08\x10\n\r\
    \n\x05\x04M\x02\x01\x05\x12\x04\x8e\x06\x11\x17\n\r\n\x05\x04M\x02\x01\
    \x01\x12\x04\x8e\x06\x18\x1c\n\r\n\x05\x04M\x02\x01\x03\x12\x04\x8e\x06\
    \x1f\x20\n\x0c\n\x04\x04M\x02\x02\x12\x04\x8f\x06\x08!\n\r\n\x05\x04M\
    \x02\x02\x04\x12\x04\x8f\x06\x08\x10\n\r\n\x05\x04M\x02\x02\x05\x12\x04\
    \x8f\x06\x11\x17\n\r\n\x05\x04M\x02\x02\x01\x12\x04\x8f\x06\x18\x1c\n\r\
    \n\x05\x04M\x02\x02\x03\x12\x04\x8f\x06\x1f\x20\n\x0c\n\x04\x04M\x02\x03\
    \x12\x04\x90\x06\x08A\n\r\n\x05\x04M\x02\x03\x04\x12\x04\x90\x06\x08\x10\
    \n\r\n\x05\x04M\x02\x03\x06\x12\x04\x90\x06\x115\n\r\n\x05\x04M\x02\x03\
    \x01\x12\x04\x90\x066<\n\r\n\x05\x04M\x02\x03\x03\x12\x04\x90\x06?@\n\
    \x0c\n\x02\x04N\x12\x06\x93\x06\0\x97\x06\x01\n\x0b\n\x03\x04N\x01\x12\
    \x04\x93\x06\x08*\n\x0c\n\x04\x04N\x02\0\x12\x04\x94\x06\x08E\n\r\n\x05\
    \x04N\x02\0\x04\x12\x04\x94\x06\x08\x10\n\r\n\x05\x04N\x02\0\x06\x12\x04\
    \x94\x06\x117\n\r\n\x05\x04N\x02\0\x01\x12\x04\x94\x068@\n\r\n\x05\x04N\
    \x02\0\x03\x12\x04\x94\x06CD\n\x0c\n\x04\x04N\x02\x01\x12\x04\x95\x06\
    \x087\n\r\n\x05\x04N\x02\x01\x04\x12\x04\x95\x06\x08\x10\n\r\n\x05\x04N\
    \x02\x01\x06\x12\x04\x95\x06\x11!\n\r\n\x05\x04N\x02\x01\x01\x12\x04\x95\
    \x06\"2\n\r\n\x05\x04N\x02\x01\x03\x12\x04\x95\x0656\n\x0c\n\x04\x04N\
    \x02\x02\x12\x04\x96\x06\x086\n\r\n\x05\x04N\x02\x02\x04\x12\x04\x96\x06\
    \x08\x10\n\r\n\x05\x04N\x02\x02\x06\x12\x04\x96\x06\x11\x20\n\r\n\x05\
    \x04N\x02\x02\x01\x12\x04\x96\x06!1\n\r\n\x05\x04N\x02\x02\x03\x12\x04\
    \x96\x0645\n\x0c\n\x02\x04O\x12\x06\x99\x06\0\xa0\x06\x01\n\x0b\n\x03\
    \x04O\x01\x12\x04\x99\x06\x08$\n\x0c\n\x04\x04O\x02\0\x12\x04\x9a\x06\
    \x08)\n\r\n\x05\x04O\x02\0\x04\x12\x04\x9a\x06\x08\x10\n\r\n\x05\x04O\
    \x02\0\x05\x12\x04\x9a\x06\x11\x17\n\r\n\x05\x04O\x02\0\x01\x12\x04\x9a\
    \x06\x18$\n\r\n\x05\x04O\x02\0\x03\x12\x04\x9a\x06'(\n\x0c\n\x04\x04O\
    \x02\x01\x12\x04\x9b\x06\x08&\n\r\n\x05\x04O\x02\x01\x04\x12\x04\x9b\x06\
    \x08\x10\n\r\n\x05\x04O\x02\x01\x05\x12\x04\x9b\x06\x11\x17\n\r\n\x05\
    \x04O\x02\x01\x01\x12\x04\x9b\x06\x18!\n\r\n\x05\x04O\x02\x01\x03\x12\
    \x04\x9b\x06$%\n\x0c\n\x04\x04O\x02\x02\x12\x04\x9c\x06\x08'\n\r\n\x05\
    \x04O\x02\x02\x04\x12\x04\x9c\x06\x08\x10\n\r\n\x05\x04O\x02\x02\x05\x12\
    \x04\x9c\x06\x11\x17\n\r\n\x05\x04O\x02\x02\x01\x12\x04\x9c\x06\x18\"\n\
    \r\n\x05\x04O\x02\x02\x03\x12\x04\x9c\x06%&\n\x0c\n\x04\x04O\x02\x03\x12\
    \x04\x9d\x06\x08<\n\r\n\x05\x04O\x02\x03\x04\x12\x04\x9d\x06\x08\x10\n\r\
    \n\x05\x04O\x02\x03\x06\x12\x04\x9d\x06\x11/\n\r\n\x05\x04O\x02\x03\x01\
    \x12\x04\x9d\x0607\n\r\n\x05\x04O\x02\x03\x03\x12\x04\x9d\x06:;\n\x0c\n\
    \x04\x04O\x02\x04\x12\x04\x9e\x06\x08-\n\r\n\x05\x04O\x02\x04\x04\x12\
    \x04\x9e\x06\x08\x10\n\r\n\x05\x04O\x02\x04\x06\x12\x04\x9e\x06\x11\x20\
    \n\r\n\x05\x04O\x02\x04\x01\x12\x04\x9e\x06!(\n\r\n\x05\x04O\x02\x04\x03\
    \x12\x04\x9e\x06+,\n\x0c\n\x04\x04O\x02\x05\x12\x04\x9f\x06\x08H\n\r\n\
    \x05\x04O\x02\x05\x04\x12\x04\x9f\x06\x08\x10\n\r\n\x05\x04O\x02\x05\x06\
    \x12\x04\x9f\x06\x114\n\r\n\x05\x04O\x02\x05\x01\x12\x04\x9f\x065C\n\r\n\
    \x05\x04O\x02\x05\x03\x12\x04\x9f\x06FG\n\x0c\n\x02\x04P\x12\x06\xa2\x06\
    \0\xad\x06\x01\n\x0b\n\x03\x04P\x01\x12\x04\xa2\x06\x08&\n\x0e\n\x04\x04\
    P\x03\0\x12\x06\xa3\x06\x08\xa9\x06\t\n\r\n\x05\x04P\x03\0\x01\x12\x04\
    \xa3\x06\x10\"\n\x0e\n\x06\x04P\x03\0\x02\0\x12\x04\xa4\x06\x10-\n\x0f\n\
    \x07\x04P\x03\0\x02\0\x04\x12\x04\xa4\x06\x10\x18\n\x0f\n\x07\x04P\x03\0\
    \x02\0\x05\x12\x04\xa4\x06\x19\x1e\n\x0f\n\x07\x04P\x03\0\x02\0\x01\x12\
    \x04\xa4\x06\x1f(\n\x0f\n\x07\x04P\x03\0\x02\0\x03\x12\x04\xa4\x06+,\n\
    \x0e\n\x06\x04P\x03\0\x02\x01\x12\x04\xa5\x06\x10+\n\x0f\n\x07\x04P\x03\
    \0\x02\x01\x04\x12\x04\xa5\x06\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x01\
    \x05\x12\x04\xa5\x06\x19\x1e\n\x0f\n\x07\x04P\x03\0\x02\x01\x01\x12\x04\
    \xa5\x06\x1f&\n\x0f\n\x07\x04P\x03\0\x02\x01\x03\x12\x04\xa5\x06)*\n\x0e\
    \n\x06\x04P\x03\0\x02\x02\x12\x04\xa6\x06\x10)\n\x0f\n\x07\x04P\x03\0\
    \x02\x02\x04\x12\x04\xa6\x06\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x02\x05\
    \x12\x04\xa6\x06\x19\x1e\n\x0f\n\x07\x04P\x03\0\x02\x02\x01\x12\x04\xa6\
    \x06\x1f$\n\x0f\n\x07\x04P\x03\0\x02\x02\x03\x12\x04\xa6\x06'(\n\x0e\n\
    \x06\x04P\x03\0\x02\x03\x12\x04\xa7\x06\x10*\n\x0f\n\x07\x04P\x03\0\x02\
    \x03\x04\x12\x04\xa7\x06\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x03\x05\x12\
    \x04\xa7\x06\x19\x1e\n\x0f\n\x07\x04P\x03\0\x02\x03\x01\x12\x04\xa7\x06\
    \x1f%\n\x0f\n\x07\x04P\x03\0\x02\x03\x03\x12\x04\xa7\x06()\n\x0e\n\x06\
    \x04P\x03\0\x02\x04\x12\x04\xa8\x06\x10+\n\x0f\n\x07\x04P\x03\0\x02\x04\
    \x04\x12\x04\xa8\x06\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x04\x05\x12\x04\
    \xa8\x06\x19\x1f\n\x0f\n\x07\x04P\x03\0\x02\x04\x01\x12\x04\xa8\x06\x20&\
    \n\x0f\n\x07\x04P\x03\0\x02\x04\x03\x12\x04\xa8\x06)*\n\x0c\n\x04\x04P\
    \x02\0\x12\x04\xab\x06\x08%\n\r\n\x05\x04P\x02\0\x04\x12\x04\xab\x06\x08\
    \x10\n\r\n\x05\x04P\x02\0\x05\x12\x04\xab\x06\x11\x17\n\r\n\x05\x04P\x02\
    \0\x01\x12\x04\xab\x06\x18\x20\n\r\n\x05\x04P\x02\0\x03\x12\x04\xab\x06#\
    $\n\x0c\n\x04\x04P\x02\x01\x12\x04\xac\x06\x08_\n\r\n\x05\x04P\x02\x01\
    \x04\x12\x04\xac\x06\x08\x10\n\r\n\x05\x04P\x02\x01\x06\x12\x04\xac\x06\
    \x11C\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xac\x06DZ\n\r\n\x05\x04P\x02\
    \x01\x03\x12\x04\xac\x06]^\n\x0c\n\x02\x04Q\x12\x06\xaf\x06\0\xbd\x06\
    \x01\n\x0b\n\x03\x04Q\x01\x12\x04\xaf\x06\x08\"\n\x0e\n\x04\x04Q\x03\0\
    \x12\x06\xb0\x06\x08\xb4\x06\t\n\r\n\x05\x04Q\x03\0\x01\x12\x04\xb0\x06\
    \x10\x1b\n\x0e\n\x06\x04Q\x03\0\x02\0\x12\x04\xb1\x06\x10(\n\x0f\n\x07\
    \x04Q\x03\0\x02\0\x04\x12\x04\xb1\x06\x10\x18\n\x0f\n\x07\x04Q\x03\0\x02\
    \0\x05\x12\x04\xb1\x06\x19\x1e\n\x0f\n\x07\x04Q\x03\0\x02\0\x01\x12\x04\
    \xb1\x06\x1f#\n\x0f\n\x07\x04Q\x03\0\x02\0\x03\x12\x04\xb1\x06&'\n\x0e\n\
    \x06\x04Q\x03\0\x02\x01\x12\x04\xb2\x06\x10(\n\x0f\n\x07\x04Q\x03\0\x02\
    \x01\x04\x12\x04\xb2\x06\x10\x18\n\x0f\n\x07\x04Q\x03\0\x02\x01\x05\x12\
    \x04\xb2\x06\x19\x1e\n\x0f\n\x07\x04Q\x03\0\x02\x01\x01\x12\x04\xb2\x06\
    \x1f#\n\x0f\n\x07\x04Q\x03\0\x02\x01\x03\x12\x04\xb2\x06&'\n\x0e\n\x06\
    \x04Q\x03\0\x02\x02\x12\x04\xb3\x06\x10+\n\x0f\n\x07\x04Q\x03\0\x02\x02\
    \x04\x12\x04\xb3\x06\x10\x18\n\x0f\n\x07\x04Q\x03\0\x02\x02\x05\x12\x04\
    \xb3\x06\x19\x1f\n\x0f\n\x07\x04Q\x03\0\x02\x02\x01\x12\x04\xb3\x06\x20&\
    \n\x0f\n\x07\x04Q\x03\0\x02\x02\x03\x12\x04\xb3\x06)*\n\x0e\n\x04\x04Q\
    \x03\x01\x12\x06\xb6\x06\x08\xb9\x06\t\n\r\n\x05\x04Q\x03\x01\x01\x12\
    \x04\xb6\x06\x10\x1b\n\x0e\n\x06\x04Q\x03\x01\x02\0\x12\x04\xb7\x06\x10-\
    \n\x0f\n\x07\x04Q\x03\x01\x02\0\x04\x12\x04\xb7\x06\x10\x18\n\x0f\n\x07\
    \x04Q\x03\x01\x02\0\x05\x12\x04\xb7\x06\x19\x1e\n\x0f\n\x07\x04Q\x03\x01\
    \x02\0\x01\x12\x04\xb7\x06\x1f(\n\x0f\n\x07\x04Q\x03\x01\x02\0\x03\x12\
    \x04\xb7\x06+,\n\x0e\n\x06\x04Q\x03\x01\x02\x01\x12\x04\xb8\x06\x10K\n\
    \x0f\n\x07\x04Q\x03\x01\x02\x01\x04\x12\x04\xb8\x06\x10\x18\n\x0f\n\x07\
    \x04Q\x03\x01\x02\x01\x06\x12\x04\xb8\x06\x19@\n\x0f\n\x07\x04Q\x03\x01\
    \x02\x01\x01\x12\x04\xb8\x06AF\n\x0f\n\x07\x04Q\x03\x01\x02\x01\x03\x12\
    \x04\xb8\x06IJ\n\x0c\n\x04\x04Q\x02\0\x12\x04\xbb\x06\x08%\n\r\n\x05\x04\
    Q\x02\0\x04\x12\x04\xbb\x06\x08\x10\n\r\n\x05\x04Q\x02\0\x05\x12\x04\xbb\
    \x06\x11\x17\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xbb\x06\x18\x20\n\r\n\x05\
    \x04Q\x02\0\x03\x12\x04\xbb\x06#$\n\x0c\n\x04\x04Q\x02\x01\x12\x04\xbc\
    \x06\x08C\n\r\n\x05\x04Q\x02\x01\x04\x12\x04\xbc\x06\x08\x10\n\r\n\x05\
    \x04Q\x02\x01\x06\x12\x04\xbc\x06\x118\n\r\n\x05\x04Q\x02\x01\x01\x12\
    \x04\xbc\x069>\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\xbc\x06AB\n\x0c\n\x02\
    \x04R\x12\x06\xbf\x06\0\xc1\x06\x01\n\x0b\n\x03\x04R\x01\x12\x04\xbf\x06\
    \x08\x19\n\x0c\n\x04\x04R\x02\0\x12\x04\xc0\x06\x08\"\n\r\n\x05\x04R\x02\
    \0\x04\x12\x04\xc0\x06\x08\x10\n\r\n\x05\x04R\x02\0\x05\x12\x04\xc0\x06\
    \x11\x17\n\r\n\x05\x04R\x02\0\x01\x12\x04\xc0\x06\x18\x1d\n\r\n\x05\x04R\
    \x02\0\x03\x12\x04\xc0\x06\x20!\n\x0c\n\x02\x04S\x12\x06\xc3\x06\0\xc4\
    \x06\x01\n\x0b\n\x03\x04S\x01\x12\x04\xc3\x06\x08\x20\n\x0c\n\x02\x04T\
    \x12\x06\xc6\x06\0\xce\x06\x01\n\x0b\n\x03\x04T\x01\x12\x04\xc6\x06\x08\
    \x1c\n\x0c\n\x04\x04T\x02\0\x12\x04\xc7\x06\x08,\n\r\n\x05\x04T\x02\0\
    \x04\x12\x04\xc7\x06\x08\x10\n\r\n\x05\x04T\x02\0\x05\x12\x04\xc7\x06\
    \x11\x17\n\r\n\x05\x04T\x02\0\x01\x12\x04\xc7\x06\x18'\n\r\n\x05\x04T\
    \x02\0\x03\x12\x04\xc7\x06*+\n\x0c\n\x04\x04T\x02\x01\x12\x04\xc8\x06\
    \x084\n\r\n\x05\x04T\x02\x01\x04\x12\x04\xc8\x06\x08\x10\n\r\n\x05\x04T\
    \x02\x01\x05\x12\x04\xc8\x06\x11\x17\n\r\n\x05\x04T\x02\x01\x01\x12\x04\
    \xc8\x06\x18/\n\r\n\x05\x04T\x02\x01\x03\x12\x04\xc8\x0623\n\x0c\n\x04\
    \x04T\x02\x02\x12\x04\xc9\x06\x08/\n\r\n\x05\x04T\x02\x02\x04\x12\x04\
    \xc9\x06\x08\x10\n\r\n\x05\x04T\x02\x02\x05\x12\x04\xc9\x06\x11\x17\n\r\
    \n\x05\x04T\x02\x02\x01\x12\x04\xc9\x06\x18)\n\r\n\x05\x04T\x02\x02\x03\
    \x12\x04\xc9\x06,.\n\x0c\n\x04\x04T\x02\x03\x12\x04\xca\x06\x08.\n\r\n\
    \x05\x04T\x02\x03\x04\x12\x04\xca\x06\x08\x10\n\r\n\x05\x04T\x02\x03\x05\
    \x12\x04\xca\x06\x11\x17\n\r\n\x05\x04T\x02\x03\x01\x12\x04\xca\x06\x18(\
    \n\r\n\x05\x04T\x02\x03\x03\x12\x04\xca\x06+-\n\x0c\n\x04\x04T\x02\x04\
    \x12\x04\xcb\x06\x08-\n\r\n\x05\x04T\x02\x04\x04\x12\x04\xcb\x06\x08\x10\
    \n\r\n\x05\x04T\x02\x04\x05\x12\x04\xcb\x06\x11\x17\n\r\n\x05\x04T\x02\
    \x04\x01\x12\x04\xcb\x06\x18'\n\r\n\x05\x04T\x02\x04\x03\x12\x04\xcb\x06\
    *,\n\x0c\n\x04\x04T\x02\x05\x12\x04\xcc\x06\x08(\n\r\n\x05\x04T\x02\x05\
    \x04\x12\x04\xcc\x06\x08\x10\n\r\n\x05\x04T\x02\x05\x05\x12\x04\xcc\x06\
    \x11\x17\n\r\n\x05\x04T\x02\x05\x01\x12\x04\xcc\x06\x18\"\n\r\n\x05\x04T\
    \x02\x05\x03\x12\x04\xcc\x06%'\n\x0c\n\x04\x04T\x02\x06\x12\x04\xcd\x06\
    \x08&\n\r\n\x05\x04T\x02\x06\x04\x12\x04\xcd\x06\x08\x10\n\r\n\x05\x04T\
    \x02\x06\x05\x12\x04\xcd\x06\x11\x17\n\r\n\x05\x04T\x02\x06\x01\x12\x04\
    \xcd\x06\x18\x20\n\r\n\x05\x04T\x02\x06\x03\x12\x04\xcd\x06#%\n\x0c\n\
    \x02\x04U\x12\x06\xd0\x06\0\xd6\x06\x01\n\x0b\n\x03\x04U\x01\x12\x04\xd0\
    \x06\x089\n\x0c\n\x04\x04U\x02\0\x12\x04\xd1\x06\x08'\n\r\n\x05\x04U\x02\
    \0\x04\x12\x04\xd1\x06\x08\x10\n\r\n\x05\x04U\x02\0\x05\x12\x04\xd1\x06\
    \x11\x17\n\r\n\x05\x04U\x02\0\x01\x12\x04\xd1\x06\x18\"\n\r\n\x05\x04U\
    \x02\0\x03\x12\x04\xd1\x06%&\n\x0c\n\x04\x04U\x02\x01\x12\x04\xd2\x06\
    \x08%\n\r\n\x05\x04U\x02\x01\x04\x12\x04\xd2\x06\x08\x10\n\r\n\x05\x04U\
    \x02\x01\x05\x12\x04\xd2\x06\x11\x16\n\r\n\x05\x04U\x02\x01\x01\x12\x04\
    \xd2\x06\x17\x20\n\r\n\x05\x04U\x02\x01\x03\x12\x04\xd2\x06#$\n\x0c\n\
    \x04\x04U\x02\x02\x12\x04\xd3\x06\x08(\n\r\n\x05\x04U\x02\x02\x04\x12\
    \x04\xd3\x06\x08\x10\n\r\n\x05\x04U\x02\x02\x05\x12\x04\xd3\x06\x11\x17\
    \n\r\n\x05\x04U\x02\x02\x01\x12\x04\xd3\x06\x18#\n\r\n\x05\x04U\x02\x02\
    \x03\x12\x04\xd3\x06&'\n\x0c\n\x04\x04U\x02\x03\x12\x04\xd4\x06\x08(\n\r\
    \n\x05\x04U\x02\x03\x04\x12\x04\xd4\x06\x08\x10\n\r\n\x05\x04U\x02\x03\
    \x05\x12\x04\xd4\x06\x11\x17\n\r\n\x05\x04U\x02\x03\x01\x12\x04\xd4\x06\
    \x18#\n\r\n\x05\x04U\x02\x03\x03\x12\x04\xd4\x06&'\n\x0c\n\x04\x04U\x02\
    \x04\x12\x04\xd5\x06\x08*\n\r\n\x05\x04U\x02\x04\x04\x12\x04\xd5\x06\x08\
    \x10\n\r\n\x05\x04U\x02\x04\x05\x12\x04\xd5\x06\x11\x17\n\r\n\x05\x04U\
    \x02\x04\x01\x12\x04\xd5\x06\x18%\n\r\n\x05\x04U\x02\x04\x03\x12\x04\xd5\
    \x06()\n\x0c\n\x02\x04V\x12\x06\xd8\x06\0\xdc\x06\x01\n\x0b\n\x03\x04V\
    \x01\x12\x04\xd8\x06\x089\n\x0c\n\x04\x04V\x02\0\x12\x04\xd9\x06\x08&\n\
    \r\n\x05\x04V\x02\0\x04\x12\x04\xd9\x06\x08\x10\n\r\n\x05\x04V\x02\0\x05\
    \x12\x04\xd9\x06\x11\x17\n\r\n\x05\x04V\x02\0\x01\x12\x04\xd9\x06\x18!\n\
    \r\n\x05\x04V\x02\0\x03\x12\x04\xd9\x06$%\n\x0c\n\x04\x04V\x02\x01\x12\
    \x04\xda\x06\x08'\n\r\n\x05\x04V\x02\x01\x04\x12\x04\xda\x06\x08\x10\n\r\
    \n\x05\x04V\x02\x01\x05\x12\x04\xda\x06\x11\x17\n\r\n\x05\x04V\x02\x01\
    \x01\x12\x04\xda\x06\x18\"\n\r\n\x05\x04V\x02\x01\x03\x12\x04\xda\x06%&\
    \n\x0c\n\x04\x04V\x02\x02\x12\x04\xdb\x06\x08!\n\r\n\x05\x04V\x02\x02\
    \x04\x12\x04\xdb\x06\x08\x10\n\r\n\x05\x04V\x02\x02\x05\x12\x04\xdb\x06\
    \x11\x17\n\r\n\x05\x04V\x02\x02\x01\x12\x04\xdb\x06\x18\x1c\n\r\n\x05\
    \x04V\x02\x02\x03\x12\x04\xdb\x06\x1f\x20\n\x0c\n\x02\x04W\x12\x06\xde\
    \x06\0\xdf\x06\x01\n\x0b\n\x03\x04W\x01\x12\x04\xde\x06\x082\n\x0c\n\x02\
    \x04X\x12\x06\xe1\x06\0\xec\x06\x01\n\x0b\n\x03\x04X\x01\x12\x04\xe1\x06\
    \x083\n\x0e\n\x04\x04X\x03\0\x12\x06\xe2\x06\x08\xe5\x06\t\n\r\n\x05\x04\
    X\x03\0\x01\x12\x04\xe2\x06\x10$\n\x0e\n\x06\x04X\x03\0\x02\0\x12\x04\
    \xe3\x06\x10.\n\x0f\n\x07\x04X\x03\0\x02\0\x04\x12\x04\xe3\x06\x10\x18\n\
    \x0f\n\x07\x04X\x03\0\x02\0\x05\x12\x04\xe3\x06\x19\x1f\n\x0f\n\x07\x04X\
    \x03\0\x02\0\x01\x12\x04\xe3\x06\x20)\n\x0f\n\x07\x04X\x03\0\x02\0\x03\
    \x12\x04\xe3\x06,-\n\x0e\n\x06\x04X\x03\0\x02\x01\x12\x04\xe4\x06\x10*\n\
    \x0f\n\x07\x04X\x03\0\x02\x01\x04\x12\x04\xe4\x06\x10\x18\n\x0f\n\x07\
    \x04X\x03\0\x02\x01\x05\x12\x04\xe4\x06\x19\x1f\n\x0f\n\x07\x04X\x03\0\
    \x02\x01\x01\x12\x04\xe4\x06\x20%\n\x0f\n\x07\x04X\x03\0\x02\x01\x03\x12\
    \x04\xe4\x06()\n\x0c\n\x04\x04X\x02\0\x12\x04\xe7\x06\x08'\n\r\n\x05\x04\
    X\x02\0\x04\x12\x04\xe7\x06\x08\x10\n\r\n\x05\x04X\x02\0\x05\x12\x04\xe7\
    \x06\x11\x17\n\r\n\x05\x04X\x02\0\x01\x12\x04\xe7\x06\x18\"\n\r\n\x05\
    \x04X\x02\0\x03\x12\x04\xe7\x06%&\n\x0c\n\x04\x04X\x02\x01\x12\x04\xe8\
    \x06\x080\n\r\n\x05\x04X\x02\x01\x04\x12\x04\xe8\x06\x08\x10\n\r\n\x05\
    \x04X\x02\x01\x05\x12\x04\xe8\x06\x11\x17\n\r\n\x05\x04X\x02\x01\x01\x12\
    \x04\xe8\x06\x18+\n\r\n\x05\x04X\x02\x01\x03\x12\x04\xe8\x06./\n\x0c\n\
    \x04\x04X\x02\x02\x12\x04\xe9\x06\x08.\n\r\n\x05\x04X\x02\x02\x04\x12\
    \x04\xe9\x06\x08\x10\n\r\n\x05\x04X\x02\x02\x05\x12\x04\xe9\x06\x11\x17\
    \n\r\n\x05\x04X\x02\x02\x01\x12\x04\xe9\x06\x18)\n\r\n\x05\x04X\x02\x02\
    \x03\x12\x04\xe9\x06,-\n\x0c\n\x04\x04X\x02\x03\x12\x04\xea\x06\x08)\n\r\
    \n\x05\x04X\x02\x03\x04\x12\x04\xea\x06\x08\x10\n\r\n\x05\x04X\x02\x03\
    \x05\x12\x04\xea\x06\x11\x17\n\r\n\x05\x04X\x02\x03\x01\x12\x04\xea\x06\
    \x18$\n\r\n\x05\x04X\x02\x03\x03\x12\x04\xea\x06'(\n\x0c\n\x04\x04X\x02\
    \x04\x12\x04\xeb\x06\x08_\n\r\n\x05\x04X\x02\x04\x04\x12\x04\xeb\x06\x08\
    \x10\n\r\n\x05\x04X\x02\x04\x06\x12\x04\xeb\x06\x11R\n\r\n\x05\x04X\x02\
    \x04\x01\x12\x04\xeb\x06SZ\n\r\n\x05\x04X\x02\x04\x03\x12\x04\xeb\x06]^\
    \n\x0c\n\x02\x04Y\x12\x06\xee\x06\0\xf1\x06\x01\n\x0b\n\x03\x04Y\x01\x12\
    \x04\xee\x06\x081\n\x0c\n\x04\x04Y\x02\0\x12\x04\xef\x06\x08&\n\r\n\x05\
    \x04Y\x02\0\x04\x12\x04\xef\x06\x08\x10\n\r\n\x05\x04Y\x02\0\x05\x12\x04\
    \xef\x06\x11\x17\n\r\n\x05\x04Y\x02\0\x01\x12\x04\xef\x06\x18!\n\r\n\x05\
    \x04Y\x02\0\x03\x12\x04\xef\x06$%\n\x0c\n\x04\x04Y\x02\x01\x12\x04\xf0\
    \x06\x08!\n\r\n\x05\x04Y\x02\x01\x04\x12\x04\xf0\x06\x08\x10\n\r\n\x05\
    \x04Y\x02\x01\x05\x12\x04\xf0\x06\x11\x17\n\r\n\x05\x04Y\x02\x01\x01\x12\
    \x04\xf0\x06\x18\x1c\n\r\n\x05\x04Y\x02\x01\x03\x12\x04\xf0\x06\x1f\x20\
    \n\x0c\n\x02\x04Z\x12\x06\xf3\x06\0\xf5\x06\x01\n\x0b\n\x03\x04Z\x01\x12\
    \x04\xf3\x06\x082\n\x0c\n\x04\x04Z\x02\0\x12\x04\xf4\x06\x08&\n\r\n\x05\
    \x04Z\x02\0\x04\x12\x04\xf4\x06\x08\x10\n\r\n\x05\x04Z\x02\0\x05\x12\x04\
    \xf4\x06\x11\x17\n\r\n\x05\x04Z\x02\0\x01\x12\x04\xf4\x06\x18!\n\r\n\x05\
    \x04Z\x02\0\x03\x12\x04\xf4\x06$%\n\x0c\n\x02\x04[\x12\x06\xf7\x06\0\x80\
    \x07\x01\n\x0b\n\x03\x04[\x01\x12\x04\xf7\x06\x08?\n\x0c\n\x04\x04[\x02\
    \0\x12\x04\xf8\x06\x08&\n\r\n\x05\x04[\x02\0\x04\x12\x04\xf8\x06\x08\x10\
    \n\r\n\x05\x04[\x02\0\x05\x12\x04\xf8\x06\x11\x17\n\r\n\x05\x04[\x02\0\
    \x01\x12\x04\xf8\x06\x18!\n\r\n\x05\x04[\x02\0\x03\x12\x04\xf8\x06$%\n\
    \x0c\n\x04\x04[\x02\x01\x12\x04\xf9\x06\x08!\n\r\n\x05\x04[\x02\x01\x04\
    \x12\x04\xf9\x06\x08\x10\n\r\n\x05\x04[\x02\x01\x05\x12\x04\xf9\x06\x11\
    \x17\n\r\n\x05\x04[\x02\x01\x01\x12\x04\xf9\x06\x18\x1c\n\r\n\x05\x04[\
    \x02\x01\x03\x12\x04\xf9\x06\x1f\x20\n\x0c\n\x04\x04[\x02\x02\x12\x04\
    \xfa\x06\x08!\n\r\n\x05\x04[\x02\x02\x04\x12\x04\xfa\x06\x08\x10\n\r\n\
    \x05\x04[\x02\x02\x05\x12\x04\xfa\x06\x11\x17\n\r\n\x05\x04[\x02\x02\x01\
    \x12\x04\xfa\x06\x18\x1c\n\r\n\x05\x04[\x02\x02\x03\x12\x04\xfa\x06\x1f\
    \x20\n\x0c\n\x04\x04[\x02\x03\x12\x04\xfb\x06\x08\x20\n\r\n\x05\x04[\x02\
    \x03\x04\x12\x04\xfb\x06\x08\x10\n\r\n\x05\x04[\x02\x03\x05\x12\x04\xfb\
    \x06\x11\x17\n\r\n\x05\x04[\x02\x03\x01\x12\x04\xfb\x06\x18\x1b\n\r\n\
    \x05\x04[\x02\x03\x03\x12\x04\xfb\x06\x1e\x1f\n\x0c\n\x04\x04[\x02\x04\
    \x12\x04\xfc\x06\x08\x20\n\r\n\x05\x04[\x02\x04\x04\x12\x04\xfc\x06\x08\
    \x10\n\r\n\x05\x04[\x02\x04\x05\x12\x04\xfc\x06\x11\x16\n\r\n\x05\x04[\
    \x02\x04\x01\x12\x04\xfc\x06\x17\x1b\n\r\n\x05\x04[\x02\x04\x03\x12\x04\
    \xfc\x06\x1e\x1f\n\x0c\n\x04\x04[\x02\x05\x12\x04\xfd\x06\x08\x1f\n\r\n\
    \x05\x04[\x02\x05\x04\x12\x04\xfd\x06\x08\x10\n\r\n\x05\x04[\x02\x05\x05\
    \x12\x04\xfd\x06\x11\x16\n\r\n\x05\x04[\x02\x05\x01\x12\x04\xfd\x06\x17\
    \x1a\n\r\n\x05\x04[\x02\x05\x03\x12\x04\xfd\x06\x1d\x1e\n\x0c\n\x04\x04[\
    \x02\x06\x12\x04\xfe\x06\x08'\n\r\n\x05\x04[\x02\x06\x04\x12\x04\xfe\x06\
    \x08\x10\n\r\n\x05\x04[\x02\x06\x05\x12\x04\xfe\x06\x11\x16\n\r\n\x05\
    \x04[\x02\x06\x01\x12\x04\xfe\x06\x17\"\n\r\n\x05\x04[\x02\x06\x03\x12\
    \x04\xfe\x06%&\n\x0c\n\x04\x04[\x02\x07\x12\x04\xff\x06\x08(\n\r\n\x05\
    \x04[\x02\x07\x04\x12\x04\xff\x06\x08\x10\n\r\n\x05\x04[\x02\x07\x05\x12\
    \x04\xff\x06\x11\x16\n\r\n\x05\x04[\x02\x07\x01\x12\x04\xff\x06\x17#\n\r\
    \n\x05\x04[\x02\x07\x03\x12\x04\xff\x06&'\n\x0c\n\x02\x04\\\x12\x06\x82\
    \x07\0\x87\x07\x01\n\x0b\n\x03\x04\\\x01\x12\x04\x82\x07\x082\n\x0c\n\
    \x04\x04\\\x02\0\x12\x04\x83\x07\x08$\n\r\n\x05\x04\\\x02\0\x04\x12\x04\
    \x83\x07\x08\x10\n\r\n\x05\x04\\\x02\0\x05\x12\x04\x83\x07\x11\x17\n\r\n\
    \x05\x04\\\x02\0\x01\x12\x04\x83\x07\x18\x1f\n\r\n\x05\x04\\\x02\0\x03\
    \x12\x04\x83\x07\"#\n\x0c\n\x04\x04\\\x02\x01\x12\x04\x84\x07\x08$\n\r\n\
    \x05\x04\\\x02\x01\x04\x12\x04\x84\x07\x08\x10\n\r\n\x05\x04\\\x02\x01\
    \x05\x12\x04\x84\x07\x11\x17\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\x84\x07\
    \x18\x1f\n\r\n\x05\x04\\\x02\x01\x03\x12\x04\x84\x07\"#\n\x0c\n\x04\x04\
    \\\x02\x02\x12\x04\x85\x07\x08&\n\r\n\x05\x04\\\x02\x02\x04\x12\x04\x85\
    \x07\x08\x10\n\r\n\x05\x04\\\x02\x02\x05\x12\x04\x85\x07\x11\x17\n\r\n\
    \x05\x04\\\x02\x02\x01\x12\x04\x85\x07\x18!\n\r\n\x05\x04\\\x02\x02\x03\
    \x12\x04\x85\x07$%\n\x0c\n\x04\x04\\\x02\x03\x12\x04\x86\x07\x08$\n\r\n\
    \x05\x04\\\x02\x03\x04\x12\x04\x86\x07\x08\x10\n\r\n\x05\x04\\\x02\x03\
    \x05\x12\x04\x86\x07\x11\x17\n\r\n\x05\x04\\\x02\x03\x01\x12\x04\x86\x07\
    \x18\x1f\n\r\n\x05\x04\\\x02\x03\x03\x12\x04\x86\x07\"#\n\x0c\n\x02\x04]\
    \x12\x06\x89\x07\0\x8d\x07\x01\n\x0b\n\x03\x04]\x01\x12\x04\x89\x07\x08\
    \x15\n\x0c\n\x04\x04]\x02\0\x12\x04\x8a\x07\x089\n\r\n\x05\x04]\x02\0\
    \x04\x12\x04\x8a\x07\x08\x10\n\r\n\x05\x04]\x02\0\x05\x12\x04\x8a\x07\
    \x11\x17\n\r\n\x05\x04]\x02\0\x01\x12\x04\x8a\x07\x18\x1f\n\r\n\x05\x04]\
    \x02\0\x03\x12\x04\x8a\x07\"#\n\r\n\x05\x04]\x02\0\x08\x12\x04\x8a\x07$8\
    \n\x10\n\x08\x04]\x02\0\x08\xe7\x07\0\x12\x04\x8a\x07%7\n\x11\n\t\x04]\
    \x02\0\x08\xe7\x07\0\x02\x12\x04\x8a\x07%0\n\x12\n\n\x04]\x02\0\x08\xe7\
    \x07\0\x02\0\x12\x04\x8a\x07%0\n\x13\n\x0b\x04]\x02\0\x08\xe7\x07\0\x02\
    \0\x01\x12\x04\x8a\x07&/\n\x11\n\t\x04]\x02\0\x08\xe7\x07\0\x03\x12\x04\
    \x8a\x0737\n\x0c\n\x04\x04]\x02\x01\x12\x04\x8b\x07\x08#\n\r\n\x05\x04]\
    \x02\x01\x04\x12\x04\x8b\x07\x08\x10\n\r\n\x05\x04]\x02\x01\x05\x12\x04\
    \x8b\x07\x11\x17\n\r\n\x05\x04]\x02\x01\x01\x12\x04\x8b\x07\x18\x1e\n\r\
    \n\x05\x04]\x02\x01\x03\x12\x04\x8b\x07!\"\n\x0c\n\x04\x04]\x02\x02\x12\
    \x04\x8c\x07\x08-\n\r\n\x05\x04]\x02\x02\x04\x12\x04\x8c\x07\x08\x10\n\r\
    \n\x05\x04]\x02\x02\x05\x12\x04\x8c\x07\x11\x18\n\r\n\x05\x04]\x02\x02\
    \x01\x12\x04\x8c\x07\x19(\n\r\n\x05\x04]\x02\x02\x03\x12\x04\x8c\x07+,\n\
    \x0c\n\x02\x04^\x12\x06\x8f\x07\0\x93\x07\x01\n\x0b\n\x03\x04^\x01\x12\
    \x04\x8f\x07\x08\x18\n\x0c\n\x04\x04^\x02\0\x12\x04\x90\x07\x089\n\r\n\
    \x05\x04^\x02\0\x04\x12\x04\x90\x07\x08\x10\n\r\n\x05\x04^\x02\0\x05\x12\
    \x04\x90\x07\x11\x17\n\r\n\x05\x04^\x02\0\x01\x12\x04\x90\x07\x18\x1f\n\
    \r\n\x05\x04^\x02\0\x03\x12\x04\x90\x07\"#\n\r\n\x05\x04^\x02\0\x08\x12\
    \x04\x90\x07$8\n\x10\n\x08\x04^\x02\0\x08\xe7\x07\0\x12\x04\x90\x07%7\n\
    \x11\n\t\x04^\x02\0\x08\xe7\x07\0\x02\x12\x04\x90\x07%0\n\x12\n\n\x04^\
    \x02\0\x08\xe7\x07\0\x02\0\x12\x04\x90\x07%0\n\x13\n\x0b\x04^\x02\0\x08\
    \xe7\x07\0\x02\0\x01\x12\x04\x90\x07&/\n\x11\n\t\x04^\x02\0\x08\xe7\x07\
    \0\x03\x12\x04\x90\x0737\n\x0c\n\x04\x04^\x02\x01\x12\x04\x91\x07\x08-\n\
    \r\n\x05\x04^\x02\x01\x04\x12\x04\x91\x07\x08\x10\n\r\n\x05\x04^\x02\x01\
    \x05\x12\x04\x91\x07\x11\x17\n\r\n\x05\x04^\x02\x01\x01\x12\x04\x91\x07\
    \x18(\n\r\n\x05\x04^\x02\x01\x03\x12\x04\x91\x07+,\n\x0c\n\x04\x04^\x02\
    \x02\x12\x04\x92\x07\x08)\n\r\n\x05\x04^\x02\x02\x04\x12\x04\x92\x07\x08\
    \x10\n\r\n\x05\x04^\x02\x02\x05\x12\x04\x92\x07\x11\x17\n\r\n\x05\x04^\
    \x02\x02\x01\x12\x04\x92\x07\x18$\n\r\n\x05\x04^\x02\x02\x03\x12\x04\x92\
    \x07'(\n\x0c\n\x02\x04_\x12\x06\x95\x07\0\x99\x07\x01\n\x0b\n\x03\x04_\
    \x01\x12\x04\x95\x07\x08\x1c\n\x0c\n\x04\x04_\x02\0\x12\x04\x96\x07\x08(\
    \n\r\n\x05\x04_\x02\0\x04\x12\x04\x96\x07\x08\x10\n\r\n\x05\x04_\x02\0\
    \x05\x12\x04\x96\x07\x11\x16\n\r\n\x05\x04_\x02\0\x01\x12\x04\x96\x07\
    \x17#\n\r\n\x05\x04_\x02\0\x03\x12\x04\x96\x07&'\n\x0c\n\x04\x04_\x02\
    \x01\x12\x04\x97\x07\x08:\n\r\n\x05\x04_\x02\x01\x04\x12\x04\x97\x07\x08\
    \x10\n\r\n\x05\x04_\x02\x01\x06\x12\x04\x97\x07\x11(\n\r\n\x05\x04_\x02\
    \x01\x01\x12\x04\x97\x07)5\n\r\n\x05\x04_\x02\x01\x03\x12\x04\x97\x0789\
    \n\x0c\n\x04\x04_\x02\x02\x12\x04\x98\x07\x08)\n\r\n\x05\x04_\x02\x02\
    \x04\x12\x04\x98\x07\x08\x10\n\r\n\x05\x04_\x02\x02\x05\x12\x04\x98\x07\
    \x11\x15\n\r\n\x05\x04_\x02\x02\x01\x12\x04\x98\x07\x16$\n\r\n\x05\x04_\
    \x02\x02\x03\x12\x04\x98\x07'(\n\x0c\n\x02\x04`\x12\x06\x9b\x07\0\x9d\
    \x07\x01\n\x0b\n\x03\x04`\x01\x12\x04\x9b\x07\x08#\n\x0c\n\x04\x04`\x02\
    \0\x12\x04\x9c\x07\x08#\n\r\n\x05\x04`\x02\0\x04\x12\x04\x9c\x07\x08\x10\
    \n\r\n\x05\x04`\x02\0\x05\x12\x04\x9c\x07\x11\x17\n\r\n\x05\x04`\x02\0\
    \x01\x12\x04\x9c\x07\x18\x1e\n\r\n\x05\x04`\x02\0\x03\x12\x04\x9c\x07!\"\
    \n\x0c\n\x02\x04a\x12\x06\x9f\x07\0\xa1\x07\x01\n\x0b\n\x03\x04a\x01\x12\
    \x04\x9f\x07\x08%\n\x0c\n\x04\x04a\x02\0\x12\x04\xa0\x07\x08$\n\r\n\x05\
    \x04a\x02\0\x04\x12\x04\xa0\x07\x08\x10\n\r\n\x05\x04a\x02\0\x05\x12\x04\
    \xa0\x07\x11\x16\n\r\n\x05\x04a\x02\0\x01\x12\x04\xa0\x07\x17\x1f\n\r\n\
    \x05\x04a\x02\0\x03\x12\x04\xa0\x07\"#\n\x0c\n\x02\x04b\x12\x06\xa3\x07\
    \0\xa7\x07\x01\n\x0b\n\x03\x04b\x01\x12\x04\xa3\x07\x08\x1e\n\x0c\n\x04\
    \x04b\x02\0\x12\x04\xa4\x07\x08#\n\r\n\x05\x04b\x02\0\x04\x12\x04\xa4\
    \x07\x08\x10\n\r\n\x05\x04b\x02\0\x05\x12\x04\xa4\x07\x11\x17\n\r\n\x05\
    \x04b\x02\0\x01\x12\x04\xa4\x07\x18\x1e\n\r\n\x05\x04b\x02\0\x03\x12\x04\
    \xa4\x07!\"\n\x0c\n\x04\x04b\x02\x01\x12\x04\xa5\x07\x08'\n\r\n\x05\x04b\
    \x02\x01\x04\x12\x04\xa5\x07\x08\x10\n\r\n\x05\x04b\x02\x01\x05\x12\x04\
    \xa5\x07\x11\x17\n\r\n\x05\x04b\x02\x01\x01\x12\x04\xa5\x07\x18\"\n\r\n\
    \x05\x04b\x02\x01\x03\x12\x04\xa5\x07%&\n\x0c\n\x04\x04b\x02\x02\x12\x04\
    \xa6\x07\x08'\n\r\n\x05\x04b\x02\x02\x04\x12\x04\xa6\x07\x08\x10\n\r\n\
    \x05\x04b\x02\x02\x05\x12\x04\xa6\x07\x11\x17\n\r\n\x05\x04b\x02\x02\x01\
    \x12\x04\xa6\x07\x18\"\n\r\n\x05\x04b\x02\x02\x03\x12\x04\xa6\x07%&\n\
    \x0c\n\x02\x04c\x12\x06\xa9\x07\0\xab\x07\x01\n\x0b\n\x03\x04c\x01\x12\
    \x04\xa9\x07\x08-\n\x0c\n\x04\x04c\x02\0\x12\x04\xaa\x07\x08(\n\r\n\x05\
    \x04c\x02\0\x04\x12\x04\xaa\x07\x08\x10\n\r\n\x05\x04c\x02\0\x05\x12\x04\
    \xaa\x07\x11\x16\n\r\n\x05\x04c\x02\0\x01\x12\x04\xaa\x07\x17#\n\r\n\x05\
    \x04c\x02\0\x03\x12\x04\xaa\x07&'\n\x0c\n\x02\x04d\x12\x06\xad\x07\0\xae\
    \x07\x01\n\x0b\n\x03\x04d\x01\x12\x04\xad\x07\x087\n\x0c\n\x02\x04e\x12\
    \x06\xb0\x07\0\xb3\x07\x01\n\x0b\n\x03\x04e\x01\x12\x04\xb0\x07\x080\n\
    \x0c\n\x04\x04e\x02\0\x12\x04\xb1\x07\x08#\n\r\n\x05\x04e\x02\0\x04\x12\
    \x04\xb1\x07\x08\x10\n\r\n\x05\x04e\x02\0\x05\x12\x04\xb1\x07\x11\x17\n\
    \r\n\x05\x04e\x02\0\x01\x12\x04\xb1\x07\x18\x1e\n\r\n\x05\x04e\x02\0\x03\
    \x12\x04\xb1\x07!\"\n\x0c\n\x04\x04e\x02\x01\x12\x04\xb2\x07\x08\x1e\n\r\
    \n\x05\x04e\x02\x01\x04\x12\x04\xb2\x07\x08\x10\n\r\n\x05\x04e\x02\x01\
    \x05\x12\x04\xb2\x07\x11\x16\n\r\n\x05\x04e\x02\x01\x01\x12\x04\xb2\x07\
    \x17\x19\n\r\n\x05\x04e\x02\x01\x03\x12\x04\xb2\x07\x1c\x1d\n\x0c\n\x02\
    \x04f\x12\x06\xb5\x07\0\xb7\x07\x01\n\x0b\n\x03\x04f\x01\x12\x04\xb5\x07\
    \x083\n\x0c\n\x04\x04f\x02\0\x12\x04\xb6\x07\x08\"\n\r\n\x05\x04f\x02\0\
    \x04\x12\x04\xb6\x07\x08\x10\n\r\n\x05\x04f\x02\0\x05\x12\x04\xb6\x07\
    \x11\x17\n\r\n\x05\x04f\x02\0\x01\x12\x04\xb6\x07\x18\x1d\n\r\n\x05\x04f\
    \x02\0\x03\x12\x04\xb6\x07\x20!\n\x0c\n\x02\x04g\x12\x06\xb9\x07\0\xbc\
    \x07\x01\n\x0b\n\x03\x04g\x01\x12\x04\xb9\x07\x08)\n\x0c\n\x04\x04g\x02\
    \0\x12\x04\xba\x07\x08%\n\r\n\x05\x04g\x02\0\x04\x12\x04\xba\x07\x08\x10\
    \n\r\n\x05\x04g\x02\0\x05\x12\x04\xba\x07\x11\x17\n\r\n\x05\x04g\x02\0\
    \x01\x12\x04\xba\x07\x18\x20\n\r\n\x05\x04g\x02\0\x03\x12\x04\xba\x07#$\
    \n\x0c\n\x04\x04g\x02\x01\x12\x04\xbb\x07\x08!\n\r\n\x05\x04g\x02\x01\
    \x04\x12\x04\xbb\x07\x08\x10\n\r\n\x05\x04g\x02\x01\x05\x12\x04\xbb\x07\
    \x11\x17\n\r\n\x05\x04g\x02\x01\x01\x12\x04\xbb\x07\x18\x1c\n\r\n\x05\
    \x04g\x02\x01\x03\x12\x04\xbb\x07\x1f\x20\n\x0c\n\x02\x04h\x12\x06\xbe\
    \x07\0\xc1\x07\x01\n\x0b\n\x03\x04h\x01\x12\x04\xbe\x07\x08)\n\x0c\n\x04\
    \x04h\x02\0\x12\x04\xbf\x07\x08'\n\r\n\x05\x04h\x02\0\x04\x12\x04\xbf\
    \x07\x08\x10\n\r\n\x05\x04h\x02\0\x05\x12\x04\xbf\x07\x11\x17\n\r\n\x05\
    \x04h\x02\0\x01\x12\x04\xbf\x07\x18\"\n\r\n\x05\x04h\x02\0\x03\x12\x04\
    \xbf\x07%&\n\x0c\n\x04\x04h\x02\x01\x12\x04\xc0\x07\x08!\n\r\n\x05\x04h\
    \x02\x01\x04\x12\x04\xc0\x07\x08\x10\n\r\n\x05\x04h\x02\x01\x05\x12\x04\
    \xc0\x07\x11\x17\n\r\n\x05\x04h\x02\x01\x01\x12\x04\xc0\x07\x18\x1c\n\r\
    \n\x05\x04h\x02\x01\x03\x12\x04\xc0\x07\x1f\x20\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
